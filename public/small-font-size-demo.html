<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HTML5 Canvas fillText - Very Small Font Sizes (0.5-12px)</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      margin: 20px;
      background: #f5f5f5;
      padding-bottom: 40px;
    }

    h1 {
      color: #333;
      border-bottom: 3px solid #FF9800;
      padding-bottom: 10px;
      margin-bottom: 10px;
    }

    .intro {
      background: #fff3e0;
      padding: 15px;
      border-radius: 5px;
      border-left: 4px solid #FF9800;
      margin-bottom: 20px;
      line-height: 1.6;
    }

    .intro strong {
      color: #E65100;
    }

    .size-section {
      background: white;
      margin: 20px 0;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .size-header {
      font-weight: bold;
      font-size: 20px;
      color: #FF9800;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #FFE0B2;
    }

    .canvas-grid {
      display: grid;
      grid-template-columns: auto auto 1fr;
      gap: 20px;
      align-items: start;
      margin-bottom: 10px;
    }

    .canvas-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .canvas-label {
      font-size: 13px;
      font-weight: 500;
      color: #666;
      margin-bottom: 8px;
      text-align: center;
    }

    canvas {
      border: 1px solid #ccc;
      background: white;

      /* CRITICAL: Crisp rendering CSS directives */
      image-rendering: pixelated;
      font-smooth: never;
      -webkit-font-smoothing: none;
      -moz-osx-font-smoothing: none;
    }

    .metrics-display {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 12px;
      background: #f5f5f5;
      padding: 12px;
      border-radius: 5px;
      line-height: 1.8;
    }

    .metrics-display .metric-row {
      margin: 2px 0;
    }

    .metrics-display .metric-label {
      color: #1976D2;
      display: inline-block;
      width: 180px;
    }

    .metrics-display .metric-value {
      color: #333;
      font-weight: 500;
    }

    .warning {
      background: #ffebee;
      padding: 10px;
      border-radius: 5px;
      border-left: 4px solid #f44336;
      margin-top: 10px;
      font-size: 14px;
      color: #c62828;
    }

    .back-link {
      display: inline-block;
      margin-top: 20px;
      padding: 10px 20px;
      background: #FF9800;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      font-weight: 500;
    }

    .back-link:hover {
      background: #F57C00;
    }
  </style>
</head>
<body>
  <h1>HTML5 Canvas fillText() at Very Small Font Sizes (0.5-12px)</h1>

  <div id="selectors" style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
    <label style="font-weight: 500; margin-right: 10px;">Font:</label>
    <!-- Font dropdowns will be inserted here by JavaScript -->

    <label style="margin-left: 15px; font-weight: 500;">Pixel Density:</label>
    <input type="radio" id="density-1" name="pixel-density" value="1" checked>
    <label for="density-1">1x</label>
    <input type="radio" id="density-2" name="pixel-density" value="2" style="margin-left: 10px;">
    <label for="density-2">2x</label>
    <input type="radio" id="density-4" name="pixel-density" value="4" style="margin-left: 10px;">
    <label for="density-4">4x</label>
    <span style="font-size: 11px; color: #666; margin-left: 5px;">(High-DPI Simulation)</span>
  </div>

  <div class="intro">
    <p>
      This demo tests how the standard HTML5 Canvas <code>fillText()</code> method handles
      extremely small font sizes at different pixel densities. Each size shows:
    </p>
    <ul>
      <li><strong>Original Canvas</strong> - Actual size with crisp rendering CSS applied</li>
      <li><strong>Magnified 5x</strong> - Constant 750×500px view for easy comparison across densities</li>
      <li><strong>Measurements</strong> - All <code>measureText()</code> metrics</li>
    </ul>
    <p>
      <strong>Test text:</strong> "The quick brown fox jumps over the lazy dog"<br>
      <strong>Pixel Density:</strong> Simulates high-DPI rendering (1x = standard, 2x = Retina, 4x = ultra-high-DPI)<br>
      <strong>Visualization:</strong> Red bounding box from actualBoundingBox metrics, red X at anchor point
    </p>
  </div>

  <div id="demo-container"></div>

  <a href="index.html" class="back-link">← Back to Demos Index</a>

  <script src="../src/ui/components/font-family-dropdown.js"></script>
  <script src="../src/ui/components/font-style-dropdown.js"></script>
  <script src="../src/ui/components/font-weight-dropdown.js"></script>

  <script>
    // Font sizes to test (0.5px to 12px in 0.5px increments)
    const fontSizes = [0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 8.5, 9, 9.5, 10, 10.5, 11, 11.5, 12];
    const testText = "The quick brown fox jumps over the lazy dog";
    const magnificationScale = 5;

    // Dropdown references
    let fontFamilySelect;
    let fontStyleSelect;
    let fontWeightSelect;

    // Initialize dropdowns
    function initializeDropdowns() {
      fontFamilySelect = addDropdownWithFontFamilies();
      fontStyleSelect = addFontStyleDropdown();
      fontWeightSelect = addFontWeightDropdown();

      // Set default to Arial to match original behavior
      fontFamilySelect.value = 'Arial';
    }

    // Get current font specification string
    function getCurrentFont(fontSize) {
      return `${fontStyleSelect.value} ${fontWeightSelect.value} ${fontSize}px ${fontFamilySelect.value}`;
    }

    // Get selected pixel density from radio buttons
    function getPixelDensity() {
      if (document.getElementById('density-4').checked) return 4;
      if (document.getElementById('density-2').checked) return 2;
      return 1;
    }

    // Re-render all content when dropdowns change (required callback for dropdown event handlers)
    function updatePageContent() {
      const container = document.getElementById("demo-container");
      container.innerHTML = "";
      fontSizes.forEach(fontSize => renderFontSize(fontSize));
    }

    // Create magnified canvas with constant 750×500 output size
    // For high-DPI canvases, downsamples to CSS-equivalent 150×100 pixels first, then magnifies 5×
    function createMagnifiedCanvas(sourceCanvas, scale, pixelDensity) {
      // Target CSS-equivalent size (what we want to magnify)
      const cssEquivWidth = 150;
      const cssEquivHeight = 100;

      // Create temporary canvas at CSS-equivalent size
      const tempCanvas = document.createElement("canvas");
      tempCanvas.width = cssEquivWidth;
      tempCanvas.height = cssEquivHeight;
      const tempCtx = tempCanvas.getContext("2d");

      // Draw source canvas scaled down to CSS-equivalent size
      // This effectively downsamples high-DPI canvases to show CSS pixel equivalents
      tempCtx.drawImage(sourceCanvas, 0, 0, sourceCanvas.width, sourceCanvas.height,
                                       0, 0, cssEquivWidth, cssEquivHeight);

      // Now magnify the CSS-equivalent canvas
      const magnifiedCanvas = document.createElement("canvas");
      magnifiedCanvas.width = cssEquivWidth * scale;
      magnifiedCanvas.height = cssEquivHeight * scale;
      magnifiedCanvas.style.imageRendering = "pixelated";

      const magnifiedCtx = magnifiedCanvas.getContext("2d");

      const imageData = tempCtx.getImageData(0, 0, cssEquivWidth, cssEquivHeight);
      const data = imageData.data;

      // Draw each pixel as a larger square
      for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % cssEquivWidth;
        const y = Math.floor((i / 4) / cssEquivWidth);

        const x2 = x * scale;
        const y2 = y * scale;

        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const a = data[i + 3] / 255;

        magnifiedCtx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
        magnifiedCtx.fillRect(x2, y2, scale, scale);
      }

      return magnifiedCanvas;
    }

    // Render text at a specific font size
    function renderFontSize(fontSize) {
      const container = document.getElementById("demo-container");

      // Create section for this font size
      const section = document.createElement("div");
      section.className = "size-section";

      const header = document.createElement("div");
      header.className = "size-header";
      header.textContent = `Font Size: ${fontSize}px`;
      section.appendChild(header);

      // Create grid layout
      const grid = document.createElement("div");
      grid.className = "canvas-grid";

      // ===== ORIGINAL CANVAS =====
      const originalWrapper = document.createElement("div");
      originalWrapper.className = "canvas-wrapper";

      const originalLabel = document.createElement("div");
      originalLabel.className = "canvas-label";
      const pixelDensity = getPixelDensity();
      originalLabel.textContent = `Original (Actual Size) - ${pixelDensity}x Density`;
      originalWrapper.appendChild(originalLabel);

      // Canvas sizing: physical pixels vs CSS pixels
      const cssWidth = 150;
      const cssHeight = 100;

      const canvas = document.createElement("canvas");
      canvas.width = cssWidth * pixelDensity;      // Physical pixels
      canvas.height = cssHeight * pixelDensity;    // Physical pixels
      canvas.style.width = cssWidth + 'px';        // CSS display size
      canvas.style.height = cssHeight + 'px';      // CSS display size
      canvas.style.imageRendering = "pixelated";

      // CRITICAL: Canvas must be in document.body for CSS font-smoothing to apply during fillText
      // (Setting via JavaScript doesn't work - canvas must be in DOM for CSS to apply)
      document.body.appendChild(canvas);

      const ctx = canvas.getContext("2d");

      // Scale context for pixel density
      // All coordinates below are in CSS pixels; scaling handles conversion to physical pixels
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(pixelDensity, pixelDensity);

      ctx.font = getCurrentFont(fontSize);

      // Position for text (in CSS pixels - centered vertically in canvas)
      const textX = 10;
      const textY = 50;

      // Get metrics before drawing
      const metrics = ctx.measureText(testText);

      // Draw the text
      ctx.fillStyle = "black";
      ctx.fillText(testText, textX, textY);

      // Draw anchor point (red X)
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      const xSize = 3;
      ctx.beginPath();
      ctx.moveTo(textX - xSize, textY - xSize);
      ctx.lineTo(textX + xSize, textY + xSize);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(textX + xSize, textY - xSize);
      ctx.lineTo(textX - xSize, textY + xSize);
      ctx.stroke();

      // Calculate bounding box
      const width = Math.abs(metrics.actualBoundingBoxLeft) + Math.abs(metrics.actualBoundingBoxRight);
      const height = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);

      const bounds = {
        top: textY - metrics.actualBoundingBoxAscent,
        right: textX + metrics.actualBoundingBoxRight,
        bottom: textY + metrics.actualBoundingBoxDescent,
        left: textX - metrics.actualBoundingBoxLeft
      };

      // Draw bounding box
      ctx.strokeStyle = "red";
      ctx.lineWidth = 1;
      ctx.strokeRect(bounds.left, bounds.top, width, height);

      // Restore context transform
      ctx.restore();

      // CRITICAL: Move canvas from document.body to its final display location
      // (All rendering is complete, CSS has applied, now move to proper parent)
      canvas.remove();
      originalWrapper.appendChild(canvas);

      grid.appendChild(originalWrapper);

      // ===== MAGNIFIED CANVAS =====
      const magnifiedWrapper = document.createElement("div");
      magnifiedWrapper.className = "canvas-wrapper";

      const magnifiedLabel = document.createElement("div");
      magnifiedLabel.className = "canvas-label";
      magnifiedLabel.textContent = `Magnified ${magnificationScale}x (${canvas.width}×${canvas.height} physical pixels)`;
      magnifiedWrapper.appendChild(magnifiedLabel);

      const magnifiedCanvas = createMagnifiedCanvas(canvas, magnificationScale, pixelDensity);
      magnifiedWrapper.appendChild(magnifiedCanvas);

      grid.appendChild(magnifiedWrapper);

      // ===== METRICS DISPLAY =====
      const metricsWrapper = document.createElement("div");

      const metricsDiv = document.createElement("div");
      metricsDiv.className = "metrics-display";

      // Helper to create metric row
      function addMetric(label, value) {
        const row = document.createElement("div");
        row.className = "metric-row";

        const labelSpan = document.createElement("span");
        labelSpan.className = "metric-label";
        labelSpan.textContent = label + ":";

        const valueSpan = document.createElement("span");
        valueSpan.className = "metric-value";
        valueSpan.textContent = typeof value === 'number' ? value.toFixed(4) : value;

        row.appendChild(labelSpan);
        row.appendChild(valueSpan);
        metricsDiv.appendChild(row);
      }

      addMetric("font", getCurrentFont(fontSize));
      addMetric("text", `"${testText}"`);
      addMetric("pixel density", `${pixelDensity}x`);
      addMetric("canvas (physical)", `${canvas.width}×${canvas.height} px`);
      addMetric("canvas (CSS)", `${cssWidth}×${cssHeight} px`);
      addMetric("width (advance)", metrics.width);
      addMetric("actualBoundingBoxLeft", metrics.actualBoundingBoxLeft);
      addMetric("actualBoundingBoxRight", metrics.actualBoundingBoxRight);
      addMetric("actualBoundingBoxAscent", metrics.actualBoundingBoxAscent);
      addMetric("actualBoundingBoxDescent", metrics.actualBoundingBoxDescent);
      addMetric("calculated width", width);
      addMetric("calculated height", height);

      metricsWrapper.appendChild(metricsDiv);

      // Check for potential issues
      if (width === 0 || height === 0) {
        const warning = document.createElement("div");
        warning.className = "warning";
        warning.textContent = "⚠️ WARNING: Bounding box has zero width or height - text may not be rendering!";
        metricsWrapper.appendChild(warning);
      }

      if (metrics.actualBoundingBoxAscent === 0 && metrics.actualBoundingBoxDescent === 0) {
        const warning = document.createElement("div");
        warning.className = "warning";
        warning.textContent = "⚠️ WARNING: No vertical metrics detected - text likely invisible!";
        metricsWrapper.appendChild(warning);
      }

      grid.appendChild(metricsWrapper);

      section.appendChild(grid);
      container.appendChild(section);
    }

    // Initialize dropdowns and render all font sizes
    initializeDropdowns();
    updatePageContent();

    // Add event listeners for pixel density radio buttons
    document.querySelectorAll('input[name="pixel-density"]').forEach(radio => {
      radio.addEventListener('change', updatePageContent);
    });
  </script>
</body>
</html>
