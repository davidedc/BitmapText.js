<!DOCTYPE html>
<html lang="">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Uniform Pixel Perfect JS Canvas Text Renderer</title>
  <style>
    body {
      padding: 0;
      margin: 0;
      background-color: #d4ffd4;
    }
    canvas {
      font-smooth: never;
      -webkit-font-smoothing: none;
      -moz-osx-font-smoothing: none;
      /* 1 pixel border around canvas */
      /* border: 1px solid #000; */
      margin-left: 3px;
    }
  </style>
</head>

<body>
  <main>
    <div id="selectors"></div>
    <div id="testCopyCanvases" style="clear:both;"></div>

    <!-- VALIDATION HARNESS SECTION (Phase 0) -->
    <div id="validation-section" style="margin-top: 40px; border-top: 3px solid #333; padding-top: 20px;">
      <h2>üî¨ Validation Harness: Atlas ‚Üí Tight Atlas Reconstruction</h2>
      <p style="font-size: 14px; color: #666; margin: 5px 0;">
        Validation runs automatically when you change font settings above. You can also click the button to re-run manually.
      </p>

      <button onclick="runValidationHarness()" style="font-size: 16px; padding: 10px 20px; margin: 10px 0;">
        Re-run Validation
      </button>

      <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-top: 20px;">
        <!-- Column 1: Current (Control) -->
        <div>
          <h3>PATH A: Tight Atlas (Current)</h3>
          <canvas id="tight-atlas-current" data-validation="true" style="border: 1px solid #ccc; image-rendering: pixelated;"></canvas>
          <div id="tight-atlas-current-info" style="font-family: monospace; font-size: 12px;"></div>
          <canvas id="current-render" data-validation="true" style="border: 1px solid #ccc; margin-top: 10px;"></canvas>
        </div>

        <!-- Column 2: Atlas Source -->
        <div>
          <h3>PATH B: Atlas (Source)</h3>
          <canvas id="atlas-source" data-validation="true" style="border: 1px solid #ccc; image-rendering: pixelated;"></canvas>
          <div id="atlas-source-info" style="font-family: monospace; font-size: 12px;"></div>
        </div>

        <!-- Column 3: Reconstructed -->
        <div>
          <h3>PATH B: Tight Atlas (Reconstructed)</h3>
          <canvas id="tight-atlas-reconstructed" data-validation="true" style="border: 1px solid #ccc; image-rendering: pixelated;"></canvas>
          <div id="tight-atlas-reconstructed-info" style="font-family: monospace; font-size: 12px;"></div>
          <canvas id="reconstructed-render" data-validation="true" style="border: 1px solid #ccc; margin-top: 10px;"></canvas>
        </div>
      </div>

      <!-- Comparison Results -->
      <div id="comparison-results" style="margin-top: 20px; padding: 20px; background: #f0f0f0; border-radius: 5px;">
        <h3>üìä Comparison Results</h3>

        <div id="atlas-comparison" style="margin: 10px 0;">
          <h4>Atlas Image Comparison:</h4>
          <div id="atlas-pixel-diff"></div>
        </div>

        <div id="positioning-comparison" style="margin: 10px 0;">
          <h4>Positioning Data Comparison:</h4>
          <div id="positioning-diff-summary"></div>
          <table id="positioning-diff-table" style="font-family: monospace; font-size: 11px; border-collapse: collapse; margin-top: 10px;">
          </table>
        </div>

        <div id="render-comparison" style="margin: 10px 0;">
          <h4>Render Comparison:</h4>
          <div id="render-hash-diff"></div>
        </div>

        <div id="performance-metrics" style="margin: 10px 0;">
          <h4>Performance Metrics:</h4>
          <div id="reconstruction-time"></div>
        </div>

        <div id="file-size-estimates" style="margin: 10px 0;">
          <h4>File Size Estimates:</h4>
          <div id="size-comparison"></div>
        </div>
      </div>
    </div>
  </main>
</body>

<script src="../lib/jszip.min.js"></script>
<script src="../lib/FileSaver.min.js"></script>
<script src="../lib/QOIEncode.js"></script>

<script src="../src/utils/timing.js"></script>

<script >
  const maxFontSize_px = 80;
  const fontSizeIncrement_px = 0.5;
  let specsDefault;
  function updatePageContent() {
    buildAndShowGlyphs();
    // Also run validation harness to keep it in sync with UI
    // Check if validation function exists (it's defined later in the page)
    if (typeof runValidationHarness === 'function') {
      runValidationHarness();
    }
  }
</script>

<script src="../src/core/StatusCode.js"></script>
<script src="../src/core/FontProperties.js"></script>
<script src="../src/core/TextProperties.js"></script>
<script src="../src/font-assets-builder-FAB/FontPropertiesFAB.js"></script>
<script src="../src/core/FontMetrics.js"></script>
<script src="../src/font-assets-builder-FAB/FontMetricsFAB.js"></script>
<script src="../src/core/AtlasPositioning.js"></script>
<script src="../src/font-assets-builder-FAB/AtlasPositioningFAB.js"></script>
<script src="../src/core/AtlasImage.js"></script>
<script src="../src/core/AtlasData.js"></script>
<script src="../src/minification/AtlasReconstructionUtils.js"></script>
<script src="../src/minification/AtlasDataMinifier.js"></script>
<script src="../src/minification/AtlasDataExpander.js"></script>
<!-- NEW: Phase 0 validation utilities -->
<script src="../src/minification/AtlasBuilder.js"></script>
<script src="../src/core/TightAtlasReconstructor.js"></script>
<script src="../src/utils/HashStore.js"></script>
<script src="../test/data/reference-hashes.js"></script>
<script src="../src/utils/canvas-extensions.js"></script>
<script src="../src/font-assets-builder-FAB/GlyphFAB.js"></script>
<script src="../src/core/AtlasDataStore.js"></script>
<script src="../src/core/FontMetricsStore.js"></script>
<script src="../src/font-assets-builder-FAB/AtlasImageFAB.js"></script>
<script src="../src/font-assets-builder-FAB/AtlasDataStoreFAB.js"></script>
<script src="../src/font-assets-builder-FAB/FontMetricsStoreFAB.js"></script>
<script src="../src/core/BitmapText.js"></script>
<script src="../src/font-assets-builder-FAB/BitmapTextFAB.js"></script>
<script src="../src/specs/SpecsParser.js"></script>
<script src="../src/specs/Specs.js"></script>
<script src="../src/specs/default-specs.js"></script>
<script src="../test/utils/test-copy.js"></script>
<script src="../test/utils/draw-test-text.js"></script>
<script src="../src/utils/dom-cleanup.js"></script>
<script src="../test/utils/show-glyphs.js"></script>
<script src="../test/utils/build-show-glyphs.js"></script>
<script src="../test/utils/create-glyphs.js"></script>
<script src="../src/ui/components/copy-choice.js"></script>
<script src="../src/ui/components/pixel-density.js"></script>
<script src="../src/ui/components/font-family-dropdown.js"></script>
<script src="../src/ui/components/font-style-dropdown.js"></script>
<script src="../src/ui/components/font-weight-dropdown.js"></script>
<script src="../src/ui/components/size-buttons.js"></script>
<script src="../src/ui/base-ui.js"></script>
<script src="../src/ui/font-assets-builder-ui.js"></script>
<script src="../tools/export-font-data.js"></script>
<script src="../src/minification/MetricsMinifier.js"></script>
<!-- needed to test the roundtrip minification + expansion works -->
<script src="../src/minification/MetricsExpander.js"></script>
<script src="../src/utils/deep-equal.js"></script>

<script >
  const atlasDataStoreFAB = new AtlasDataStoreFAB();
  const fontMetricsStoreFAB = new FontMetricsStoreFAB();
  const bitmapTextFAB = new BitmapTextFAB(atlasDataStoreFAB, fontMetricsStoreFAB);

  updatePageContent();
</script>

<!-- VALIDATION HARNESS JAVASCRIPT (Phase 0) -->
<script>
  function runValidationHarness() {
    console.log('üî¨ Starting Validation Harness...');

    // Get current font properties from the UI state
    const currentFontProperties = getFontPropertiesFromUI();
    console.log('Using font properties from UI:', currentFontProperties);

    try {
      // PATH A: Reuse the tight atlas already built by buildAndShowGlyphs()
      // No need to rebuild - glyphs and atlas are already in atlasDataStoreFAB
      const currentAtlasData = atlasDataStoreFAB.getAtlasData(currentFontProperties);

      if (!currentAtlasData) {
        throw new Error('No atlas data found - buildAndShowGlyphs() should have created it');
      }

      const currentAtlasPositioning = currentAtlasData.atlasPositioning;

      // PATH B: Atlas ‚Üí Reconstructed tight
      console.time('PATH B: Atlas build');
      const atlasResult = atlasDataStoreFAB.buildAtlas(currentFontProperties, fontMetricsStoreFAB);
      console.timeEnd('PATH B: Atlas build');

      console.time('PATH B: Tight atlas reconstruction');
      const reconstructedAtlasData = atlasDataStoreFAB.reconstructTightAtlas(
        atlasResult.canvas,
        currentFontProperties,
        fontMetricsStoreFAB
      );
      console.timeEnd('PATH B: Tight atlas reconstruction');

      // Display atlases
      displayAtlasCanvas(currentAtlasData.atlasImage.image, 'tight-atlas-current');
      displayAtlasCanvas(atlasResult.canvas, 'atlas-source');
      displayAtlasCanvas(reconstructedAtlasData.atlasImage.image, 'tight-atlas-reconstructed');

      // Display info using the same format as the main atlases, including positioning hash
      displayAtlasInfo(currentAtlasData.atlasImage.image, 'tight-atlas-current-info', currentFontProperties, 'tight atlas (current)', currentAtlasData.atlasPositioning);
      displayAtlasInfo(atlasResult.canvas, 'atlas-source-info', currentFontProperties, 'atlas', null);
      displayAtlasInfo(reconstructedAtlasData.atlasImage.image, 'tight-atlas-reconstructed-info', currentFontProperties, 'tight atlas (reconstructed)', reconstructedAtlasData.atlasPositioning);

      // Render both
      const currentRenderCanvas = document.getElementById('current-render');
      const reconstructedRenderCanvas = document.getElementById('reconstructed-render');

      renderTestText(currentRenderCanvas, currentAtlasData, currentFontProperties);
      renderTestText(reconstructedRenderCanvas, reconstructedAtlasData, currentFontProperties);


      // COMPARE EVERYTHING
      const comparison = {
        atlasPixelDiff: compareAtlasImages(
          currentAtlasData.atlasImage.image,
          reconstructedAtlasData.atlasImage.image
        ),
        positioningDiff: comparePositioning(
          currentAtlasPositioning,
          reconstructedAtlasData.atlasPositioning
        ),
        renderHashDiff: compareRenderHashes(
          currentRenderCanvas,
          reconstructedRenderCanvas
        )
      };

      // Display comparison results
      displayComparisonResults(comparison, atlasResult);

      // Final verdict
      const resultsDiv = document.getElementById('comparison-results');
      if (comparison.atlasPixelDiff === 0 &&
          comparison.positioningDiff.totalDifferences === 0 &&
          comparison.renderHashDiff.identical) {
        console.log('‚úÖ VALIDATION PASSED: Perfect match!');
        resultsDiv.style.background = '#d4edda';
        resultsDiv.innerHTML = '<h2 style="color: #155724;">‚úÖ VALIDATION PASSED</h2>' + resultsDiv.innerHTML;
      } else {
        console.error('‚ùå VALIDATION FAILED: Differences detected');
        resultsDiv.style.background = '#f8d7da';
        resultsDiv.innerHTML = '<h2 style="color: #721c24;">‚ùå VALIDATION FAILED</h2>' + resultsDiv.innerHTML;
        console.log('Differences:', comparison);
      }

    } catch (error) {
      console.error('Validation harness error:', error);
      const resultsDiv = document.getElementById('comparison-results');
      resultsDiv.style.background = '#f8d7da';
      resultsDiv.innerHTML = `<h2 style="color: #721c24;">‚ùå ERROR</h2><p>${error.message}</p><pre>${error.stack}</pre>`;
    }
  }

  function displayAtlasCanvas(sourceCanvas, targetId) {
    const target = document.getElementById(targetId);
    target.width = sourceCanvas.width;
    target.height = sourceCanvas.height;
    const ctx = target.getContext('2d');
    ctx.drawImage(sourceCanvas, 0, 0);
  }

  function displayAtlasInfo(canvas, targetDivId, fontProperties, hashSuffix, atlasPositioning = null) {
    const targetDiv = document.getElementById(targetDivId);
    const ctx = canvas.getContext('2d');
    const hashString = ctx.getHashString();

    // Get hash match info if available
    let additionalInfo = '';
    if (typeof calculateFontPropertiesHashKey === 'function' && typeof hashStore !== 'undefined') {
      const hashKey = calculateFontPropertiesHashKey(fontProperties, hashSuffix);
      const result = hashStore.compareHash(hashKey, hashString);
      additionalInfo = result.message || '';
    }

    // Add positioning hash if available
    let positioningHashInfo = '';
    if (atlasPositioning && typeof atlasPositioning.getHash === 'function') {
      const posHash = atlasPositioning.getHash();
      positioningHashInfo = ` pos: ${posHash}`;
    }

    targetDiv.innerHTML = `${canvas.width} x ${canvas.height} hash: ${hashString}${positioningHashInfo} ${additionalInfo}`;
  }

  function comparePositioning(posA, posB) {
    const charsA = posA.getAvailableCharacters().sort();
    const charsB = posB.getAvailableCharacters().sort();

    const differences = {
      tightWidth: [],
      tightHeight: [],
      dx: [],
      dy: [],
      xInAtlas: [],
      totalDifferences: 0,
      characterCountMismatch: charsA.length !== charsB.length
    };

    for (const char of charsA) {
      const a = posA.getPositioning(char);
      const b = posB.getPositioning(char);

      if (!b || b.tightWidth === undefined) {
        differences.totalDifferences++;
        continue;
      }

      if (a.tightWidth !== b.tightWidth) {
        differences.tightWidth.push({char, a: a.tightWidth, b: b.tightWidth});
        differences.totalDifferences++;
      }
      if (a.tightHeight !== b.tightHeight) {
        differences.tightHeight.push({char, a: a.tightHeight, b: b.tightHeight});
        differences.totalDifferences++;
      }
      if (a.dx !== b.dx) {
        differences.dx.push({char, a: a.dx, b: b.dx});
        differences.totalDifferences++;
      }
      if (a.dy !== b.dy) {
        differences.dy.push({char, a: a.dy, b: b.dy});
        differences.totalDifferences++;
      }
      if (a.xInAtlas !== b.xInAtlas) {
        differences.xInAtlas.push({char, a: a.xInAtlas, b: b.xInAtlas});
        differences.totalDifferences++;
      }
    }

    return differences;
  }

  function compareAtlasImages(imgA, imgB) {
    if (imgA.width !== imgB.width || imgA.height !== imgB.height) {
      console.error(`Atlas dimension mismatch: A=${imgA.width}√ó${imgA.height}, B=${imgB.width}√ó${imgB.height}`);
      return -1; // Dimension mismatch
    }

    const ctxA = document.createElement('canvas').getContext('2d');
    ctxA.canvas.width = imgA.width;
    ctxA.canvas.height = imgA.height;
    ctxA.drawImage(imgA, 0, 0);
    const dataA = ctxA.getImageData(0, 0, imgA.width, imgA.height).data;

    const ctxB = document.createElement('canvas').getContext('2d');
    ctxB.canvas.width = imgB.width;
    ctxB.canvas.height = imgB.height;
    ctxB.drawImage(imgB, 0, 0);
    const dataB = ctxB.getImageData(0, 0, imgB.width, imgB.height).data;

    let diffCount = 0;
    let firstDiffPixel = null;
    for (let i = 0; i < dataA.length; i += 4) {
      const pixelIndex = i / 4;
      const x = pixelIndex % imgA.width;
      const y = Math.floor(pixelIndex / imgA.width);

      const rDiff = dataA[i] !== dataB[i];
      const gDiff = dataA[i+1] !== dataB[i+1];
      const bDiff = dataA[i+2] !== dataB[i+2];
      const aDiff = dataA[i+3] !== dataB[i+3];

      if (rDiff || gDiff || bDiff || aDiff) {
        if (!firstDiffPixel) {
          firstDiffPixel = {
            x, y,
            a: { r: dataA[i], g: dataA[i+1], b: dataA[i+2], a: dataA[i+3] },
            b: { r: dataB[i], g: dataB[i+1], b: dataB[i+2], a: dataB[i+3] }
          };
        }
        diffCount++;
      }
    }

    if (firstDiffPixel) {
      console.log(`First pixel difference at (${firstDiffPixel.x}, ${firstDiffPixel.y}):`);
      console.log(`  PATH A: rgba(${firstDiffPixel.a.r}, ${firstDiffPixel.a.g}, ${firstDiffPixel.a.b}, ${firstDiffPixel.a.a})`);
      console.log(`  PATH B: rgba(${firstDiffPixel.b.r}, ${firstDiffPixel.b.g}, ${firstDiffPixel.b.b}, ${firstDiffPixel.b.a})`);
    }

    return diffCount;
  }

  function compareRenderHashes(canvasA, canvasB) {
    const hashA = canvasA.getHash ? canvasA.getHash() : 'N/A';
    const hashB = canvasB.getHash ? canvasB.getHash() : 'N/A';

    return {
      hashA,
      hashB,
      identical: hashA === hashB
    };
  }

  function displayComparisonResults(comparison, atlasResult) {
    // Atlas comparison
    const atlasDiv = document.getElementById('atlas-pixel-diff');
    if (comparison.atlasPixelDiff === -1) {
      atlasDiv.innerHTML = '‚ùå Dimension mismatch';
      atlasDiv.style.color = '#721c24';
    } else if (comparison.atlasPixelDiff === 0) {
      atlasDiv.innerHTML = '‚úÖ Perfect match (0 pixel differences)';
      atlasDiv.style.color = '#155724';
    } else {
      atlasDiv.innerHTML = `‚ùå ${comparison.atlasPixelDiff} pixel differences`;
      atlasDiv.style.color = '#721c24';
    }

    // Positioning comparison
    const posDiv = document.getElementById('positioning-diff-summary');
    if (comparison.positioningDiff.totalDifferences === 0) {
      posDiv.innerHTML = '‚úÖ Perfect match (0 differences across all properties)';
      posDiv.style.color = '#155724';
    } else {
      posDiv.innerHTML = `‚ùå ${comparison.positioningDiff.totalDifferences} total differences`;
      posDiv.style.color = '#721c24';

      // Build detailed table
      const table = document.getElementById('positioning-diff-table');
      let html = '<tr style="background: #ddd;"><th style="padding: 5px; border: 1px solid #999;">Property</th><th style="padding: 5px; border: 1px solid #999;">Char</th><th style="padding: 5px; border: 1px solid #999;">Path A</th><th style="padding: 5px; border: 1px solid #999;">Path B</th></tr>';

      for (const prop of ['tightWidth', 'tightHeight', 'dx', 'dy', 'xInAtlas']) {
        for (const diff of comparison.positioningDiff[prop]) {
          const charDisplay = diff.char === ' ' ? 'SPACE' : diff.char;
          html += `<tr><td style="padding: 5px; border: 1px solid #ccc;">${prop}</td><td style="padding: 5px; border: 1px solid #ccc;">${charDisplay}</td><td style="padding: 5px; border: 1px solid #ccc;">${diff.a}</td><td style="padding: 5px; border: 1px solid #ccc;">${diff.b}</td></tr>`;
        }
      }
      table.innerHTML = html;
    }

    // Render comparison
    const renderDiv = document.getElementById('render-hash-diff');
    if (comparison.renderHashDiff.identical) {
      renderDiv.innerHTML = `‚úÖ Perfect match (Hash: ${comparison.renderHashDiff.hashA})`;
      renderDiv.style.color = '#155724';
    } else {
      renderDiv.innerHTML = `‚ùå Hashes differ:<br>Path A: ${comparison.renderHashDiff.hashA}<br>Path B: ${comparison.renderHashDiff.hashB}`;
      renderDiv.style.color = '#721c24';
    }

    // File size estimates
    const sizeDiv = document.getElementById('size-comparison');
    if (atlasResult) {
      const atlasSize = atlasResult.canvas.width * atlasResult.canvas.height * 4;
      const atlasSizeKB = (atlasSize / 1024).toFixed(2);
      sizeDiv.innerHTML = `Atlas: ${atlasResult.canvas.width}√ó${atlasResult.canvas.height} = ${atlasSizeKB} KB uncompressed<br>` +
                          `Estimated PNG: ~${(atlasSize * 0.015 / 1024).toFixed(2)} KB (1.5% compression ratio estimate)`;
    }
  }

  function renderTestText(canvas, atlasData, fontProperties) {
    canvas.width = 800;
    canvas.height = 200;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Create temporary atlas store for this specific test
    const tempAtlasStore = new AtlasDataStore();
    tempAtlasStore.setAtlasData(fontProperties, atlasData);

    // Create temporary metrics store (use existing metrics)
    const tempMetricsStore = new FontMetricsStore();
    const fontMetrics = fontMetricsStoreFAB.getFontMetrics(fontProperties);
    if (fontMetrics) {
      tempMetricsStore.setFontMetrics(fontProperties, fontMetrics);
    }

    const tempBitmapText = new BitmapText(tempAtlasStore, tempMetricsStore);

    const testText = "Hello World! ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const textProps = new TextProperties();
    tempBitmapText.drawTextFromAtlas(ctx, testText, 10, 50, fontProperties, textProps);
  }

  // Run validation on initial page load
  runValidationHarness();
</script>


</html>