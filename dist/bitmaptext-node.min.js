const StatusCode=Object.freeze({SUCCESS:0,NO_METRICS:1,PARTIAL_METRICS:2,NO_ATLAS:3,PARTIAL_ATLAS:4}),SUCCESS_STATUS=Object.freeze({code:StatusCode.SUCCESS});function createErrorStatus(t,e={}){return Object.freeze({code:t,...e})}function isSuccess(t){return t?.code===StatusCode.SUCCESS}function isCompleteFailure(t){return t&&(t.code===StatusCode.NO_METRICS||t.code===StatusCode.PARTIAL_METRICS)}function isPartialSuccess(t){return t&&(t.code===StatusCode.NO_ATLAS||t.code===StatusCode.PARTIAL_ATLAS)}function getStatusDescription(t){if(!t||"number"!=typeof t.code)return"Invalid status";switch(t.code){case StatusCode.SUCCESS:return"Success";case StatusCode.NO_METRICS:return t.requiresMinSize?`Font size ${t.requestedSize}px requires size ${t.minSize}px metrics for interpolation. Please load size ${t.minSize}px font assets.`:"No font metrics available";case StatusCode.PARTIAL_METRICS:return`Missing metrics for characters: ${t.missingChars?[...t.missingChars].join(""):"unknown"}`;case StatusCode.NO_ATLAS:return"No atlas available (using placeholders)";case StatusCode.PARTIAL_ATLAS:return`Missing atlas data for characters: ${t.missingAtlasChars?[...t.missingAtlasChars].join(""):"unknown"} (using placeholders)`;default:return`Unknown status code: ${t.code}`}}class FontProperties{constructor(t,e,a,i,r){this.pixelDensity=t||1,this.fontFamily=e,this.fontStyle=a||"normal",this.fontWeight=i||"normal",this.fontSize=r,this._key=`${this.pixelDensity}:${this.fontFamily}:${this.fontStyle}:${this.fontWeight}:${this.fontSize}`,this._idString=`density-${this.#t(this.pixelDensity)}-${this.fontFamily}-style-${this.fontStyle}-weight-${this.fontWeight}-size-${this.#t(this.fontSize)}`,Object.freeze(this)}#t(t){const e=String(t);return e.includes(".")?e.replace(".","-"):`${e}-0`}get key(){return this._key}get idString(){return this._idString}static fromIDString(t){const e=t.split("-"),a=parseFloat(FontProperties.#e(e[1],e[2])),i=parseFloat(FontProperties.#e(e[9],e[10])),r=e[3],s=e[5],n=e[7];return new FontProperties(a,r,s,n,i)}static fromKey(t){const[e,a,i,r,s]=t.split(":");return new FontProperties(parseFloat(e),a,i,r,parseFloat(s))}static#e(t,e){return e&&"0"!==e?`${t}.${e}`:t}equals(t){return t instanceof FontProperties&&this._key===t._key}}class TextProperties{constructor(t={}){const{isKerningEnabled:e=!0,textBaseline:a="bottom",textAlign:i="left",textColor:r="#000000"}=t;this.isKerningEnabled=e,this.textBaseline=a,this.textAlign=i,this.textColor=r,this._key=`kerning:${this.isKerningEnabled}:baseline:${this.textBaseline}:align:${this.textAlign}:color:${this.textColor}`,Object.freeze(this)}get key(){return this._key}static withKerning(t,e={}){return new TextProperties({...e,isKerningEnabled:t})}static withColor(t,e={}){return new TextProperties({...e,textColor:t})}static forBitmapText(t={}){return new TextProperties({textBaseline:"bottom",...t})}withKerningEnabled(t){return new TextProperties({isKerningEnabled:t,textBaseline:this.textBaseline,textAlign:this.textAlign,textColor:this.textColor})}withTextColor(t){return new TextProperties({isKerningEnabled:this.isKerningEnabled,textBaseline:this.textBaseline,textAlign:this.textAlign,textColor:t})}equals(t){return t instanceof TextProperties&&this._key===t._key}toObject(){return{isKerningEnabled:this.isKerningEnabled,textBaseline:this.textBaseline,textAlign:this.textAlign,textColor:this.textColor}}}class FontMetrics{constructor(t,e={}){if(!t||"object"!=typeof t)throw new Error("FontMetrics constructor requires data object");this._kerningTable=t.kerningTable||{},this._characterMetrics=t.characterMetrics||{},this._spaceAdvancementOverride=t.spaceAdvancementOverrideForSmallSizesInPx||null,e.mutable||(Object.freeze(this._kerningTable),Object.freeze(this._characterMetrics),Object.freeze(this))}getCharacterMetrics(t){return this._characterMetrics[t]}getKerningAdjustment(t,e){return t&&e&&this._kerningTable[t]?.[e]||0}hasGlyph(t){return t in this._characterMetrics}getSpaceAdvancementOverride(){return this._spaceAdvancementOverride}getKerningTable(){return this._kerningTable}getAvailableCharacters(){return Object.keys(this._characterMetrics)}}class InterpolatedFontMetrics{constructor(t,e){this.baseFontMetrics=t,this.targetSize=e,this.interpolationFactor=e/8.5,this.isInterpolatedMetrics=!0}getCharacterMetrics(t){const e=this.baseFontMetrics.getCharacterMetrics(t);return e?{actualBoundingBoxLeft:e.actualBoundingBoxLeft*this.interpolationFactor,actualBoundingBoxRight:e.actualBoundingBoxRight*this.interpolationFactor,actualBoundingBoxAscent:e.actualBoundingBoxAscent*this.interpolationFactor,actualBoundingBoxDescent:e.actualBoundingBoxDescent*this.interpolationFactor,fontBoundingBoxAscent:e.fontBoundingBoxAscent*this.interpolationFactor,fontBoundingBoxDescent:e.fontBoundingBoxDescent*this.interpolationFactor,width:e.width*this.interpolationFactor}:null}hasGlyph(t){return this.baseFontMetrics.hasGlyph(t)}getKerningAdjustment(t,e){return this.baseFontMetrics.getKerningAdjustment(t,e)*this.interpolationFactor}getKerningTable(){return this.baseFontMetrics.getKerningTable()}getSpaceAdvancementOverride(){const t=this.baseFontMetrics.getSpaceAdvancementOverride();return null!==t?t*this.interpolationFactor:null}get fontSize(){return this.targetSize}get alphabeticBaseline_ab(){return this.baseFontMetrics.alphabeticBaseline_ab*this.interpolationFactor}get hangingBaseline_ab(){return this.baseFontMetrics.hangingBaseline_ab*this.interpolationFactor}get ideographicBaseline_ab(){return this.baseFontMetrics.ideographicBaseline_ab*this.interpolationFactor}get middleBaseline_ab(){return this.baseFontMetrics.middleBaseline_ab*this.interpolationFactor}get topBaseline_ab(){return this.baseFontMetrics.topBaseline_ab*this.interpolationFactor}}if(void 0===StatusCode||void 0===SUCCESS_STATUS||void 0===createErrorStatus)throw new Error("StatusCode.js must be loaded before BitmapText.js");class BitmapText{static KERNING_UNIT_DIVISOR=1e3;static MIN_RENDERABLE_SIZE=8.5;static METRICS_PREFIX="metrics-";static ATLAS_PREFIX="atlas-";static WEBP_EXTENSION=".webp";static QOI_EXTENSION=".qoi";static JS_EXTENSION=".js";static#a="#000000";static CHARACTER_SET=BitmapText.#i();static FONT_INVARIANT_CHARS="‚ò∫‚òπ‚ô†‚ô°‚ô¶‚ô£‚îÇ‚îÄ‚îú‚îî‚ñ∂‚ñº‚ñ≤‚óÄ‚úî‚úò‚â†‚Üó";static FONT_INVARIANT_CHAR_SET=Array.from(BitmapText.FONT_INVARIANT_CHARS);static INVARIANT_FONT_FAMILY="BitmapTextInvariant";static#r(t){return BitmapText.FONT_INVARIANT_CHARS.includes(t)}static calculateOptimalGridDimensions(t){if(t<=0)throw new Error("BitmapText: Character count must be positive");const e=Math.ceil(Math.sqrt(t));return{columns:e,rows:Math.ceil(t/e)}}static#s="undefined"!=typeof document?()=>document.createElement("canvas"):null;static#n=null;static#o=null;static#l=null;static setFontDirectory(t){BitmapText.#c(),BitmapText.#l.setFontDirectory(t)}static getFontDirectory(){return BitmapText.#c(),BitmapText.#l.getFontDirectory()}static setCanvasFactory(t){BitmapText.#s=t,BitmapText.#n=null,BitmapText.#o=null}static getCanvasFactory(){return BitmapText.#s}static configure(t={}){void 0!==t.fontDirectory&&BitmapText.setFontDirectory(t.fontDirectory),void 0!==t.canvasFactory&&BitmapText.setCanvasFactory(t.canvasFactory)}static#c(){if(!BitmapText.#l){if(void 0===FontLoader)throw new Error('BitmapText: FontLoader not loaded.\nEnsure platform-specific FontLoader is included before BitmapText.js:\n  - Browser: <script src="src/platform/FontLoader-browser.js"><\/script>\n  - Node.js: Include src/platform/FontLoader-node.js in bundle');BitmapText.#l=FontLoader}}static#d(t){return t<BitmapText.MIN_RENDERABLE_SIZE}static#h(t){return new FontProperties(t.pixelDensity,t.fontFamily,t.fontStyle,t.fontWeight,BitmapText.MIN_RENDERABLE_SIZE)}static#g(t,e){return new InterpolatedFontMetrics(t,e)}static#u(t,e=!1){const a=FontProperties.fromIDString(t);if(BitmapText.#d(a.fontSize)){const t=BitmapText.#h(a);return e||console.warn(`BitmapText: Font size ${a.fontSize}px requested. Redirecting to size ${BitmapText.MIN_RENDERABLE_SIZE}px (minimum supported size). Sizes < ${BitmapText.MIN_RENDERABLE_SIZE}px render using interpolated placeholder rectangles.`),{redirected:!0,idString:t.idString,originalSize:a.fontSize}}return{redirected:!1,idString:t,originalSize:a.fontSize}}static#f(t,e,a,i,r){const s=0===a?"normal":1===a?"italic":"oblique",n=0===i?"normal":1===i?"bold":String(i),o=String(t),l=o.includes(".")?o.replace(".","-"):`${o}-0`,c=String(r);return`density-${l}-${e}-style-${s}-weight-${n}-size-${c.includes(".")?c.replace(".","-"):`${c}-0`}`}static registerMetrics(t,e,a,i,r,s){BitmapText.#c();const n=BitmapText.#f(t,e,a,i,r);FontLoaderBase.registerMetrics(n,s,BitmapText)}static registerAtlas(t,e,a,i,r,s){BitmapText.#c();const n=BitmapText.#f(t,e,a,i,r);FontLoaderBase.registerAtlas(n,s)}static measureText(t,e,a){if(a||(a=new TextProperties),0===t.length)return{metrics:{width:0,actualBoundingBoxLeft:0,actualBoundingBoxRight:0,actualBoundingBoxAscent:0,actualBoundingBoxDescent:0,fontBoundingBoxAscent:0,fontBoundingBoxDescent:0},status:SUCCESS_STATUS};let i=FontMetricsStore.getFontMetrics(e);if(!i&&BitmapText.#d(e.fontSize)){const t=BitmapText.#h(e),a=FontMetricsStore.getFontMetrics(t);if(!a)return{metrics:null,status:createErrorStatus(StatusCode.NO_METRICS,{requiresMinSize:!0,requestedSize:e.fontSize,minSize:BitmapText.MIN_RENDERABLE_SIZE})};i=BitmapText.#g(a,e.fontSize)}else if(!i)return{metrics:null,status:createErrorStatus(StatusCode.NO_METRICS)};const r=new FontProperties(e.pixelDensity,BitmapText.INVARIANT_FONT_FAMILY,"normal","normal",e.fontSize);let s=FontMetricsStore.getFontMetrics(r);if(!s&&BitmapText.#d(e.fontSize)){const t=BitmapText.#h(r),a=FontMetricsStore.getFontMetrics(t);a&&(s=BitmapText.#g(a,e.fontSize))}const n=null!==s,o=new Set;for(const e of t)" "!==e&&((n&&BitmapText.#r(e)?s:i).hasGlyph(e)||o.add(e));if(o.size>0)return{metrics:null,status:createErrorStatus(StatusCode.PARTIAL_METRICS,{missingChars:o})};const l=[...t];let c=0;const d=n&&BitmapText.#r(l[0]);let h=d?s:i,g=d?r:e,u=h.getCharacterMetrics(l[0]);const f=u.actualBoundingBoxLeft;let p,m=0,x=0,A=0;for(let t=0;t<l.length;t++){const o=l[t],d=l[t+1],f=n&&BitmapText.#r(o);f&&g!==r?(h=s,g=r):f||g===e||(h=i,g=e),u=h.getCharacterMetrics(o),m=Math.max(m,u.actualBoundingBoxAscent),x=Math.min(x,u.actualBoundingBoxDescent),A=this.calculateAdvancement_CssPx(h,g,o,d,a,u),c+=A}return p=c-A,p+=u.actualBoundingBoxRight,{metrics:{width:c,actualBoundingBoxLeft:f,actualBoundingBoxRight:p,actualBoundingBoxAscent:m,actualBoundingBoxDescent:x,fontBoundingBoxAscent:u.fontBoundingBoxAscent,fontBoundingBoxDescent:u.fontBoundingBoxDescent},status:SUCCESS_STATUS}}static drawTextFromAtlas(t,e,a,i,r,s=null){s=s||new TextProperties,BitmapText.#n||(BitmapText.#n=BitmapText.getCanvasFactory()(),BitmapText.#o=BitmapText.#n.getContext("2d"));let n=FontMetricsStore.getFontMetrics(r),o=!1;if(BitmapText.#d(r.fontSize)){const t=BitmapText.#h(r),e=FontMetricsStore.getFontMetrics(t);if(!e)return{rendered:!1,status:createErrorStatus(StatusCode.NO_METRICS,{requiresMinSize:!0,requestedSize:r.fontSize,minSize:BitmapText.MIN_RENDERABLE_SIZE})};n=BitmapText.#g(e,r.fontSize),o=!0}else if(!n)return{rendered:!1,status:createErrorStatus(StatusCode.NO_METRICS)};const l=new FontProperties(r.pixelDensity,BitmapText.INVARIANT_FONT_FAMILY,"normal","normal",r.fontSize);let c=FontMetricsStore.getFontMetrics(l);if(!c&&BitmapText.#d(r.fontSize)){const t=BitmapText.#h(l),e=FontMetricsStore.getFontMetrics(t);e&&(c=BitmapText.#g(e,r.fontSize))}const d=null!==c,h=new Set;for(const t of e)" "!==t&&((d&&BitmapText.#r(t)?c:n).hasGlyph(t)||h.add(t));if(h.size>0)return{rendered:!1,status:createErrorStatus(StatusCode.PARTIAL_METRICS,{missingChars:h})};let g=o?null:AtlasDataStore.getAtlasData(r);const u=!o&&BitmapText.#p(g),f=c?AtlasDataStore.getAtlasData(l):null,p=!!c&&BitmapText.#p(f);let m=r,x=n,A=g,B=u;const T=new Set;let S=!1;t.save(),t.setTransform(1,0,0,1,0,0);const F=[...e],I=s.textColor,y=F.find((t=>n.hasGlyph(t)))||F[0],M=n.getCharacterMetrics(y),C=M?BitmapText.#m(s.textBaseline,M):0;let b=0;if("left"!==s.textAlign){const t=BitmapText.measureText(e,r,s);0===t.status.code&&t.metrics?b=BitmapText.#x(s.textAlign,t.metrics.width):console.warn(`BitmapText: Failed to measure text for alignment '${s.textAlign}', defaulting to left alignment`)}const w={x:(a+b)*r.pixelDensity,y:(i+C)*r.pixelDensity};if(I!==BitmapText.#a&&u){const a=BitmapText.#A(t,e,F,w,g,n,r,s);a.missingAtlasChars.forEach((t=>T.add(t))),S=S||a.placeholdersUsed}else for(let e=0;e<F.length;e++){const a=F[e],i=F[e+1],o=d&&BitmapText.#r(a);o&&m!==l?(m=l,x=c,A=f,B=p):o||m===r||(m=r,x=n,A=g,B=u)," "!==a&&(B&&A.hasPositioning(a)||(T.add(a),S=!0)),BitmapText.#B(t,a,w,A,x,I),w.x+=BitmapText.#T(x,m,a,i,s)}let _;if(u){if(!(T.size>0))return t.restore(),{rendered:!0,status:SUCCESS_STATUS};_=StatusCode.PARTIAL_ATLAS}else _=StatusCode.NO_ATLAS;return t.restore(),{rendered:!0,status:createErrorStatus(_,{missingAtlasChars:T.size>0?T:void 0,placeholdersUsed:S})}}static calculateAdvancement_CssPx(t,e,a,i,r,s=null){r||(r=new TextProperties),s||(s=t.getCharacterMetrics(a));let n=0;if(" "===a){const e=t.getSpaceAdvancementOverride();n+=null!==e?e:s.width}else n+=s.width;let o=BitmapText.#S(t,a,i,r);return n-=e.fontSize*o/BitmapText.KERNING_UNIT_DIVISOR,t.isInterpolatedMetrics?n:Math.round(n)}static#S(t,e,a,i){return i||(i=new TextProperties),i.isKerningEnabled&&a?t.getKerningAdjustment(e,a):0}static#m(t,e){const a=e.fontBoundingBoxAscent,i=e.fontBoundingBoxDescent,r=e.hangingBaseline,s=e.ideographicBaseline;switch(t){case"top":return a+i;case"hanging":return r+i;case"middle":return(a+i)/2;case"alphabetic":return i;case"ideographic":return i+s;case"bottom":return 0;default:return console.warn(`BitmapText: Unknown textBaseline '${t}', defaulting to 'bottom'. Valid values: top, hanging, middle, alphabetic, ideographic, bottom`),0}}static#x(t,e){switch(t){case"left":return 0;case"center":return-e/2;case"right":return-e;default:return console.warn(`BitmapText: Unknown textAlign '${t}', defaulting to 'left'. Valid values: left, center, right`),0}}static#A(t,e,a,i,r,s,n,o){const l=new Set;let c=!1;const d=BitmapText.measureText(e,n,o);if(0!==d.status.code||!d.metrics)return console.warn("BitmapText: Batch rendering failed (cannot measure text), falling back to per-character rendering"),{missingAtlasChars:l,placeholdersUsed:c};const h=d.metrics,g=new FontProperties(n.pixelDensity,BitmapText.INVARIANT_FONT_FAMILY,"normal","normal",n.fontSize),u=FontMetricsStore.getFontMetrics(g),f=u?AtlasDataStore.getAtlasData(g):null,p=null!==u;let m=n,x=s,A=r;const B=h.actualBoundingBoxLeft+h.actualBoundingBoxRight,T=Math.ceil(B*n.pixelDensity),S=Math.round(h.fontBoundingBoxAscent+h.fontBoundingBoxDescent)*n.pixelDensity,F=Math.round(h.actualBoundingBoxLeft*n.pixelDensity),I=S-n.pixelDensity;if(T<=0||S<=0||T>32e3||S>32e3)return console.warn(`BitmapText: Invalid scratch canvas dimensions (${T}x${S}), falling back`),{missingAtlasChars:l,placeholdersUsed:c};BitmapText.#n.width=T,BitmapText.#n.height=S,BitmapText.#o.clearRect(0,0,T,S);const y={x:F,y:I};for(let t=0;t<a.length;t++){const e=a[t],i=a[t+1],d=p&&BitmapText.#r(e);if(d&&m!==g?(m=g,x=u,A=f):d||m===n||(m=n,x=s,A=r)," "===e||A.hasPositioning(e)){if(" "!==e&&A.hasPositioning(e)){const t=A.atlasPositioning.getPositioning(e),a=A.atlasImage.image,{xInAtlas:i,yInAtlas:r,tightWidth:s,tightHeight:n,dx:o,dy:l}=t;BitmapText.#o.drawImage(a,i,r,s,n,Math.round(y.x+o),Math.round(y.y+l),s,n)}y.x+=BitmapText.#T(x,m,e,i,o)}else l.add(e),c=!0,y.x+=BitmapText.#T(x,m,e,i,o)}return BitmapText.#o.globalCompositeOperation="source-in",BitmapText.#o.fillStyle=o.textColor,BitmapText.#o.fillRect(0,0,T,S),BitmapText.#o.globalCompositeOperation="source-over",t.drawImage(BitmapText.#n,0,0,T,S,Math.round(i.x)-F,Math.round(i.y)-I,T,S),{missingAtlasChars:l,placeholdersUsed:c}}static#B(t,e,a,i,r,s){if(!BitmapText.#p(i)){const i=r.getCharacterMetrics(e);return void(i&&BitmapText.#F(t,e,a,i,s))}if(s===BitmapText.#a)return void BitmapText.#I(t,e,a,i,r);if(!i.hasPositioning(e))return;const n=i.atlasPositioning.getPositioning(e),o=i.atlasImage.image,l=BitmapText.#y(o,n,s);BitmapText.#M(t,l,a,n)}static#y(t,e,a){const{xInAtlas:i,yInAtlas:r,tightWidth:s,tightHeight:n}=e;return BitmapText.#n.width=s,BitmapText.#n.height=n,BitmapText.#o.clearRect(0,0,s,n),BitmapText.#o.globalCompositeOperation="source-over",BitmapText.#o.drawImage(t,i,r,s,n,0,0,s,n),BitmapText.#o.globalCompositeOperation="source-in",BitmapText.#o.fillStyle=a,BitmapText.#o.fillRect(0,0,s,n),BitmapText.#n}static#M(t,e,a,i){const{tightWidth:r,tightHeight:s,dx:n,dy:o}=i;t.drawImage(e,0,0,r,s,Math.round(a.x+n),Math.round(a.y+o),r,s)}static#I(t,e,a,i,r){if(!i.hasPositioning(e))return;const s=i.atlasPositioning.getPositioning(e),n=i.atlasImage.image,{xInAtlas:o,yInAtlas:l,tightWidth:c,tightHeight:d,dx:h,dy:g}=s;t.drawImage(n,o,l,c,d,Math.round(a.x+h),Math.round(a.y+g),c,d)}static#F(t,e,a,i,r){if(" "===e)return;if(void 0===i.actualBoundingBoxLeft||void 0===i.actualBoundingBoxRight||void 0===i.actualBoundingBoxAscent||void 0===i.actualBoundingBoxDescent)return void console.warn(`Missing bounding box metrics for character '${e}'`);const s=i.pixelDensity||1,n=Math.round(i.actualBoundingBoxLeft+i.actualBoundingBoxRight)*s,o=Math.round(i.actualBoundingBoxAscent+i.actualBoundingBoxDescent)*s,l=a.x-Math.round(i.actualBoundingBoxLeft)*s,c=a.y-i.fontBoundingBoxDescent*s-i.actualBoundingBoxAscent*s,d=r||"black";t.fillStyle=d,t.fillRect(Math.round(l),Math.round(c),Math.round(n),Math.round(o))}static#T(t,e,a,i,r){return this.calculateAdvancement_CssPx(t,e,a,i,r)*e.pixelDensity}static#p(t){return t instanceof AtlasData&&t.isValid()}static async loadFont(t,e={}){BitmapText.#c();const a=BitmapText.#u(t);return BitmapText.#l.loadFont(a.idString,e,BitmapText)}static async loadFonts(t,e={}){BitmapText.#c();const a=t.map((t=>BitmapText.#u(t).idString));return BitmapText.#l.loadFonts(a,e,BitmapText)}static async loadMetrics(t,e={}){BitmapText.#c();const a=t.map((t=>BitmapText.#u(t).idString));return BitmapText.#l.loadMetrics(a,e,BitmapText)}static async loadAtlases(t,e={}){BitmapText.#c();const a=t.map((t=>BitmapText.#u(t).idString));return BitmapText.#l.loadAtlases(a,e,BitmapText)}static setAtlasData(t,e){AtlasDataStore.setAtlasData(t,e)}static getAtlasData(t){return AtlasDataStore.getAtlasData(t)}static deleteAtlas(t){return AtlasDataStore.deleteAtlas(t)}static setFontMetrics(t,e){FontMetricsStore.setFontMetrics(t,e)}static getFontMetrics(t){return FontMetricsStore.getFontMetrics(t)}static unloadFont(t){const e=FontProperties.fromIDString(t);FontMetricsStore.deleteFontMetrics(e),AtlasDataStore.deleteAtlas(e)}static unloadFonts(t){t.forEach((t=>this.unloadFont(t)))}static unloadMetrics(t){const e=FontProperties.fromIDString(t);FontMetricsStore.deleteFontMetrics(e),AtlasDataStore.deleteAtlas(e)}static unloadAtlas(t){const e=FontProperties.fromIDString(t);AtlasDataStore.deleteAtlas(e)}static unloadAllFonts(){FontMetricsStore.clear(),AtlasDataStore.clear()}static unloadAllAtlases(){AtlasDataStore.clear()}static hasFont(t){return this.hasMetrics(t)&&this.hasAtlas(t)}static hasMetrics(t){const e=BitmapText.#u(t,!0),a=FontProperties.fromIDString(e.idString);return FontMetricsStore.hasFontMetrics(a)}static hasAtlas(t){const e=FontProperties.fromIDString(t);if(BitmapText.#d(e.fontSize))return!1;const a=AtlasDataStore.getAtlasData(e);return a&&BitmapText.#p(a)}static getLoadedFonts(){const t=[];for(const e of FontMetricsStore.getAvailableFonts()){const a=FontProperties.fromKey(e),i=AtlasDataStore.getAtlasData(a);i&&BitmapText.#p(i)&&t.push(a.idString)}return t}static getLoadedMetrics(){const t=[];for(const e of FontMetricsStore.getAvailableFonts()){const a=FontProperties.fromKey(e);t.push(a.idString)}return t}static getLoadedAtlases(){const t=[];for(const e of AtlasDataStore.getAvailableFonts()){const a=FontProperties.fromKey(e),i=AtlasDataStore.getAtlasData(a);BitmapText.#p(i)&&t.push(a.idString)}return t}static __resetForTesting(){FontMetricsStore.clear(),AtlasDataStore.clear(),FontLoaderBase._loadingPromises&&FontLoaderBase._loadingPromises.clear(),FontLoaderBase._tempAtlasPackages&&(FontLoaderBase._tempAtlasPackages={}),FontLoaderBase._pendingAtlases&&FontLoaderBase._pendingAtlases.clear(),FontLoaderBase.setFontDirectory&&FontLoaderBase.setFontDirectory(null),BitmapText.#n=null,BitmapText.#o=null,BitmapText.#s=null,BitmapText.#l=null}static#i(){const t=[];for(let e=32;e<=126;e++)t.push(String.fromCharCode(e));const e=[8364,8230,8240,8249,381,8217,8226,8212,8482,353,8250,339,382,376];for(const a of e)t.push(String.fromCharCode(a));for(let e=161;e<=255;e++)173!==e&&t.push(String.fromCharCode(e));return t.push("‚ñà"),t.sort().join("")}}BitmapText.r=BitmapText.registerMetrics,BitmapText.a=BitmapText.registerAtlas;class MetricsExpander{constructor(){throw new Error("MetricsExpander cannot be instantiated - use static methods")}static#C(t){let e;if("undefined"!=typeof Buffer)e=Buffer.from(t,"base64");else{const a=atob(t);e=new Uint8Array(a.length);for(let t=0;t<a.length;t++)e[t]=a.charCodeAt(t)}return Array.from(e)}static#b(t){const e=this.#C(t),a=[];let i=0;for(;i<e.length;){let t,r=0,s=0;do{t=e[i++],r|=(127&t)<<s,s+=7}while(128&t);const n=1&r?-(r+1)/2:r/2;a.push(n)}return a}static#w(t){const e=this.#b(t),a=[e[0]];for(let t=1;t<e.length;t++)a.push(a[t-1]+e[t]);return a}static expand(t,e=BitmapText.CHARACTER_SET){if(void 0===FontMetrics)throw new Error("FontMetrics class not found. Please ensure FontMetrics.js is loaded before MetricsExpander.js");if(!Array.isArray(t)||8!==t.length)throw new Error(`Invalid format - expected 8-element array (Tier 6c), got ${"object"==typeof t?"array":typeof t} with ${t?.length||0} elements.\nPlease regenerate font assets with the current version.`);let a,[i,r,s,n,o,l,c,d]=t;if("object"!=typeof n||Array.isArray(n)||null===n){if(i=this.#_(i),"string"==typeof n)n=this.#w(n),n=this.#_(n);else{if(!Array.isArray(n))throw new Error("Invalid value lookup format - expected array or string");n=this.#_(n)}s=this.#D(s),o=this.#b(o),l=this.#C(l),o=this.#E(o),a={kerningTable:this.#v(r,i,e),characterMetrics:this.#P(l,s,n,o,d,e),spaceAdvancementOverrideForSmallSizesInPx:c}}else console.debug("üîç MetricsExpander: Detected uncompressed custom character set font"),a={kerningTable:r,characterMetrics:n,spaceAdvancementOverrideForSmallSizesInPx:c};const h=Object.keys(a.characterMetrics)[0],g=a.characterMetrics[h]?.pixelDensity;return console.debug(`üîç MetricsExpander: Restored pixelDensity=${g} for ${Object.keys(a.characterMetrics).length} characters`),new FontMetrics(a)}static#v(t,e,a){const i=this.#L(t,a),r={};for(const[t,e]of Object.entries(i))r[t]=this.#R(e,a);const s={};for(const[t,a]of Object.entries(r)){s[t]={};for(const[i,r]of Object.entries(a))s[t][i]=e[r]}return s}static#L(t,e){const a={};for(const[i,r]of Object.entries(t)){if(i.includes("-")&&i.length>=3){const t=i.indexOf("-"),s=i.substring(0,t),n=i.substring(t+1);if(1===s.length&&1===n.length){const t=e.indexOf(s),i=e.indexOf(n);if(-1!==t&&-1!==i&&t<=i){for(let s=t;s<=i;s++)a[e[s]]=r;continue}}}a[i]=r}return a}static#R(t,e){const a={};for(const[i,r]of Object.entries(t)){const t=this.#O(i,e);for(const e of t)a[e]=r}return a}static#O(t,e){const a=[];let i=0;for("-"===t[0]&&(a.push("-"),i=1);i<t.length;){const r=t[i];if(i+2<t.length&&"-"===t[i+1]){const s=r,n=t[i+2],o=e.indexOf(s),l=e.indexOf(n);if(-1!==o&&-1!==l&&o<l){for(let t=o;t<=l;t++)a.push(e[t]);i+=3}else a.push(r),i++}else a.push(r),i++}return a}static#P(t,e,a,i,r,s){const n={};return(Array.isArray(s)?s:Array.from(s)).forEach(((s,o)=>{const l=t[o],c=i[l];let d;if(2===c.length){if(void 0===r)throw new Error(`2-element tuplet found but no common left index provided.\nCharacter "${s}" at index ${o}: [${c.join(",")}]\nThis indicates a corrupted Tier 6b font file. Please regenerate font assets.`);d=[c[0],r,c[0],c[1],r]}else if(3===c.length)d=[c[0],c[1],c[0],c[2],c[1]];else if(4===c.length)d=[c[0],c[1],c[0],c[2],c[3]];else{if(5!==c.length)throw new Error(`Invalid glyph tuplet length for character "${s}" at index ${o}.\nExpected 2, 3, 4, or 5 elements, got ${c.length}: [${c.join(",")}]\nThis indicates a corrupted font file. Please regenerate font assets.`);d=c}const h=a[d[0]],g=a[d[1]],u=a[d[2]],f=a[d[3]],p=a[d[4]];n[s]={width:h,actualBoundingBoxLeft:g,actualBoundingBoxRight:u,actualBoundingBoxAscent:f,actualBoundingBoxDescent:p,fontBoundingBoxAscent:e.fba,fontBoundingBoxDescent:e.fbd,emHeightAscent:e.fba,emHeightDescent:e.fbd,hangingBaseline:e.hb,alphabeticBaseline:e.ab,ideographicBaseline:e.ib,pixelDensity:e.pd}})),n}static#_(t){return t.map((t=>t/1e4))}static#D(t){if(!Array.isArray(t)||6!==t.length)throw new Error(`Invalid baseline array - expected 6 elements, got ${t?.length}.\nThis indicates a corrupted font file. Please regenerate font assets.`);return{fba:t[0],fbd:t[1],hb:t[2],ab:t[3],ib:t[4],pd:t[5]}}static#E(t){const e=[];let a=[];for(let i=0;i<t.length;i++){const r=t[i];if(r<0){if(a.push(-r-1),a.length<2||a.length>5)throw new Error(`Invalid tuplet length ${a.length} at position ${i}.\nExpected 2, 3, 4, or 5. This indicates a corrupted font file.\nPlease regenerate font assets.`);e.push(a),a=[]}else a.push(r-1)}if(a.length>0)throw new Error(`Incomplete tuplet at end of data.\nFound ${a.length} elements without negative delimiter.\nThis indicates a corrupted font file. Please regenerate font assets.`);return e}}class AtlasPositioning{constructor(t,e={}){if(!t||"object"!=typeof t)throw new Error("AtlasPositioning constructor requires data object");this._tightWidth=t.tightWidth||{},this._tightHeight=t.tightHeight||{},this._dx=t.dx||{},this._dy=t.dy||{},this._xInAtlas=t.xInAtlas||{},this._yInAtlas=t.yInAtlas||{},e.mutable||(Object.freeze(this._tightWidth),Object.freeze(this._tightHeight),Object.freeze(this._dx),Object.freeze(this._dy),Object.freeze(this._xInAtlas),Object.freeze(this._yInAtlas),Object.freeze(this))}getPositioning(t){return{xInAtlas:this._xInAtlas[t],yInAtlas:this._yInAtlas[t],tightWidth:this._tightWidth[t],tightHeight:this._tightHeight[t],dx:this._dx[t],dy:this._dy[t]}}hasPositioning(t){return void 0!==this._xInAtlas[t]&&void 0!==this._yInAtlas[t]&&void 0!==this._tightWidth[t]&&void 0!==this._tightHeight[t]}hasAtlasPosition(t){return void 0!==this._xInAtlas[t]&&void 0!==this._yInAtlas[t]}getAvailableCharacters(){return Object.keys(this._xInAtlas)}getTightWidth(t){return this._tightWidth[t]}getTightHeight(t){return this._tightHeight[t]}getXInAtlas(t){return this._xInAtlas[t]}getYInAtlas(t){return this._yInAtlas[t]}getDx(t){return this._dx[t]}getDy(t){return this._dy[t]}}class AtlasImage{constructor(t,e={}){if(!t)throw new Error("AtlasImage constructor requires image (Canvas or Image element)");if("object"!=typeof t||void 0===t.width&&void 0===t.naturalWidth)throw new Error("AtlasImage constructor requires Canvas or Image element with width property");this.image=t,e.mutable||Object.freeze(this)}get width(){return this.image.naturalWidth||this.image.width||0}get height(){return this.image.naturalHeight||this.image.height||0}isValid(){return this.image&&"object"==typeof this.image&&this.width>0&&this.height>0}canRender(){return!!this.isValid()&&(!(this.image instanceof Image)||this.image.complete&&this.image.naturalWidth>0)}getImageType(){return this.image instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&this.image instanceof OffscreenCanvas?"canvas":this.image instanceof Image||this.image instanceof HTMLImageElement?"image":"unknown"}getContext(t="2d"){return"canvas"===this.getImageType()?this.image.getContext(t):null}equals(t){return t instanceof AtlasImage&&this.image===t.image}getDebugInfo(){return{type:this.getImageType(),width:this.width,height:this.height,isValid:this.isValid(),canRender:this.canRender()}}}class AtlasData{constructor(t,e){if(!(t instanceof AtlasImage))throw new Error("AtlasData constructor requires AtlasImage instance (not raw Canvas/Image)");if(e&&!(e instanceof AtlasPositioning))throw new Error("AtlasData constructor requires AtlasPositioning instance (not raw positioning object)");this.atlasImage=t,this.atlasPositioning=e,Object.freeze(this)}hasPositioning(t){return!!this.atlasPositioning&&this.atlasPositioning.hasPositioning(t)}isValid(){return this.atlasImage?.isValid()}getAvailableCharacters(){return this.atlasPositioning?this.atlasPositioning.getAvailableCharacters():[]}get width(){return this.atlasImage.width}get height(){return this.atlasImage.height}canRender(){return this.atlasImage?.canRender()}equals(t){return t instanceof AtlasData&&this.atlasImage.equals(t.atlasImage)&&this.atlasPositioning===t.atlasPositioning}getDebugInfo(){return{atlasImage:this.atlasImage?this.atlasImage.getDebugInfo():null,atlasPositioning:this.atlasPositioning?{availableCharacters:this.atlasPositioning.getAvailableCharacters().length,characters:this.atlasPositioning.getAvailableCharacters().slice(0,10)}:null,isValid:this.isValid(),canRender:this.canRender()}}}class AtlasReconstructionUtils{constructor(){throw new Error("AtlasReconstructionUtils cannot be instantiated - use static methods")}static getImageData(t){const e=t?.image?t.image:t;if(!e)throw new Error("getImageData: Invalid image source (null or undefined)");if(e.getContext)return e.getContext("2d").getImageData(0,0,e.width,e.height);if(void 0!==e.naturalWidth||void 0!==e.width){const t=BitmapText.getCanvasFactory()();t.width=e.naturalWidth||e.width,t.height=e.naturalHeight||e.height;const a=t.getContext("2d");return a.drawImage(e,0,0),a.getImageData(0,0,t.width,t.height)}throw new Error("getImageData: Image source is not a Canvas or Image element")}}class AtlasCellDimensions{constructor(){throw new Error("AtlasCellDimensions cannot be instantiated - use static methods")}static getWidth(t){return Math.round(t.actualBoundingBoxLeft+t.actualBoundingBoxRight)}static getHeight(t){return Math.round(t.fontBoundingBoxAscent+t.fontBoundingBoxDescent)}static getDimensions(t){return{width:this.getWidth(t),height:this.getHeight(t)}}}class TightAtlasReconstructor{constructor(){throw new Error("TightAtlasReconstructor cannot be instantiated - use static methods")}static reconstructFromAtlas(t,e){const a=AtlasReconstructionUtils.getImageData(e),i=t.getAvailableCharacters().sort();if(0===i.length)throw new Error("TightAtlasReconstructor: No characters found in FontMetrics");console.debug(`TightAtlasReconstructor: Processing ${i.length} characters`);const r=i[0],s=t.getCharacterMetrics(r),n=AtlasCellDimensions.getHeight(s),o=s.pixelDensity||1,l=Math.round(n*o);console.debug(`üîç TightAtlasReconstructor: pixelDensity=${o}, height_CssPx=${n}, cellHeight_PhysPx=${l}`);const c=BitmapText.calculateOptimalGridDimensions(i.length),d=c.columns,h=c.rows,g=[],u=new Array(d).fill(0);for(let e=0;e<i.length;e++){const a=i[e],r=t.getCharacterMetrics(a),s=AtlasCellDimensions.getWidth(r),n=Math.round(s*o);g[e]=n;const l=e%d;u[l]=Math.max(u[l],n)}const f=[0];for(let t=0;t<d-1;t++)f.push(f[t]+u[t]);const p={},m=[];for(let t=0;t<i.length;t++){const e=i[t],r=g[t],s=t%d,n=Math.floor(t/d),o=f[s],c=n*l;m.length<5&&m.push(`${e}:w=${r},r=${n},c=${s},x=${o},y=${c}`);const h=this.findTightBounds(a,o,c,r,l);h&&(p[e]=h)}return console.debug(`üîç Cell dimensions (first 5): ${m.join(", ")} [Grid: ${d}√ó${h}]`),this.packTightAtlas(t,p,i,e,o,l,g,f,d)}static findTightBounds(t,e,a,i,r){const s=t.data,n=4*t.width,o=(t,e)=>s[e*n+(t<<2)+3];let l=-1;for(let t=a+r-1;t>=a&&-1===l;t--)for(let a=e;a<e+i&&-1===l;a++)o(a,t)>0&&(l=t);if(-1===l)return null;let c=a;for(let t=a;t<=l;t++){let a=!1;for(let r=e;r<e+i;r++)if(o(r,t)>0){c=t,a=!0;break}if(a)break}let d=e;for(let t=e;t<e+i;t++){let e=!1;for(let a=c;a<=l;a++)if(o(t,a)>0){d=t,e=!0;break}if(e)break}let h=e+i-1;for(let t=e+i-1;t>=e;t--){let e=!1;for(let a=c;a<=l;a++)if(o(t,a)>0){h=t,e=!0;break}if(e)break}return{left:d-e,top:c-a,width:h-d+1,height:l-c+1}}static packTightAtlas(t,e,a,i,r,s,n,o,l){let c=0,d=0;for(const t of a)e[t]&&(c+=e[t].width,d=Math.max(d,e[t].height));const h=BitmapText.getCanvasFactory()();h.width=c,h.height=d;const g=h.getContext("2d");let u=0;const f={tightWidth:{},tightHeight:{},dx:{},dy:{},xInAtlas:{},yInAtlas:{}};for(let c=0;c<a.length;c++){const d=a[c],h=t.getCharacterMetrics(d),p=c%l,m=Math.floor(c/l),x=o[p],A=m*s,B=(n[c],e[d]);if(!B)continue;const T=BitmapText.getCanvasFactory()();T.width=B.width,T.height=B.height;const S=T.getContext("2d"),F=Math.floor(x+B.left),I=Math.floor(A+B.top),y=Math.floor(B.width),M=Math.floor(B.height);S.drawImage(i,F,I,y,M,0,0,y,M),g.drawImage(T,u,0);const C=s-(B.top+B.height-1)-1;f.tightWidth[d]=B.width,f.tightHeight[d]=B.height,f.xInAtlas[d]=u,f.yInAtlas[d]=0,f.dx[d]=-Math.round(h.actualBoundingBoxLeft)*r+B.left,f.dy[d]=-B.height-C+1*r,u+=B.width}const p=new AtlasImage(h),m=new AtlasPositioning(f);return console.debug(`TightAtlasReconstructor: Packed ${Object.keys(f.xInAtlas).length} glyphs into ${c}√ó${d} atlas`),{atlasImage:p,atlasPositioning:m}}}class AtlasDataStore{static#N=new Map;static getAtlasData(t){return AtlasDataStore.#N.get(t.key)}static setAtlasData(t,e){if(!(e instanceof AtlasData))throw new Error("AtlasDataStore.setAtlasData requires AtlasData instance (not raw images)");AtlasDataStore.#N.set(t.key,e)}static isValidAtlas(t){return t instanceof AtlasData&&t.isValid()}static getAvailableFonts(){return Array.from(AtlasDataStore.#N.keys())}static hasAtlas(t){return AtlasDataStore.#N.has(t.key)}static deleteAtlas(t){return AtlasDataStore.#N.delete(t.key)}static clear(){AtlasDataStore.#N.clear()}static size(){return AtlasDataStore.#N.size}}class FontMetricsStore{static#z=new Map;static getFontMetrics(t){return FontMetricsStore.#z.get(t.key)}static setFontMetrics(t,e){FontMetricsStore.#z.set(t.key,e)}static hasFontMetrics(t){return FontMetricsStore.#z.has(t.key)}static deleteFontMetrics(t){return FontMetricsStore.#z.delete(t.key)}static getAvailableFonts(){return Array.from(FontMetricsStore.#z.keys())}static clear(){FontMetricsStore.#z.clear()}static size(){return FontMetricsStore.#z.size}}class FontManifest{static#$=[];static addFontIDs(t){const e=Array.isArray(t)?t:[t];for(const t of e)"string"!=typeof t||this.#$.includes(t)||this.#$.push(t)}static allFontIDs(){return[...this.#$]}static hasFontID(t){return this.#$.includes(t)}static count(){return this.#$.length}static clear(){this.#$.length=0}static allFontIDsSorted(){return[...this.#$].sort()}}class FontLoaderBase{static _tempAtlasPackages={};static _pendingAtlases=new Map;static _loadingPromises=new Map;static DEFAULT_FONT_DIRECTORY="./font-assets/";static#k=null;static setFontDirectory(t){FontLoaderBase.#k=t}static getFontDirectory(){return FontLoaderBase.#k??FontLoaderBase.DEFAULT_FONT_DIRECTORY}static getDefaultFontDirectory(){return FontLoaderBase.DEFAULT_FONT_DIRECTORY}static registerMetrics(t,e,a){if("string"!=typeof t)return void console.warn("FontLoader.registerMetrics: Invalid idString - must be string");if(void 0===MetricsExpander)return void console.warn("FontLoader.registerMetrics: MetricsExpander not available");if(void 0===FontProperties)return void console.warn("FontLoader.registerMetrics: FontProperties not available");const i=FontProperties.fromIDString(t);let r;a&&i.fontFamily===a.INVARIANT_FONT_FAMILY&&(r=a.FONT_INVARIANT_CHAR_SET);const s=MetricsExpander.expand(e,r);FontMetricsStore.setFontMetrics(i,s),FontLoaderBase._processPendingAtlas(t)}static registerAtlas(t,e){"string"==typeof t&&"string"==typeof e?FontLoaderBase._tempAtlasPackages[t]={base64Data:e}:console.warn("FontLoader.registerAtlas: Invalid arguments - idString and base64Data must be strings")}static async loadFont(t,e,a){return this.loadFonts([t],e,a)}static async loadFonts(t,e={},a){const{onProgress:i=null,isFileProtocol:r=!1,loadMetrics:s=!0,loadAtlases:n=!0}=e,o=(s?1:0)+(n?1:0),l=t.length*o;let c=0;const d=()=>{i&&i(c,l)};for(const e of t){if(FontLoaderBase._loadingPromises.has(e)){await FontLoaderBase._loadingPromises.get(e);continue}const t=(async()=>{try{s&&(await this.loadMetricsFile(e,a),c++,d()),n&&(await this.loadAtlasFile(e,r,a),c++,d())}finally{FontLoaderBase._loadingPromises.delete(e)}})();FontLoaderBase._loadingPromises.set(e,t),await t}}static async loadMetrics(t,e,a){return this.loadFonts(t,{...e,loadAtlases:!1},a)}static async loadAtlases(t,e,a){return this.loadFonts(t,{...e,loadMetrics:!1},a)}static async loadMetricsFile(t,e){throw new Error("FontLoaderBase.loadMetricsFile() must be implemented by derived class")}static async loadAtlasFile(t,e,a){throw new Error("FontLoaderBase.loadAtlasFile() must be implemented by derived class")}static _loadAtlasFromPackage(t,e,a){const i=FontProperties.fromIDString(t);delete FontLoaderBase._tempAtlasPackages[t];const r=FontMetricsStore.getFontMetrics(i);if(!r)return FontLoaderBase._pendingAtlases.set(t,{atlasImage:e,bitmapTextClass:a}),!1;if(void 0===TightAtlasReconstructor)throw new Error(`FontLoader: TightAtlasReconstructor required for font loading - not available for ${t}`);const{atlasImage:s,atlasPositioning:n}=TightAtlasReconstructor.reconstructFromAtlas(r,e),o=new AtlasData(s,n);return AtlasDataStore.setAtlasData(i,o),!0}static _processPendingAtlas(t){if(!FontLoaderBase._pendingAtlases.has(t))return;const{atlasImage:e,bitmapTextClass:a}=FontLoaderBase._pendingAtlases.get(t);FontLoaderBase._pendingAtlases.delete(t),FontLoaderBase._loadAtlasFromPackage(t,e,a)}}function QOIDecode(t,e,a,i){null==e&&(e=0),null==a&&(a=t.byteLength-e);const r=new Uint8Array(t,e,a),s=r[0],n=r[1],o=r[2],l=r[3],c=(r[4]<<24|r[5]<<16|r[6]<<8|r[7])>>>0,d=(r[8]<<24|r[9]<<16|r[10]<<8|r[11])>>>0,h=r[12],g=r[13];if(null==i&&(i=h),113!==s||111!==n||105!==o||102!==l)throw new Error("QOI.decode: The signature of the QOI file is invalid");if(h<3||h>4)throw new Error("QOI.decode: The number of channels declared in the file is invalid");if(g>1)throw new Error("QOI.decode: The colorspace declared in the file is invalid");if(i<3||i>4)throw new Error("QOI.decode: The number of channels for the output is invalid");const u=c*d*i,f=new Uint8Array(u);let p=14;const m=new Uint8Array(256);let x=0,A=0,B=0,T=0,S=255;const F=a-8;let I=0,y=0;for(;y<u&&p<a-4;y+=i){if(I>0)I--;else if(p<F){const t=r[p++];if(254===t)A=r[p++],B=r[p++],T=r[p++];else if(255===t)A=r[p++],B=r[p++],T=r[p++],S=r[p++];else if(192&t)if(64==(192&t))A+=(t>>4&3)-2,B+=(t>>2&3)-2,T+=(3&t)-2,A=(A+256)%256,B=(B+256)%256,T=(T+256)%256;else if(128==(192&t)){const e=r[p++],a=(63&t)-32;A=(A+(a+(e>>4&15)-8)+256)%256,B=(B+a+256)%256,T=(T+(a+(15&e)-8)+256)%256}else 192&~t||(I=63&t);else A=m[4*t],B=m[4*t+1],T=m[4*t+2],S=m[4*t+3];x=(3*A+5*B+7*T+11*S)%64*4,m[x]=A,m[x+1]=B,m[x+2]=T,m[x+3]=S}4===i?(f[y]=A,f[y+1]=B,f[y+2]=T,f[y+3]=S):(f[y]=A,f[y+1]=B,f[y+2]=T)}if(y<u)throw new Error("QOI.decode: Incomplete image");return{width:c,height:d,colorspace:g,channels:i,data:f}}class FontLoader extends FontLoaderBase{static METRICS_PREFIX="metrics-";static ATLAS_PREFIX="atlas-";static JS_EXTENSION=".js";static async loadMetricsFile(idString,bitmapTextClass){if("undefined"==typeof require)throw new Error("FontLoader.loadMetricsFile requires Node.js environment");const fs=require("fs"),path=require("path"),fontDirectory=FontLoaderBase.getFontDirectory(),metricsPath=path.resolve(fontDirectory,`${FontLoader.METRICS_PREFIX}${idString}${FontLoader.JS_EXTENSION}`);try{const metricsCode=fs.readFileSync(metricsPath,"utf8");eval(metricsCode)}catch(t){throw console.warn(`Metrics file not found: ${metricsPath}`),t}}static async loadAtlasFile(idString,isFileProtocol,bitmapTextClass){if("undefined"==typeof require)throw new Error("FontLoader.loadAtlasFile requires Node.js environment");const fs=require("fs"),path=require("path"),fontDirectory=FontLoaderBase.getFontDirectory(),atlasPath=path.resolve(fontDirectory,`${FontLoader.ATLAS_PREFIX}${idString}-qoi${FontLoader.JS_EXTENSION}`);try{const atlasCode=fs.readFileSync(atlasPath,"utf8");eval(atlasCode);const pkg=FontLoaderBase._tempAtlasPackages[idString];if(pkg&&pkg.base64Data){if(void 0===QOIDecode)throw new Error("FontLoader: QOIDecode not available - required for atlas loading");const t=Uint8Array.from(atob(pkg.base64Data),(t=>t.charCodeAt(0))),e=QOIDecode(t.buffer),a=bitmapTextClass.getCanvasFactory()();a.width=e.width,a.height=e.height;const i=a.getContext("2d"),r=i.createImageData(e.width,e.height);r.data.set(e.data),i.putImageData(r,0,0),FontLoaderBase._loadAtlasFromPackage(idString,a,bitmapTextClass)}}catch(t){console.warn(`Atlas loading error for ${atlasPath}: ${t.message}`),console.warn("Will use placeholder rectangles")}}}"undefined"!=typeof global&&(global.StatusCode=StatusCode,global.SUCCESS_STATUS=SUCCESS_STATUS,global.createErrorStatus=createErrorStatus,global.getStatusDescription=getStatusDescription,global.FontProperties=FontProperties,global.TextProperties=TextProperties,global.FontMetrics=FontMetrics,global.BitmapText=BitmapText,global.AtlasDataStore=AtlasDataStore,global.FontMetricsStore=FontMetricsStore,global.FontManifest=FontManifest,global.QOIDecode=QOIDecode);
//# sourceMappingURL=bitmaptext-node.min.js.map