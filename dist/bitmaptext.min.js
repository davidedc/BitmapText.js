const StatusCode=Object.freeze({SUCCESS:0,NO_METRICS:1,PARTIAL_METRICS:2,NO_ATLAS:3,PARTIAL_ATLAS:4}),SUCCESS_STATUS=Object.freeze({code:StatusCode.SUCCESS});function createErrorStatus(t,e={}){return Object.freeze({code:t,...e})}function isSuccess(t){return t?.code===StatusCode.SUCCESS}function isCompleteFailure(t){return t&&(t.code===StatusCode.NO_METRICS||t.code===StatusCode.PARTIAL_METRICS)}function isPartialSuccess(t){return t&&(t.code===StatusCode.NO_ATLAS||t.code===StatusCode.PARTIAL_ATLAS)}function getStatusDescription(t){if(!t||"number"!=typeof t.code)return"Invalid status";switch(t.code){case StatusCode.SUCCESS:return"Success";case StatusCode.NO_METRICS:return"No font metrics available";case StatusCode.PARTIAL_METRICS:return`Missing metrics for characters: ${t.missingChars?[...t.missingChars].join(""):"unknown"}`;case StatusCode.NO_ATLAS:return"No atlas available (using placeholders)";case StatusCode.PARTIAL_ATLAS:return`Missing atlas data for characters: ${t.missingAtlasChars?[...t.missingAtlasChars].join(""):"unknown"} (using placeholders)`;default:return`Unknown status code: ${t.code}`}}class FontProperties{constructor(t,e,a,s,r){this.pixelDensity=t||1,this.fontFamily=e,this.fontStyle=a||"normal",this.fontWeight=s||"normal",this.fontSize=r,this._key=`${this.pixelDensity}:${this.fontFamily}:${this.fontStyle}:${this.fontWeight}:${this.fontSize}`,this._idString=`density-${this.#t(this.pixelDensity)}-${this.fontFamily}-style-${this.fontStyle}-weight-${this.fontWeight}-size-${this.#t(this.fontSize)}`,Object.freeze(this)}#t(t){const e=String(t);return e.includes(".")?e.replace(".","-"):`${e}-0`}get key(){return this._key}get idString(){return this._idString}static fromIDString(t){const e=t.split("-"),a=parseFloat(FontProperties.#e(e[1],e[2])),s=parseFloat(FontProperties.#e(e[9],e[10])),r=e[3],n=e[5],i=e[7];return new FontProperties(a,r,n,i,s)}static fromKey(t){const[e,a,s,r,n]=t.split(":");return new FontProperties(parseFloat(e),a,s,r,parseFloat(n))}static#e(t,e){return e&&"0"!==e?`${t}.${e}`:t}equals(t){return t instanceof FontProperties&&this._key===t._key}}class TextProperties{constructor(t={}){const{isKerningEnabled:e=!0,textBaseline:a="bottom",textAlign:s="left",textColor:r="#000000"}=t;this.isKerningEnabled=e,this.textBaseline=a,this.textAlign=s,this.textColor=r,this._key=`kerning:${this.isKerningEnabled}:baseline:${this.textBaseline}:align:${this.textAlign}:color:${this.textColor}`,Object.freeze(this)}get key(){return this._key}static withKerning(t,e={}){return new TextProperties({...e,isKerningEnabled:t})}static withColor(t,e={}){return new TextProperties({...e,textColor:t})}static forBitmapText(t={}){return new TextProperties({textBaseline:"bottom",...t})}withKerningEnabled(t){return new TextProperties({isKerningEnabled:t,textBaseline:this.textBaseline,textAlign:this.textAlign,textColor:this.textColor})}withTextColor(t){return new TextProperties({isKerningEnabled:this.isKerningEnabled,textBaseline:this.textBaseline,textAlign:this.textAlign,textColor:t})}equals(t){return t instanceof TextProperties&&this._key===t._key}toObject(){return{isKerningEnabled:this.isKerningEnabled,textBaseline:this.textBaseline,textAlign:this.textAlign,textColor:this.textColor}}}class FontMetrics{constructor(t,e={}){if(!t||"object"!=typeof t)throw new Error("FontMetrics constructor requires data object");this._kerningTable=t.kerningTable||{},this._characterMetrics=t.characterMetrics||{},this._spaceAdvancementOverride=t.spaceAdvancementOverrideForSmallSizesInPx||null,e.mutable||(Object.freeze(this._kerningTable),Object.freeze(this._characterMetrics),Object.freeze(this))}getCharacterMetrics(t){return this._characterMetrics[t]}getKerningAdjustment(t,e){return t&&e&&this._kerningTable[t]?.[e]||0}hasGlyph(t){return t in this._characterMetrics}getSpaceAdvancementOverride(){return this._spaceAdvancementOverride}getKerningTable(){return this._kerningTable}getAvailableCharacters(){return Object.keys(this._characterMetrics)}}if(void 0===StatusCode||void 0===SUCCESS_STATUS||void 0===createErrorStatus)throw new Error("StatusCode.js must be loaded before BitmapText.js");class BitmapText{static KERNING_UNIT_DIVISOR=1e3;static METRICS_PREFIX="metrics-";static ATLAS_PREFIX="atlas-";static WEBP_EXTENSION=".webp";static QOI_EXTENSION=".qoi";static JS_EXTENSION=".js";static#a="#000000";static CHARACTER_SET=BitmapText.#s();static#r="undefined"!=typeof document?()=>document.createElement("canvas"):null;static#n=null;static#i=null;static#o=null;static setFontDirectory(t){BitmapText.#c(),BitmapText.#o.setFontDirectory(t)}static getFontDirectory(){return BitmapText.#c(),BitmapText.#o.getFontDirectory()}static setCanvasFactory(t){BitmapText.#r=t,BitmapText.#n=null,BitmapText.#i=null}static getCanvasFactory(){return BitmapText.#r}static configure(t={}){void 0!==t.fontDirectory&&BitmapText.setFontDirectory(t.fontDirectory),void 0!==t.canvasFactory&&BitmapText.setCanvasFactory(t.canvasFactory)}static#c(){if(!BitmapText.#o){if(void 0===FontLoader)throw new Error('BitmapText: FontLoader not loaded.\nEnsure platform-specific FontLoader is included before BitmapText.js:\n  - Browser: <script src="src/platform/FontLoader-browser.js"><\/script>\n  - Node.js: Include src/platform/FontLoader-node.js in bundle');BitmapText.#o=FontLoader}}static#l(t,e,a,s,r){const n=0===a?"normal":1===a?"italic":"oblique",i=0===s?"normal":1===s?"bold":String(s),o=String(t),c=o.includes(".")?o.replace(".","-"):`${o}-0`,l=String(r);return`density-${c}-${e}-style-${n}-weight-${i}-size-${l.includes(".")?l.replace(".","-"):`${l}-0`}`}static registerMetrics(t,e,a,s,r,n){BitmapText.#c();const i=BitmapText.#l(t,e,a,s,r);FontLoaderBase.registerMetrics(i,n,BitmapText)}static registerAtlas(t,e,a,s,r,n){BitmapText.#c();const i=BitmapText.#l(t,e,a,s,r);FontLoaderBase.registerAtlas(i,n)}static measureText(t,e,a){if(a||(a=new TextProperties),0===t.length)return{metrics:{width:0,actualBoundingBoxLeft:0,actualBoundingBoxRight:0,actualBoundingBoxAscent:0,actualBoundingBoxDescent:0,fontBoundingBoxAscent:0,fontBoundingBoxDescent:0},status:SUCCESS_STATUS};const s=FontMetricsStore.getFontMetrics(e);if(!s)return{metrics:null,status:createErrorStatus(StatusCode.NO_METRICS)};const r=new Set;for(const e of t)" "===e||s.hasGlyph(e)||r.add(e);if(r.size>0)return{metrics:null,status:createErrorStatus(StatusCode.PARTIAL_METRICS,{missingChars:r})};const n=[...t];let i=0,o=s.getCharacterMetrics(n[0]);const c=o.actualBoundingBoxLeft;let l,d=0,h=0,g=0;for(let t=0;t<n.length;t++){const r=n[t],c=n[t+1];o=s.getCharacterMetrics(r),d=Math.max(d,o.actualBoundingBoxAscent),h=Math.min(h,o.actualBoundingBoxDescent),g=this.calculateAdvancement_CssPx(s,e,r,c,a),i+=g}return l=i-g,l+=o.actualBoundingBoxRight,{metrics:{width:i,actualBoundingBoxLeft:c,actualBoundingBoxRight:l,actualBoundingBoxAscent:d,actualBoundingBoxDescent:h,fontBoundingBoxAscent:o.fontBoundingBoxAscent,fontBoundingBoxDescent:o.fontBoundingBoxDescent},status:SUCCESS_STATUS}}static drawTextFromAtlas(t,e,a,s,r,n=null){n=n||new TextProperties,BitmapText.#n||(BitmapText.#n=BitmapText.getCanvasFactory()(),BitmapText.#i=BitmapText.#n.getContext("2d"));const i=FontMetricsStore.getFontMetrics(r);if(!i)return{rendered:!1,status:createErrorStatus(StatusCode.NO_METRICS)};const o=new Set;for(const t of e)" "===t||i.hasGlyph(t)||o.add(t);if(o.size>0)return{rendered:!1,status:createErrorStatus(StatusCode.PARTIAL_METRICS,{missingChars:o})};const c=AtlasDataStore.getAtlasData(r),l=BitmapText.#d(c),d=new Set;let h=!1;t.save(),t.setTransform(1,0,0,1,0,0);const g=[...e],u=n.textColor,f=g.find((t=>i.hasGlyph(t)))||g[0],m=i.getCharacterMetrics(f),p=m?BitmapText.#h(n.textBaseline,m):0;let A=0;if("left"!==n.textAlign){const t=BitmapText.measureText(e,r,n);0===t.status.code&&t.metrics?A=BitmapText.#g(n.textAlign,t.metrics.width):console.warn(`BitmapText: Failed to measure text for alignment '${n.textAlign}', defaulting to left alignment`)}const x={x:(a+A)*r.pixelDensity,y:(s+p)*r.pixelDensity};for(let e=0;e<g.length;e++){const a=g[e],s=g[e+1];" "!==a&&(l&&c.hasPositioning(a)||(d.add(a),h=!0)),BitmapText.#u(t,a,x,c,i,u),x.x+=BitmapText.#f(i,r,a,s,n)}let B;if(l){if(!(d.size>0))return t.restore(),{rendered:!0,status:SUCCESS_STATUS};B=StatusCode.PARTIAL_ATLAS}else B=StatusCode.NO_ATLAS;return t.restore(),{rendered:!0,status:createErrorStatus(B,{missingAtlasChars:d.size>0?d:void 0,placeholdersUsed:h})}}static calculateAdvancement_CssPx(t,e,a,s,r){r||(r=new TextProperties);const n=t.getCharacterMetrics(a);let i=0;if(" "===a){const e=t.getSpaceAdvancementOverride();i+=null!==e?e:n.width}else i+=n.width;let o=BitmapText.#m(t,a,s,r);return i-=e.fontSize*o/BitmapText.KERNING_UNIT_DIVISOR,Math.round(i)}static#m(t,e,a,s){return s||(s=new TextProperties),s.isKerningEnabled&&a?t.getKerningAdjustment(e,a):0}static#h(t,e){const a=e.fontBoundingBoxAscent,s=e.fontBoundingBoxDescent,r=e.hangingBaseline,n=e.ideographicBaseline;switch(t){case"top":return a+s;case"hanging":return r+s;case"middle":return(a+s)/2;case"alphabetic":return s;case"ideographic":return s+n;case"bottom":return 0;default:return console.warn(`BitmapText: Unknown textBaseline '${t}', defaulting to 'bottom'. Valid values: top, hanging, middle, alphabetic, ideographic, bottom`),0}}static#g(t,e){switch(t){case"left":return 0;case"center":return-e/2;case"right":return-e;default:return console.warn(`BitmapText: Unknown textAlign '${t}', defaulting to 'left'. Valid values: left, center, right`),0}}static#u(t,e,a,s,r,n){if(!BitmapText.#d(s)){const s=r.getCharacterMetrics(e);return void(s&&BitmapText.#p(t,e,a,s,n))}if(n===BitmapText.#a)return void BitmapText.#A(t,e,a,s,r);if(!s.hasPositioning(e))return;const i=s.atlasPositioning.getPositioning(e),o=s.atlasImage.image,c=BitmapText.#x(o,i,n);BitmapText.#B(t,c,a,i)}static#x(t,e,a){const{xInAtlas:s,tightWidth:r,tightHeight:n}=e;return BitmapText.#n.width=r,BitmapText.#n.height=n,BitmapText.#i.clearRect(0,0,r,n),BitmapText.#i.globalCompositeOperation="source-over",BitmapText.#i.drawImage(t,s,0,r,n,0,0,r,n),BitmapText.#i.globalCompositeOperation="source-in",BitmapText.#i.fillStyle=a,BitmapText.#i.fillRect(0,0,r,n),BitmapText.#n}static#B(t,e,a,s){const{tightWidth:r,tightHeight:n,dx:i,dy:o}=s;t.drawImage(e,0,0,r,n,Math.round(a.x+i),Math.round(a.y+o),r,n)}static#A(t,e,a,s,r){if(!s.hasPositioning(e))return;const n=s.atlasPositioning.getPositioning(e),i=s.atlasImage.image,{xInAtlas:o,tightWidth:c,tightHeight:l,dx:d,dy:h}=n;t.drawImage(i,o,0,c,l,Math.round(a.x+d),Math.round(a.y+h),c,l)}static#p(t,e,a,s,r){if(" "===e)return;if(void 0===s.actualBoundingBoxLeft||void 0===s.actualBoundingBoxRight||void 0===s.actualBoundingBoxAscent||void 0===s.actualBoundingBoxDescent)return void console.warn(`Missing bounding box metrics for character '${e}'`);const n=s.pixelDensity||1,i=Math.round(s.actualBoundingBoxLeft+s.actualBoundingBoxRight)*n,o=Math.round(s.actualBoundingBoxAscent+s.actualBoundingBoxDescent)*n,c=a.x-Math.round(s.actualBoundingBoxLeft)*n,l=a.y-s.fontBoundingBoxDescent*n-s.actualBoundingBoxAscent*n,d=r||"black";t.fillStyle=d,t.fillRect(Math.round(c),Math.round(l),Math.round(i),Math.round(o))}static#f(t,e,a,s,r){return this.calculateAdvancement_CssPx(t,e,a,s,r)*e.pixelDensity}static#d(t){return t instanceof AtlasData&&t.isValid()}static async loadFont(t,e={}){return BitmapText.#c(),BitmapText.#o.loadFont(t,e,BitmapText)}static async loadFonts(t,e={}){return BitmapText.#c(),BitmapText.#o.loadFonts(t,e,BitmapText)}static async loadMetrics(t,e={}){return BitmapText.#c(),BitmapText.#o.loadMetrics(t,e,BitmapText)}static async loadAtlases(t,e={}){return BitmapText.#c(),BitmapText.#o.loadAtlases(t,e,BitmapText)}static setAtlasData(t,e){AtlasDataStore.setAtlasData(t,e)}static getAtlasData(t){return AtlasDataStore.getAtlasData(t)}static deleteAtlas(t){return AtlasDataStore.deleteAtlas(t)}static setFontMetrics(t,e){FontMetricsStore.setFontMetrics(t,e)}static getFontMetrics(t){return FontMetricsStore.getFontMetrics(t)}static unloadFont(t){const e=FontProperties.fromIDString(t);FontMetricsStore.deleteFontMetrics(e),AtlasDataStore.deleteAtlas(e)}static unloadFonts(t){t.forEach((t=>this.unloadFont(t)))}static unloadMetrics(t){const e=FontProperties.fromIDString(t);FontMetricsStore.deleteFontMetrics(e),AtlasDataStore.deleteAtlas(e)}static unloadAtlas(t){const e=FontProperties.fromIDString(t);AtlasDataStore.deleteAtlas(e)}static unloadAllFonts(){FontMetricsStore.clear(),AtlasDataStore.clear()}static unloadAllAtlases(){AtlasDataStore.clear()}static hasFont(t){return this.hasMetrics(t)&&this.hasAtlas(t)}static hasMetrics(t){const e=FontProperties.fromIDString(t);return FontMetricsStore.hasFontMetrics(e)}static hasAtlas(t){const e=FontProperties.fromIDString(t),a=AtlasDataStore.getAtlasData(e);return a&&BitmapText.#d(a)}static getLoadedFonts(){const t=[];for(const e of FontMetricsStore.getAvailableFonts()){const a=FontProperties.fromKey(e),s=AtlasDataStore.getAtlasData(a);s&&BitmapText.#d(s)&&t.push(a.idString)}return t}static getLoadedMetrics(){const t=[];for(const e of FontMetricsStore.getAvailableFonts()){const a=FontProperties.fromKey(e);t.push(a.idString)}return t}static getLoadedAtlases(){const t=[];for(const e of AtlasDataStore.getAvailableFonts()){const a=FontProperties.fromKey(e),s=AtlasDataStore.getAtlasData(a);BitmapText.#d(s)&&t.push(a.idString)}return t}static __resetForTesting(){FontMetricsStore.clear(),AtlasDataStore.clear(),FontLoaderBase._loadingPromises&&FontLoaderBase._loadingPromises.clear(),FontLoaderBase._tempAtlasPackages&&(FontLoaderBase._tempAtlasPackages={}),FontLoaderBase._pendingAtlases&&FontLoaderBase._pendingAtlases.clear(),FontLoaderBase.setFontDirectory&&FontLoaderBase.setFontDirectory(null),BitmapText.#n=null,BitmapText.#i=null,BitmapText.#r=null,BitmapText.#o=null}static#s(){const t=[];for(let e=32;e<=126;e++)t.push(String.fromCharCode(e));const e=[8364,8230,8240,8249,381,8217,8226,8212,8482,353,8250,339,382,376];for(const a of e)t.push(String.fromCharCode(a));for(let e=161;e<=255;e++)173!==e&&t.push(String.fromCharCode(e));return t.push("‚ñà"),t.sort().join("")}}BitmapText.r=BitmapText.registerMetrics,BitmapText.a=BitmapText.registerAtlas;class MetricsExpander{constructor(){throw new Error("MetricsExpander cannot be instantiated - use static methods")}static#T(t){let e;if("undefined"!=typeof Buffer)e=Buffer.from(t,"base64");else{const a=atob(t);e=new Uint8Array(a.length);for(let t=0;t<a.length;t++)e[t]=a.charCodeAt(t)}return Array.from(e)}static#F(t){const e=this.#T(t),a=[];let s=0;for(;s<e.length;){let t,r=0,n=0;do{t=e[s++],r|=(127&t)<<n,n+=7}while(128&t);const i=1&r?-(r+1)/2:r/2;a.push(i)}return a}static#S(t){const e=this.#F(t),a=[e[0]];for(let t=1;t<e.length;t++)a.push(a[t-1]+e[t]);return a}static expand(t){if(void 0===FontMetrics)throw new Error("FontMetrics class not found. Please ensure FontMetrics.js is loaded before MetricsExpander.js");if(!Array.isArray(t)||8!==t.length)throw new Error(`Invalid format - expected 8-element array (Tier 6c), got ${"object"==typeof t?"array":typeof t} with ${t?.length||0} elements.\nPlease regenerate font assets with the current version.`);let[e,a,s,r,n,i,o,c]=t;if(e=this.#C(e),"string"==typeof r)r=this.#S(r),r=this.#C(r);else{if(!Array.isArray(r))throw new Error("Invalid value lookup format - expected array or string");r=this.#C(r)}s=this.#y(s),n=this.#F(n),i=this.#T(i),n=this.#w(n);const l={kerningTable:this.#b(a,e),characterMetrics:this.#I(i,s,r,n,c),spaceAdvancementOverrideForSmallSizesInPx:o},d=Object.keys(l.characterMetrics)[0],h=l.characterMetrics[d]?.pixelDensity;return console.debug(`üîç MetricsExpander: Restored pixelDensity=${h} for ${Object.keys(l.characterMetrics).length} characters`),new FontMetrics(l)}static#b(t,e){const a=this.#M(t),s={};for(const[t,e]of Object.entries(a))s[t]=this.#D(e);const r={};for(const[t,a]of Object.entries(s)){r[t]={};for(const[s,n]of Object.entries(a))r[t][s]=e[n]}return r}static#M(t){const e={};for(const[a,s]of Object.entries(t)){if(a.includes("-")&&a.length>=3){const t=a.indexOf("-"),r=a.substring(0,t),n=a.substring(t+1);if(1===r.length&&1===n.length){const t=BitmapText.CHARACTER_SET.indexOf(r),a=BitmapText.CHARACTER_SET.indexOf(n);if(-1!==t&&-1!==a&&t<=a){for(let r=t;r<=a;r++)e[BitmapText.CHARACTER_SET[r]]=s;continue}}}e[a]=s}return e}static#D(t){const e={};for(const[a,s]of Object.entries(t)){const t=this.#_(a);for(const a of t)e[a]=s}return e}static#_(t){const e=[];let a=0;for("-"===t[0]&&(e.push("-"),a=1);a<t.length;){const s=t[a];if(a+2<t.length&&"-"===t[a+1]){const r=s,n=t[a+2],i=BitmapText.CHARACTER_SET.indexOf(r),o=BitmapText.CHARACTER_SET.indexOf(n);if(-1!==i&&-1!==o&&i<o){for(let t=i;t<=o;t++)e.push(BitmapText.CHARACTER_SET[t]);a+=3}else e.push(s),a++}else e.push(s),a++}return e}static#I(t,e,a,s,r){const n={};return Array.from(BitmapText.CHARACTER_SET).forEach(((i,o)=>{const c=t[o],l=s[c];let d;if(2===l.length){if(void 0===r)throw new Error(`2-element tuplet found but no common left index provided.\nCharacter "${i}" at index ${o}: [${l.join(",")}]\nThis indicates a corrupted Tier 6b font file. Please regenerate font assets.`);d=[l[0],r,l[0],l[1],r]}else if(3===l.length)d=[l[0],l[1],l[0],l[2],l[1]];else if(4===l.length)d=[l[0],l[1],l[0],l[2],l[3]];else{if(5!==l.length)throw new Error(`Invalid glyph tuplet length for character "${i}" at index ${o}.\nExpected 2, 3, 4, or 5 elements, got ${l.length}: [${l.join(",")}]\nThis indicates a corrupted font file. Please regenerate font assets.`);d=l}const h=a[d[0]],g=a[d[1]],u=a[d[2]],f=a[d[3]],m=a[d[4]];n[i]={width:h,actualBoundingBoxLeft:g,actualBoundingBoxRight:u,actualBoundingBoxAscent:f,actualBoundingBoxDescent:m,fontBoundingBoxAscent:e.fba,fontBoundingBoxDescent:e.fbd,emHeightAscent:e.fba,emHeightDescent:e.fbd,hangingBaseline:e.hb,alphabeticBaseline:e.ab,ideographicBaseline:e.ib,pixelDensity:e.pd}})),n}static#C(t){return t.map((t=>t/1e4))}static#y(t){if(!Array.isArray(t)||6!==t.length)throw new Error(`Invalid baseline array - expected 6 elements, got ${t?.length}.\nThis indicates a corrupted font file. Please regenerate font assets.`);return{fba:t[0],fbd:t[1],hb:t[2],ab:t[3],ib:t[4],pd:t[5]}}static#w(t){const e=[];let a=[];for(let s=0;s<t.length;s++){const r=t[s];if(r<0){if(a.push(-r-1),a.length<2||a.length>5)throw new Error(`Invalid tuplet length ${a.length} at position ${s}.\nExpected 2, 3, 4, or 5. This indicates a corrupted font file.\nPlease regenerate font assets.`);e.push(a),a=[]}else a.push(r-1)}if(a.length>0)throw new Error(`Incomplete tuplet at end of data.\nFound ${a.length} elements without negative delimiter.\nThis indicates a corrupted font file. Please regenerate font assets.`);return e}}class AtlasPositioning{constructor(t,e={}){if(!t||"object"!=typeof t)throw new Error("AtlasPositioning constructor requires data object");this._tightWidth=t.tightWidth||{},this._tightHeight=t.tightHeight||{},this._dx=t.dx||{},this._dy=t.dy||{},this._xInAtlas=t.xInAtlas||{},e.mutable||(Object.freeze(this._tightWidth),Object.freeze(this._tightHeight),Object.freeze(this._dx),Object.freeze(this._dy),Object.freeze(this._xInAtlas),Object.freeze(this))}getPositioning(t){return{xInAtlas:this._xInAtlas[t],tightWidth:this._tightWidth[t],tightHeight:this._tightHeight[t],dx:this._dx[t],dy:this._dy[t]}}hasPositioning(t){return void 0!==this._xInAtlas[t]&&void 0!==this._tightWidth[t]&&void 0!==this._tightHeight[t]}hasAtlasPosition(t){return void 0!==this._xInAtlas[t]}getAvailableCharacters(){return Object.keys(this._xInAtlas)}getTightWidth(t){return this._tightWidth[t]}getTightHeight(t){return this._tightHeight[t]}getXInAtlas(t){return this._xInAtlas[t]}getDx(t){return this._dx[t]}getDy(t){return this._dy[t]}getHash(){const t=this.getAvailableCharacters().sort(),e=[];for(const a of t){const t=this.getPositioning(a);e.push(`${a}:w${t.tightWidth}h${t.tightHeight}x${t.dx}y${t.dy}a${t.xInAtlas}`)}const a=e.join("|");let s=2166136261;for(let t=0;t<a.length;t++)s^=a.charCodeAt(t),s+=(s<<1)+(s<<4)+(s<<7)+(s<<8)+(s<<24);return(s>>>0).toString(16).substring(0,6).padStart(6,"0")}}class AtlasImage{constructor(t,e={}){if(!t)throw new Error("AtlasImage constructor requires image (Canvas or Image element)");if("object"!=typeof t||void 0===t.width&&void 0===t.naturalWidth)throw new Error("AtlasImage constructor requires Canvas or Image element with width property");this.image=t,e.mutable||Object.freeze(this)}get width(){return this.image.naturalWidth||this.image.width||0}get height(){return this.image.naturalHeight||this.image.height||0}isValid(){return this.image&&"object"==typeof this.image&&this.width>0&&this.height>0}canRender(){return!!this.isValid()&&(!(this.image instanceof Image)||this.image.complete&&this.image.naturalWidth>0)}getImageType(){return this.image instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&this.image instanceof OffscreenCanvas?"canvas":this.image instanceof Image||this.image instanceof HTMLImageElement?"image":"unknown"}getContext(t="2d"){return"canvas"===this.getImageType()?this.image.getContext(t):null}equals(t){return t instanceof AtlasImage&&this.image===t.image}getDebugInfo(){return{type:this.getImageType(),width:this.width,height:this.height,isValid:this.isValid(),canRender:this.canRender()}}}class AtlasData{constructor(t,e){if(!(t instanceof AtlasImage))throw new Error("AtlasData constructor requires AtlasImage instance (not raw Canvas/Image)");if(e&&!(e instanceof AtlasPositioning))throw new Error("AtlasData constructor requires AtlasPositioning instance (not raw positioning object)");this.atlasImage=t,this.atlasPositioning=e,Object.freeze(this)}hasPositioning(t){return!!this.atlasPositioning&&this.atlasPositioning.hasPositioning(t)}isValid(){return this.atlasImage?.isValid()}getAvailableCharacters(){return this.atlasPositioning?this.atlasPositioning.getAvailableCharacters():[]}get width(){return this.atlasImage.width}get height(){return this.atlasImage.height}canRender(){return this.atlasImage?.canRender()}equals(t){return t instanceof AtlasData&&this.atlasImage.equals(t.atlasImage)&&this.atlasPositioning===t.atlasPositioning}getDebugInfo(){return{atlasImage:this.atlasImage?this.atlasImage.getDebugInfo():null,atlasPositioning:this.atlasPositioning?{availableCharacters:this.atlasPositioning.getAvailableCharacters().length,characters:this.atlasPositioning.getAvailableCharacters().slice(0,10)}:null,isValid:this.isValid(),canRender:this.canRender()}}}class AtlasReconstructionUtils{constructor(){throw new Error("AtlasReconstructionUtils cannot be instantiated - use static methods")}static getImageData(t){const e=t?.image?t.image:t;if(!e)throw new Error("getImageData: Invalid image source (null or undefined)");if(e.getContext)return e.getContext("2d").getImageData(0,0,e.width,e.height);if(void 0!==e.naturalWidth||void 0!==e.width){const t=BitmapText.getCanvasFactory()();t.width=e.naturalWidth||e.width,t.height=e.naturalHeight||e.height;const a=t.getContext("2d");return a.drawImage(e,0,0),a.getImageData(0,0,t.width,t.height)}throw new Error("getImageData: Image source is not a Canvas or Image element")}}class AtlasCellDimensions{constructor(){throw new Error("AtlasCellDimensions cannot be instantiated - use static methods")}static getWidth(t){return Math.round(t.actualBoundingBoxLeft+t.actualBoundingBoxRight)}static getHeight(t){return Math.round(t.fontBoundingBoxAscent+t.fontBoundingBoxDescent)}static getDimensions(t){return{width:this.getWidth(t),height:this.getHeight(t)}}}class TightAtlasReconstructor{constructor(){throw new Error("TightAtlasReconstructor cannot be instantiated - use static methods")}static reconstructFromAtlas(t,e){const a=AtlasReconstructionUtils.getImageData(e),s=t.getAvailableCharacters().sort();if(0===s.length)throw new Error("TightAtlasReconstructor: No characters found in FontMetrics");console.debug(`TightAtlasReconstructor: Processing ${s.length} characters`);const r=s[0],n=t.getCharacterMetrics(r),i=AtlasCellDimensions.getHeight(n),o=n.pixelDensity||1,c=Math.round(i*o);console.debug(`üîç TightAtlasReconstructor: pixelDensity=${o}, height_CssPx=${i}, cellHeight_PhysPx=${c}`);let l=0;const d={},h=[];for(const e of s){const s=t.getCharacterMetrics(e),r=AtlasCellDimensions.getWidth(s),n=Math.round(r*o);h.length<5&&h.push(`${e}:css=${r},phys=${n},x=${l}`);const i=this.findTightBounds(a,l,0,n,c);i&&(d[e]=i),l+=n}return console.debug(`üîç Cell dimensions (first 5): ${h.join(", ")}`),this.packTightAtlas(t,d,s,e,o,c)}static findTightBounds(t,e,a,s,r){const n=t.data,i=4*t.width,o=(t,e)=>n[e*i+(t<<2)+3];let c=-1;for(let t=a+r-1;t>=a&&-1===c;t--)for(let a=e;a<e+s&&-1===c;a++)o(a,t)>0&&(c=t);if(-1===c)return null;let l=a;for(let t=a;t<=c;t++){let a=!1;for(let r=e;r<e+s;r++)if(o(r,t)>0){l=t,a=!0;break}if(a)break}let d=e;for(let t=e;t<e+s;t++){let e=!1;for(let a=l;a<=c;a++)if(o(t,a)>0){d=t,e=!0;break}if(e)break}let h=e+s-1;for(let t=e+s-1;t>=e;t--){let e=!1;for(let a=l;a<=c;a++)if(o(t,a)>0){h=t,e=!0;break}if(e)break}return{left:d-e,top:l-a,width:h-d+1,height:c-l+1}}static packTightAtlas(t,e,a,s,r,n){let i=0,o=0;for(const t of a)e[t]&&(i+=e[t].width,o=Math.max(o,e[t].height));const c=BitmapText.getCanvasFactory()();c.width=i,c.height=o;const l=c.getContext("2d");let d=0;const h={tightWidth:{},tightHeight:{},dx:{},dy:{},xInAtlas:{}};let g=0;for(const i of a){const a=t.getCharacterMetrics(i),o=AtlasCellDimensions.getWidth(a),c=Math.round(o*r),u=e[i];if(!u){g+=c;continue}const f=BitmapText.getCanvasFactory()();f.width=u.width,f.height=u.height;const m=f.getContext("2d"),p=Math.floor(g+u.left),A=Math.floor(u.top),x=Math.floor(u.width),B=Math.floor(u.height);m.drawImage(s,p,A,x,B,0,0,x,B),l.drawImage(f,d,0);const T=n-(u.top+u.height-1)-1;h.tightWidth[i]=u.width,h.tightHeight[i]=u.height,h.xInAtlas[i]=d,h.dx[i]=-Math.round(a.actualBoundingBoxLeft)*r+u.left,h.dy[i]=-u.height-T+1*r,d+=u.width,g+=c}const u=new AtlasImage(c),f=new AtlasPositioning(h);return console.debug(`TightAtlasReconstructor: Packed ${Object.keys(h.xInAtlas).length} glyphs into ${i}√ó${o} atlas`),{atlasImage:u,atlasPositioning:f}}}class AtlasDataStore{static#E=new Map;static getAtlasData(t){return AtlasDataStore.#E.get(t.key)}static setAtlasData(t,e){if(!(e instanceof AtlasData))throw new Error("AtlasDataStore.setAtlasData requires AtlasData instance (not raw images)");AtlasDataStore.#E.set(t.key,e)}static isValidAtlas(t){return t instanceof AtlasData&&t.isValid()}static getAvailableFonts(){return Array.from(AtlasDataStore.#E.keys())}static hasAtlas(t){return AtlasDataStore.#E.has(t.key)}static deleteAtlas(t){return AtlasDataStore.#E.delete(t.key)}static clear(){AtlasDataStore.#E.clear()}static size(){return AtlasDataStore.#E.size}}class FontMetricsStore{static#P=new Map;static getFontMetrics(t){return FontMetricsStore.#P.get(t.key)}static setFontMetrics(t,e){FontMetricsStore.#P.set(t.key,e)}static hasFontMetrics(t){return FontMetricsStore.#P.has(t.key)}static deleteFontMetrics(t){return FontMetricsStore.#P.delete(t.key)}static getAvailableFonts(){return Array.from(FontMetricsStore.#P.keys())}static clear(){FontMetricsStore.#P.clear()}static size(){return FontMetricsStore.#P.size}}class FontManifest{static#v=[];static addFontIDs(t){const e=Array.isArray(t)?t:[t];for(const t of e)"string"!=typeof t||this.#v.includes(t)||this.#v.push(t)}static allFontIDs(){return[...this.#v]}static hasFontID(t){return this.#v.includes(t)}static count(){return this.#v.length}static clear(){this.#v.length=0}static allFontIDsSorted(){return[...this.#v].sort()}}class FontLoaderBase{static _tempAtlasPackages={};static _pendingAtlases=new Map;static _loadingPromises=new Map;static DEFAULT_FONT_DIRECTORY="./font-assets/";static#L=null;static setFontDirectory(t){FontLoaderBase.#L=t}static getFontDirectory(){return FontLoaderBase.#L??FontLoaderBase.DEFAULT_FONT_DIRECTORY}static getDefaultFontDirectory(){return FontLoaderBase.DEFAULT_FONT_DIRECTORY}static registerMetrics(t,e,a){if("string"!=typeof t)return void console.warn("FontLoader.registerMetrics: Invalid idString - must be string");if(void 0===MetricsExpander)return void console.warn("FontLoader.registerMetrics: MetricsExpander not available");if(void 0===FontProperties)return void console.warn("FontLoader.registerMetrics: FontProperties not available");const s=FontProperties.fromIDString(t),r=MetricsExpander.expand(e);FontMetricsStore.setFontMetrics(s,r),FontLoaderBase._processPendingAtlas(t)}static registerAtlas(t,e){"string"==typeof t&&"string"==typeof e?FontLoaderBase._tempAtlasPackages[t]={base64Data:e}:console.warn("FontLoader.registerAtlas: Invalid arguments - idString and base64Data must be strings")}static async loadFont(t,e,a){return this.loadFonts([t],e,a)}static async loadFonts(t,e={},a){const{onProgress:s=null,isFileProtocol:r=!1,loadMetrics:n=!0,loadAtlases:i=!0}=e,o=(n?1:0)+(i?1:0),c=t.length*o;let l=0;const d=()=>{s&&s(l,c)};for(const e of t){if(FontLoaderBase._loadingPromises.has(e)){await FontLoaderBase._loadingPromises.get(e);continue}const t=(async()=>{try{n&&(await this.loadMetricsFile(e,a),l++,d()),i&&(await this.loadAtlasFile(e,r,a),l++,d())}finally{FontLoaderBase._loadingPromises.delete(e)}})();FontLoaderBase._loadingPromises.set(e,t),await t}}static async loadMetrics(t,e,a){return this.loadFonts(t,{...e,loadAtlases:!1},a)}static async loadAtlases(t,e,a){return this.loadFonts(t,{...e,loadMetrics:!1},a)}static async loadMetricsFile(t,e){throw new Error("FontLoaderBase.loadMetricsFile() must be implemented by derived class")}static async loadAtlasFile(t,e,a){throw new Error("FontLoaderBase.loadAtlasFile() must be implemented by derived class")}static _loadAtlasFromPackage(t,e,a){const s=FontProperties.fromIDString(t);delete FontLoaderBase._tempAtlasPackages[t];const r=FontMetricsStore.getFontMetrics(s);if(!r)return FontLoaderBase._pendingAtlases.set(t,{atlasImage:e,bitmapTextClass:a}),!1;if(void 0===TightAtlasReconstructor)throw new Error(`FontLoader: TightAtlasReconstructor required for font loading - not available for ${t}`);const{atlasImage:n,atlasPositioning:i}=TightAtlasReconstructor.reconstructFromAtlas(r,e),o=new AtlasData(n,i);return AtlasDataStore.setAtlasData(s,o),!0}static _processPendingAtlas(t){if(!FontLoaderBase._pendingAtlases.has(t))return;const{atlasImage:e,bitmapTextClass:a}=FontLoaderBase._pendingAtlases.get(t);FontLoaderBase._pendingAtlases.delete(t),FontLoaderBase._loadAtlasFromPackage(t,e,a)}}class FontLoader extends FontLoaderBase{static METRICS_PREFIX="metrics-";static ATLAS_PREFIX="atlas-";static JS_EXTENSION=".js";static WEBP_EXTENSION=".webp";static async loadMetricsFile(t,e){return new Promise(((e,a)=>{const s=document.createElement("script"),r=FontLoaderBase.getFontDirectory();s.src=`${r}${FontLoader.METRICS_PREFIX}${t}${FontLoader.JS_EXTENSION}`,s.onload=()=>{e()},s.onerror=()=>{s.remove(),console.warn(`Metrics JS not found: metrics-${t}.js - font will not be available`),a(new Error(`Metrics not found for ${t}`))},document.head.appendChild(s)}))}static async loadAtlasFile(t,e,a){return e?FontLoader._loadAtlasFromJS(t,a):FontLoader._loadAtlasFromWebP(t,a)}static _loadAtlasFromJS(t,e){return new Promise(((a,s)=>{const r=document.createElement("script"),n=FontLoaderBase.getFontDirectory();r.src=`${n}${FontLoader.ATLAS_PREFIX}${t}-webp${FontLoader.JS_EXTENSION}`,r.onload=()=>{const s=FontLoaderBase._tempAtlasPackages[t];if(!s||!s.base64Data)return console.warn(`Image data not found in JS file for ${t} - will use placeholder rectangles`),r.remove(),void a();const n=new Image;n.src=`data:image/webp;base64,${s.base64Data}`,n.onload=()=>{FontLoaderBase._loadAtlasFromPackage(t,n,e),r.remove(),a()},n.onerror=()=>{console.warn(`Failed to decode base64 WebP data for ${t} - will use placeholder rectangles`),r.remove(),delete FontLoaderBase._tempAtlasPackages[t],a()}},r.onerror=()=>{console.warn(`Atlas JS not found: atlas-${t}-webp.js - will use placeholder rectangles`),r.remove(),a()},document.head.appendChild(r)}))}static _loadAtlasFromWebP(t,e){return new Promise(((a,s)=>{const r=new Image,n=FontLoaderBase.getFontDirectory();r.src=`${n}${FontLoader.ATLAS_PREFIX}${t}${FontLoader.WEBP_EXTENSION}`,r.onload=()=>{FontLoaderBase._loadAtlasFromPackage(t,r,e),a()},r.onerror=()=>{console.warn(`Atlas image not found: atlas-${t}.webp - will use placeholder rectangles`),a()}}))}}
//# sourceMappingURL=bitmaptext.min.js.map