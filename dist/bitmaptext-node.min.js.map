{"version":3,"names":["StatusCode","Object","freeze","SUCCESS","NO_METRICS","PARTIAL_METRICS","NO_ATLAS","PARTIAL_ATLAS","SUCCESS_STATUS","code","createErrorStatus","details","isSuccess","status","isCompleteFailure","isPartialSuccess","getStatusDescription","missingChars","join","missingAtlasChars","FontProperties","constructor","pixelDensity","fontFamily","fontStyle","fontWeight","fontSize","this","_key","_idString","formatNumber","num","str","String","includes","replace","key","idString","fromIDString","parts","split","parseFloat","formatNumericPart","fromKey","integerPart","decimalPart","equals","other","TextProperties","options","isKerningEnabled","textBaseline","textAlign","textColor","withKerning","withColor","forBitmapText","withKerningEnabled","withTextColor","toObject","FontMetrics","data","Error","_kerningTable","kerningTable","_characterMetrics","characterMetrics","_spaceAdvancementOverride","spaceAdvancementOverrideForSmallSizesInPx","mutable","getCharacterMetrics","char","getKerningAdjustment","leftChar","rightChar","hasGlyph","getSpaceAdvancementOverride","getKerningTable","getAvailableCharacters","keys","BitmapText","static","generateCharacterSet","document","createElement","setFontDirectory","path","ensureFontLoader","fontLoader","getFontDirectory","setCanvasFactory","factory","canvasFactory","coloredGlyphCanvas","coloredGlyphCtx","getCanvasFactory","configure","undefined","fontDirectory","FontLoader","parametersToIDString","density","styleIdx","weightIdx","size","style","weight","densityStr","densityFormatted","sizeStr","registerMetrics","compactedData","fullIDString","FontLoaderBase","registerAtlas","base64Data","measureText","text","fontProperties","textProperties","length","metrics","width","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","fontBoundingBoxAscent","fontBoundingBoxDescent","fontMetrics","FontMetricsStore","getFontMetrics","Set","add","chars","width_CssPx","actualBoundingBoxLeft_CssPx","actualBoundingBoxRight_CssPx","advancement_CssPx","i","nextChar","Math","max","min","calculateAdvancement_CssPx","drawTextFromAtlas","ctx","x_CssPx","y_CssPx","getContext","rendered","missingMetricsChars","atlasData","AtlasDataStore","getAtlasData","atlasValid","isValidAtlas","placeholdersUsed","save","setTransform","firstChar","find","c","characterMetricsForBaseline","baselineOffset_CssPx","calculateBaselineOffsetToBottom","alignmentOffset_CssPx","measureResult","calculateAlignmentOffsetToLeft","console","warn","position_PhysPx","x","y","currentChar","hasPositioning","drawCharacter","calculateCharacterAdvancement_PhysPx","statusCode","restore","spaceAdvancementOverrideForSmallSizesInPx_CssPx","kerningCorrection","getKerningCorrection","KERNING_UNIT_DIVISOR","round","fba","fbd","hb","hangingBaseline","ib","ideographicBaseline","textWidth_CssPx","drawPlaceholderRectangle","DEFAULT_TEXT_COLOR","drawCharacterDirect","atlasPositioning","getPositioning","atlasImage","image","createColoredGlyph","renderGlyphToMainCanvas","xInAtlas","tightWidth","tightHeight","height","clearRect","globalCompositeOperation","drawImage","fillStyle","fillRect","dx","dy","width_PhysPx","height_PhysPx","rectX_PhysPx","rectY_PhysPx","actualColor","AtlasData","isValid","loadFont","loadFonts","idStrings","loadMetrics","loadAtlases","setAtlasData","deleteAtlas","setFontMetrics","unloadFont","deleteFontMetrics","unloadFonts","forEach","id","unloadMetrics","unloadAtlas","unloadAllFonts","clear","unloadAllAtlases","hasFont","hasMetrics","hasAtlas","hasFontMetrics","getLoadedFonts","loaded","getAvailableFonts","push","getLoadedMetrics","getLoadedAtlases","__resetForTesting","_loadingPromises","_tempAtlasPackages","_pendingAtlases","fromCharCode","cp1252PrintableChars","sort","r","a","MetricsExpander","decodeFromBase64Bytes","base64","bytes","Buffer","from","binary","atob","Uint8Array","charCodeAt","Array","decodeVarInts","integers","byte","value","shift","signed","decompressValueArray","deltas","sorted","expand","minified","isArray","kv","k","b","v","t","g","s","cl","convertIntegersToValues","unflattenBaseline","unflattenTuplets","expandedData","expandKerningTable","expandCharacterMetrics","debug","kerningValueLookup","leftExpanded","expandLeftSide","rangeExpanded","pairs","entries","expandKerningPairs","expanded","index","rightSideObj","hyphenIndex","indexOf","startChar","substring","endChar","startIndex","CHARACTER_SET","endIndex","parseCompactCharString","compactStr","j","tupletIndices","metricsCommonToAllCharacters","valueLookup","tupletLookup","commonLeftIndex","tupletIndex","compressed","indices","emHeightAscent","emHeightDescent","alphabeticBaseline","ab","pd","map","int","baselineArray","flattened","tuplets","currentTuplet","AtlasPositioning","_tightWidth","_tightHeight","_dx","_dy","_xInAtlas","hasAtlasPosition","getTightWidth","getTightHeight","getXInAtlas","getDx","getDy","getHash","pos","hash","toString","padStart","AtlasImage","naturalWidth","naturalHeight","canRender","Image","complete","getImageType","HTMLCanvasElement","OffscreenCanvas","HTMLImageElement","contextType","getDebugInfo","type","availableCharacters","characters","slice","AtlasReconstructionUtils","getImageData","actualImage","canvas","AtlasCellDimensions","getWidth","charMetrics","getHeight","getDimensions","TightAtlasReconstructor","reconstructFromAtlas","imageData","firstMetrics","height_CssPx","cellHeight_PhysPx","cellX_PhysPx","tightBounds","cellDebugInfo","cellWidth_PhysPx","bounds","findTightBounds","packTightAtlas","cellY_PhysPx","pixels","stride","getAlpha","bottom_PhysPx","top_PhysPx","found","left_PhysPx","right_PhysPx","left","top","sourceAtlasImage","totalWidth_PhysPx","maxHeight_PhysPx","tightCanvas","xInTightAtlas_PhysPx","positioning","tempCanvas","tempCtx","srcX_PhysPx","floor","srcY_PhysPx","srcWidth_PhysPx","srcHeight_PhysPx","distanceBetweenBottomAndBottomOfCanvas_PhysPx","tightAtlasImage","Map","atlases","get","set","atlas","has","delete","FontManifest","addFontIDs","ids","idsArray","fontIDs","allFontIDs","hasFontID","count","allFontIDsSorted","DEFAULT_FONT_DIRECTORY","getDefaultFontDirectory","bitmapTextClass","_processPendingAtlas","onProgress","isFileProtocol","filesPerFont","totalFiles","loadedFiles","reportProgress","loadPromise","loadMetricsFile","loadAtlasFile","_loadAtlasFromPackage","QOIDecode","arrayBuffer","byteOffset","byteLength","outputChannels","uint8","magic1","magic2","magic3","magic4","channels","colorspace","pixelLength","result","arrayPosition","indexPosition","red","green","blue","alpha","chunksLength","run","pixelPosition","byte1","byte2","greenDiff","require","fs","metricsPath","resolve","METRICS_PREFIX","JS_EXTENSION","metricsCode","readFileSync","eval","error","atlasPath","ATLAS_PREFIX","atlasCode","pkg","qoiData","decoded","buffer","createImageData","putImageData","message","global"],"sources":["/Users/davidedellacasa/code/BitmapText.js/dist/bitmaptext-node.js"],"sourcesContent":["/**\n * BitmapText.js - Runtime Bundle\n *\n * Pixel-perfect bitmap text rendering for HTML5 Canvas\n *\n * ⚠️  DO NOT EDIT - Generated by scripts/build-runtime-bundle.sh\n *\n * This bundle contains the complete BitmapText.js runtime for rendering\n * pre-generated bitmap fonts. It does NOT include font generation tools.\n *\n * Bundle Contents:\n *   - StatusCode (status reporting)\n *   - FontProperties/TextProperties (configuration)\n *   - FontMetrics (font metrics domain object)\n *   - BitmapText (core runtime with CHARACTER_SET)\n *   - MetricsExpander (minified metrics expansion)\n *   - Atlas classes (AtlasPositioning, AtlasImage, AtlasData)\n *   - TightAtlasReconstructor (runtime atlas reconstruction)\n *   - FontLoader (font loading with platform detection)\n *   - Atlas/Metrics stores (data storage)\n *\n * Usage (Browser):\n *   <script src=\"dist/bitmaptext.min.js\"></script>\n *   <script>\n *     const fontProps = new FontProperties(1, \"Arial\", \"normal\", \"normal\", 19);\n *     await BitmapText.loadFont(fontProps.idString);\n *     BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 50, fontProps);\n *   </script>\n *\n * Usage (Node.js):\n *   import { createCanvas } from 'node-canvas';  // or 'skia-canvas'\n *   import './dist/bitmaptext-node.min.js';\n *\n *   BitmapText.configure({\n *     fontDirectory: './font-assets/',\n *     canvasFactory: () => createCanvas()\n *   });\n *\n *   await BitmapText.loadFont(fontProps.idString);\n *   BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 50, fontProps);\n *\n * License: SEE LICENSE IN LICENSE\n */\n\n// ============================================================================\n// StatusCode.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/StatusCode.js\n// ============================================================================\n\n// StatusCode - Core Runtime Constants\n//\n// This is a CORE RUNTIME module designed for minimal bundle size (~0.5KB).\n// It provides status code constants and pre-created status objects for performance optimization.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Used by BitmapText for efficient status reporting\n// - No dependencies, pure constants and helper objects\n//\n// PERFORMANCE OPTIMIZATIONS:\n// - Numeric codes for faster comparisons than strings\n// - Pre-created immutable SUCCESS_STATUS object to avoid allocations\n// - Frozen objects for memory safety and immutability\n\n/**\n * Status codes for BitmapText operations\n * Using numeric values for optimal performance in comparisons\n */\nconst StatusCode = Object.freeze({\n  SUCCESS: 0,           // Everything worked perfectly\n  NO_METRICS: 1,        // No FontMetrics found at all for this font configuration\n  PARTIAL_METRICS: 2,   // Some characters missing metrics data\n  NO_ATLAS: 3,          // No atlas available (will render placeholder rectangles)\n  PARTIAL_ATLAS: 4      // Some characters missing from atlas (partial placeholders)\n});\n\n/**\n * Pre-created immutable success status object for performance\n * Reused for all successful operations to avoid object allocation overhead\n */\nconst SUCCESS_STATUS = Object.freeze({\n  code: StatusCode.SUCCESS\n});\n\n/**\n * Helper function to create error status objects\n * @param {number} code - StatusCode value\n * @param {Object} details - Additional details object\n * @returns {Object} Immutable status object\n */\nfunction createErrorStatus(code, details = {}) {\n  return Object.freeze({\n    code,\n    ...details\n  });\n}\n\n/**\n * Helper function to check if a status indicates success\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates success\n */\nfunction isSuccess(status) {\n  return status?.code === StatusCode.SUCCESS;\n}\n\n/**\n * Helper function to check if a status indicates complete failure\n * (NO_METRICS or PARTIAL_METRICS - cannot render at all)\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates complete failure\n */\nfunction isCompleteFailure(status) {\n  return status && (\n    status.code === StatusCode.NO_METRICS ||\n    status.code === StatusCode.PARTIAL_METRICS\n  );\n}\n\n/**\n * Helper function to check if a status indicates partial success\n * (NO_ATLAS or PARTIAL_ATLAS - can render with placeholders)\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates partial success\n */\nfunction isPartialSuccess(status) {\n  return status && (\n    status.code === StatusCode.NO_ATLAS ||\n    status.code === StatusCode.PARTIAL_ATLAS\n  );\n}\n\n/**\n * Helper function to get human-readable status description\n * @param {Object} status - Status object with code property\n * @returns {string} Human-readable description\n */\nfunction getStatusDescription(status) {\n  if (!status || typeof status.code !== 'number') {\n    return 'Invalid status';\n  }\n\n  switch (status.code) {\n    case StatusCode.SUCCESS:\n      return 'Success';\n    case StatusCode.NO_METRICS:\n      return 'No font metrics available';\n    case StatusCode.PARTIAL_METRICS:\n      return `Missing metrics for characters: ${status.missingChars ? [...status.missingChars].join('') : 'unknown'}`;\n    case StatusCode.NO_ATLAS:\n      return 'No atlas available (using placeholders)';\n    case StatusCode.PARTIAL_ATLAS:\n      return `Missing atlas data for characters: ${status.missingAtlasChars ? [...status.missingAtlasChars].join('') : 'unknown'} (using placeholders)`;\n    default:\n      return `Unknown status code: ${status.code}`;\n  }\n}\n// ============================================================================\n// FontProperties.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontProperties.js\n// ============================================================================\n\n// FontProperties - Core Runtime Class  \n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It provides essential font configuration management with maximum performance.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontPropertiesFAB for validation and font assets building utilities  \n// - Contains no validation code to minimize runtime overhead\n// - Optimized for performance with pre-computed keys and immutability\n//\n// ARCHITECTURE:\n// - Immutable font configuration object safe to use as Map keys\n// - Pre-computes storage keys and ID strings for optimal lookup performance\n// - Provides factory methods for creating instances from various inputs\n// - Properties in fixed order: pixelDensity, fontFamily, fontStyle, fontWeight, fontSize\n//\n// For validation and font assets building utilities, use FontPropertiesFAB.\nclass FontProperties {\n  constructor(pixelDensity, fontFamily, fontStyle, fontWeight, fontSize) {\n    // Direct assignment, no validation in core for performance\n    this.pixelDensity = pixelDensity || 1;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = fontWeight || 'normal';\n    this.fontSize = fontSize;\n    \n    // Pre-compute storage key (critical for performance optimization)\n    // Used for Map lookups in AtlasDataStore\n    this._key = `${this.pixelDensity}:${this.fontFamily}:${this.fontStyle}:${this.fontWeight}:${this.fontSize}`;\n    \n    // Pre-compute ID string for file naming and manifest keys\n    // Format: density-1-0-Arial-style-normal-weight-normal-size-18-0\n    this._idString = `density-${this.#formatNumber(this.pixelDensity)}-${this.fontFamily}-style-${this.fontStyle}-weight-${this.fontWeight}-size-${this.#formatNumber(this.fontSize)}`;\n    \n    // Freeze for immutability (safe to use as Map keys)\n    Object.freeze(this);\n  }\n  \n  // Format number handling non-integers: 1.5 → \"1-5\", 18.5 → \"18-5\", 18 → \"18-0\"\n  #formatNumber(num) {\n    const str = String(num);\n    return str.includes('.') ? str.replace('.', '-') : `${str}-0`;\n  }\n  \n  // Getter for pre-computed storage key\n  get key() {\n    return this._key;\n  }\n  \n  // Getter for pre-computed ID string\n  get idString() {\n    return this._idString;\n  }\n  \n  \n  // Factory method to create FontProperties from ID string\n  // Parses: density-1-0-Arial-style-normal-weight-normal-size-18-0\n  static fromIDString(idString) {\n    const parts = idString.split('-');\n\n    // Extract and format numeric values (handling decimal parts)\n    const pixelDensity = parseFloat(FontProperties.#formatNumericPart(parts[1], parts[2]));\n    const fontSize = parseFloat(FontProperties.#formatNumericPart(parts[9], parts[10]));\n    const fontFamily = parts[3];\n    const fontStyle = parts[5];\n    const fontWeight = parts[7];\n\n    // Return new FontProperties instance\n    return new FontProperties(pixelDensity, fontFamily, fontStyle, fontWeight, fontSize);\n  }\n\n  // Factory method to create FontProperties from storage key\n  // Parses: \"1:Arial:normal:normal:19\" or \"1.5:Arial:italic:bold:18.5\"\n  static fromKey(key) {\n    const [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize] = key.split(':');\n\n    // Return new FontProperties instance with parsed numeric values\n    return new FontProperties(\n      parseFloat(pixelDensity),\n      fontFamily,\n      fontStyle,\n      fontWeight,\n      parseFloat(fontSize)\n    );\n  }\n\n  // Helper method to format numeric parts (used by fromIDString)\n  static #formatNumericPart(integerPart, decimalPart) {\n    if (!decimalPart || decimalPart === '0') {\n      return integerPart;\n    }\n    return `${integerPart}.${decimalPart}`;\n  }\n  \n  // Equality comparison based on key\n  equals(other) {\n    if (!(other instanceof FontProperties)) return false;\n    return this._key === other._key;\n  }\n}\n// ============================================================================\n// TextProperties.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/TextProperties.js\n// ============================================================================\n\n// TextProperties - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It provides essential text rendering configuration with maximum performance.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Manages text rendering properties: kerning, alignment, baseline, color\n// - Contains no validation code to minimize runtime overhead\n// - Optimized for performance with pre-computed keys and immutability\n//\n// ARCHITECTURE:\n// - Immutable text configuration object safe to use as Map keys\n// - Pre-computes storage keys for optimal lookup performance\n// - Provides factory methods for creating instances from various inputs\n// - Properties: isKerningEnabled, textBaseline, textAlign, textColor\n//\n// This class replaces the global isKerningEnabled variable and consolidates\n// all text rendering properties into a single, immutable configuration object.\nclass TextProperties {\n  constructor(options = {}) {\n    // Extract options with defaults - optimized for BitmapText usage\n    const {\n      isKerningEnabled = true,        // Enable kerning by default for better text rendering\n      textBaseline = 'bottom',        // BitmapText uses 'bottom' baseline by architectural design (HTML5 Canvas default is 'alphabetic')\n      textAlign = 'left',             // HTML5 Canvas default\n      textColor = '#000000'           // Black color default\n    } = options;\n\n    // Direct assignment, no validation in core for performance\n    this.isKerningEnabled = isKerningEnabled;\n    this.textBaseline = textBaseline;\n    this.textAlign = textAlign;\n    this.textColor = textColor;\n\n    // Pre-compute storage key (for potential caching or Map lookups)\n    this._key = `kerning:${this.isKerningEnabled}:baseline:${this.textBaseline}:align:${this.textAlign}:color:${this.textColor}`;\n\n    // Freeze for immutability (safe to use as Map keys)\n    Object.freeze(this);\n  }\n\n  // Getter for pre-computed storage key\n  get key() {\n    return this._key;\n  }\n\n  // Factory method to create TextProperties with specific kerning setting\n  static withKerning(isKerningEnabled, options = {}) {\n    return new TextProperties({\n      ...options,\n      isKerningEnabled\n    });\n  }\n\n  // Factory method to create TextProperties with specific color\n  static withColor(textColor, options = {}) {\n    return new TextProperties({\n      ...options,\n      textColor\n    });\n  }\n\n  // Factory method to create TextProperties for BitmapText (uses 'bottom' baseline)\n  static forBitmapText(options = {}) {\n    return new TextProperties({\n      textBaseline: 'bottom',  // BitmapText uses bottom baseline positioning\n      ...options\n    });\n  }\n\n  // Create a new TextProperties with modified kerning\n  withKerningEnabled(isKerningEnabled) {\n    return new TextProperties({\n      isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor: this.textColor\n    });\n  }\n\n  // Create a new TextProperties with modified color\n  withTextColor(textColor) {\n    return new TextProperties({\n      isKerningEnabled: this.isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor\n    });\n  }\n\n  // Equality comparison based on key\n  equals(other) {\n    if (!(other instanceof TextProperties)) return false;\n    return this._key === other._key;\n  }\n\n  // Return plain object for compatibility/debugging\n  toObject() {\n    return {\n      isKerningEnabled: this.isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor: this.textColor\n    };\n  }\n}\n// ============================================================================\n// FontMetrics.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontMetrics.js\n// ============================================================================\n\n// FontMetrics - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~3-4KB).\n// It encapsulates all metrics data for a single font configuration as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontMetricsFAB for font assets building capabilities\n// - Contains only essential metrics data and accessor methods\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Immutable object representing all metrics for ONE font configuration\n// - Pre-computed lookups for optimal performance during text rendering\n// - Provides clean API without needing fontProperties passed to every method\n// - Follows same immutable pattern as FontProperties\n//\n// SEPARATION RATIONALE:\n// - Encapsulates related metrics data together\n// - Eliminates repeated fontProperties parameter passing\n// - Serves as domain object for font metrics\n// - Enables cleaner, more object-oriented API\n//\n// For font assets building capabilities, use FontMetricsFAB which extends this class.\nclass FontMetrics {\n  constructor(data, options = {}) {\n    // Validate input data structure\n    if (!data || typeof data !== 'object') {\n      throw new Error('FontMetrics constructor requires data object');\n    }\n    \n    // Kerning table: character pairs → adjustment values\n    this._kerningTable = data.kerningTable || {};\n    \n    // Character metrics: character → TextMetrics-compatible object\n    this._characterMetrics = data.characterMetrics || {};\n    \n    // Space advancement override for small font sizes\n    this._spaceAdvancementOverride = data.spaceAdvancementOverrideForSmallSizesInPx || null;\n    \n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this._kerningTable);\n      Object.freeze(this._characterMetrics);\n      Object.freeze(this);\n    }\n  }\n  \n  /**\n   * Get text measurement metrics for a character\n   * @param {string} char - Character (code point) to get metrics for\n   * @returns {Object} TextMetrics-compatible object\n   */\n  getCharacterMetrics(char) {\n    return this._characterMetrics[char];\n  }\n  \n  /**\n   * Get kerning adjustment between two characters\n   * @param {string} leftChar - Left character in pair\n   * @param {string} rightChar - Right character in pair  \n   * @returns {number} Kerning adjustment value (0 if no adjustment)\n   */\n  getKerningAdjustment(leftChar, rightChar) {\n    if (!leftChar || !rightChar) return 0;\n    return this._kerningTable[leftChar]?.[rightChar] || 0;\n  }\n  \n  /**\n   * Check if glyph exists in this font\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if glyph has metrics\n   */\n  hasGlyph(char) {\n    return char in this._characterMetrics;\n  }\n  \n  /**\n   * Get space advancement override for small font sizes\n   * @returns {number|null} Override value in pixels, or null if no override\n   */\n  getSpaceAdvancementOverride() {\n    return this._spaceAdvancementOverride;\n  }\n  \n  /**\n   * Get the complete kerning table (for compatibility/debugging)\n   * @returns {Object} Complete kerning table\n   */\n  getKerningTable() {\n    return this._kerningTable;\n  }\n  \n  /**\n   * Get all available characters in this font\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    return Object.keys(this._characterMetrics);\n  }\n  \n}\n// ============================================================================\n// BitmapText.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/BitmapText.js\n// ============================================================================\n\n// BitmapText - Static Core Runtime Class\n//\n// Status constants are loaded as global variables by StatusCode.js (loaded before this file)\n// In Node.js bundles, StatusCode.js is concatenated before this file\nif (typeof StatusCode === 'undefined' || typeof SUCCESS_STATUS === 'undefined' || typeof createErrorStatus === 'undefined') {\n  throw new Error('StatusCode.js must be loaded before BitmapText.js');\n}\n//\n// This is a STATIC CORE RUNTIME class designed for minimal bundle size and zero-ceremony usage.\n// It provides essential text rendering capabilities for consuming pre-built bitmap fonts.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - All methods are static - no instantiation needed\n// - Contains no font generation code to keep bundle size minimal\n//\n// ARCHITECTURE:\n// - Facade pattern: Delegates storage to AtlasDataStore/FontMetricsStore, font loading to FontLoader\n// - fontDirectory configuration owned by FontLoader (this class delegates get/set)\n// - Auto-detects environment (browser vs Node.js) for canvas creation\n// - Draws text by looking up glyphs from atlases and positioning them with metrics/kerning\n// - Uses textBaseline='bottom' positioning (y = bottom of text bounding box)\n// - Supports placeholder rectangles when atlases are missing but metrics are available\n//\n// CANVAS FACTORY (Node.js only):\n// - Node.js has no DOM, thus no native Canvas\n// - BitmapText needs Canvas to:\n//   1. Load atlas images from files\n//   2. Scan pixels to find tight bounding boxes for each glyph\n//   3. Create tight atlas from scanned data\n// - Cannot pass class reference: HTMLCanvasElement is NOT constructible\n//   (new HTMLCanvasElement() throws \"Illegal constructor\")\n// - Must pass factory function: () => new Canvas()\n// - Browser: via document.createElement('canvas')\n// - Node.js: Must configure with canvas-mock providing Canvas constructor\n//\n// USAGE:\n// - Zero configuration for browser: Just call BitmapText.drawTextFromAtlas()\n// - Node.js: Optionally set canvas factory: BitmapText.setCanvasFactory(() => new Canvas())\n// - Loading: BitmapText.loadFont(idString) or BitmapText.loadFonts([idStrings])\n// - Query: BitmapText.hasFont(idString), BitmapText.getLoadedFonts()\n//\nclass BitmapText {\n  // ============================================\n  // Static Constants\n  // ============================================\n\n  // Kerning unit divisor (kerning measured in 1/1000 em units)\n  static KERNING_UNIT_DIVISOR = 1000;\n\n  // Font asset naming conventions\n  static METRICS_PREFIX = 'metrics-';\n  static ATLAS_PREFIX = 'atlas-';\n  static WEBP_EXTENSION = '.webp';\n  static QOI_EXTENSION = '.qoi';\n  static JS_EXTENSION = '.js';\n\n  // Default text color (matches TextProperties default)\n  static #DEFAULT_TEXT_COLOR = '#000000';\n\n  // Character set constant (204 characters)\n  // Used by both build-time (MetricsMinifier) and runtime (MetricsExpander)\n  // This is the sorted character set that defines the standard order for all font metrics.\n  // ALL font files must contain exactly these 204 characters in this order.\n  static CHARACTER_SET = BitmapText.#generateCharacterSet();\n\n  // ============================================\n  // Static Storage & Configuration\n  // ============================================\n\n  // Font data storage delegated to AtlasDataStore and FontMetricsStore\n  // (no private maps - stores are the single source of truth)\n\n  // Configuration (user overrides, delegates to FontLoader for defaults)\n  // fontDirectory is owned by FontLoader (it's the component that uses it)\n  static #canvasFactory = (typeof document !== 'undefined' ? () => document.createElement('canvas') : null);         // Optional user override\n\n  // Rendering resources (lazy-initialized on first render)\n  static #coloredGlyphCanvas = null;    // Shared scratch canvas for coloring\n  static #coloredGlyphCtx = null;       // 2D context for scratch canvas\n\n  // Font loader (platform-specific, set at runtime)\n  static #fontLoader = null;            // FontLoaderBrowser or FontLoaderNode\n\n  // ============================================\n  // Configuration API (Optional)\n  // ============================================\n\n  /**\n   * Set font directory (overrides default)\n   * Delegates to FontLoader which owns this configuration\n   * @param {string} path - Path to font assets directory\n   */\n  static setFontDirectory(path) {\n    BitmapText.#ensureFontLoader();\n    BitmapText.#fontLoader.setFontDirectory(path);\n  }\n\n  /**\n   * Get font directory (returns override or default)\n   * Delegates to FontLoader which owns this configuration\n   * @returns {string} Font directory path\n   */\n  static getFontDirectory() {\n    BitmapText.#ensureFontLoader();\n    return BitmapText.#fontLoader.getFontDirectory();\n  }\n\n  /**\n   * Override canvas factory (Node.js only, testing, or custom canvas implementations)\n   *\n   * WHY A FACTORY FUNCTION?\n   * HTMLCanvasElement is not constructible in JavaScript - new HTMLCanvasElement()\n   * throws \"Illegal constructor\". Browser uses document.createElement('canvas'),\n   * Node.js requires canvas-mock providing Canvas constructor.\n   *\n   * @param {Function} factory - Function that returns a canvas instance\n   * @example\n   * // Node.js\n   * BitmapText.setCanvasFactory(() => new Canvas());\n   *\n   * // Browser (custom implementation)\n   * BitmapText.setCanvasFactory(() => new OffscreenCanvas(0, 0));\n   */\n  static setCanvasFactory(factory) {\n    BitmapText.#canvasFactory = factory;\n    // Reset canvas to use new factory on next render\n    BitmapText.#coloredGlyphCanvas = null;\n    BitmapText.#coloredGlyphCtx = null;\n  }\n\n  /**\n   * Get canvas factory (with fallback to platform default)\n   *\n   * USAGE PATTERN:\n   * const canvas = BitmapText.getCanvasFactory()();  // Note double invocation\n   *   - First ():  Gets the factory function\n   *   - Second (): Invokes factory to create canvas\n   *\n   * @returns {Function} Canvas factory function\n   */\n  static getCanvasFactory() {\n    return BitmapText.#canvasFactory;\n  }\n\n  /**\n   * Configure multiple options at once\n   * @param {Object} options - Configuration options\n   * @param {string} [options.fontDirectory] - Font assets directory\n   * @param {Function} [options.canvasFactory] - Canvas factory function\n   */\n  static configure(options = {}) {\n    if (options.fontDirectory !== undefined) {\n      BitmapText.setFontDirectory(options.fontDirectory);\n    }\n    if (options.canvasFactory !== undefined) {\n      BitmapText.setCanvasFactory(options.canvasFactory);\n    }\n  }\n\n  /**\n   * Ensure font loader is initialized\n   * @private\n   */\n  static #ensureFontLoader() {\n    if (BitmapText.#fontLoader) {\n      return;\n    }\n\n    // Check if platform-specific FontLoader is available\n    if (typeof FontLoader === 'undefined') {\n      throw new Error(\n        'BitmapText: FontLoader not loaded.\\n' +\n        'Ensure platform-specific FontLoader is included before BitmapText.js:\\n' +\n        '  - Browser: <script src=\"src/platform/FontLoader-browser.js\"></script>\\n' +\n        '  - Node.js: Include src/platform/FontLoader-node.js in bundle'\n      );\n    }\n\n    BitmapText.#fontLoader = FontLoader;\n  }\n\n  // ============================================\n  // Registration API (called by asset files)\n  // ============================================\n\n  /**\n   * Convert registration parameters to ID string\n   * Shared helper for registerMetrics and registerAtlas\n   * @private\n   * @param {number} density - Pixel density\n   * @param {string} fontFamily - Font family name\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric)\n   * @param {number} size - Font size\n   * @returns {string} ID string (e.g., \"density-1-0-Arial-style-normal-weight-normal-size-19-0\")\n   */\n  static #parametersToIDString(density, fontFamily, styleIdx, weightIdx, size) {\n    // Decompress style and weight indices\n    const style = styleIdx === 0 ? 'normal' : (styleIdx === 1 ? 'italic' : 'oblique');\n    const weight = weightIdx === 0 ? 'normal' : (weightIdx === 1 ? 'bold' : String(weightIdx));\n\n    // Format density (1 → 1-0, 1.5 → 1-5)\n    const densityStr = String(density);\n    const densityFormatted = densityStr.includes('.') ? densityStr.replace('.', '-') : `${densityStr}-0`;\n\n    // Format size (18 → 18-0, 18.5 → 18-5)\n    const sizeStr = String(size);\n    const sizeFormatted = sizeStr.includes('.') ? sizeStr.replace('.', '-') : `${sizeStr}-0`;\n\n    // Reconstruct full ID\n    return `density-${densityFormatted}-${fontFamily}-style-${style}-weight-${weight}-size-${sizeFormatted}`;\n  }\n\n  /**\n   * Register font metrics from metrics-*.js file\n   * TIER 6c: Multi-parameter format only (no legacy support)\n   *\n   * @param {number} density - Pixel density (e.g., 1 or 1.5)\n   * @param {string} fontFamily - Font family name (e.g., 'Arial')\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric weight)\n   * @param {number} size - Font size (e.g., 18 or 18.5)\n   * @param {Array} compactedData - Tier 6c compacted metrics array\n   */\n  static registerMetrics(density, fontFamily, styleIdx, weightIdx, size, compactedData) {\n    BitmapText.#ensureFontLoader();\n    const fullIDString = BitmapText.#parametersToIDString(density, fontFamily, styleIdx, weightIdx, size);\n    FontLoaderBase.registerMetrics(fullIDString, compactedData, BitmapText);\n  }\n\n  /**\n   * Register atlas from atlas-*.js file (base64 only, positioning reconstructed later)\n   * Delegates to FontLoader which handles platform-specific details\n   * @param {number} density - Pixel density (e.g., 1 or 1.5)\n   * @param {string} fontFamily - Font family name (e.g., 'Arial')\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric weight)\n   * @param {number} size - Font size (e.g., 18 or 18.5)\n   * @param {string} base64Data - Base64-encoded atlas data\n   */\n  static registerAtlas(density, fontFamily, styleIdx, weightIdx, size, base64Data) {\n    BitmapText.#ensureFontLoader();\n    const fullIDString = BitmapText.#parametersToIDString(density, fontFamily, styleIdx, weightIdx, size);\n    FontLoaderBase.registerAtlas(fullIDString, base64Data);\n  }\n\n  // ============================================\n  // Rendering API\n  // ============================================\n\n  /**\n   * Measure text dimensions\n   *\n   * RETURN VALUES: All measurements are in CSS PIXELS\n   * - width, actualBoundingBox* values are CSS pixels\n   * - Measurements are independent of canvas setup or context transforms\n   * - To convert to physical pixels: multiply by fontProperties.pixelDensity\n   *\n   * NOTE: This method does NOT draw anything and is NOT affected by context transforms.\n   * It purely calculates metrics based on font data.\n   *\n   * The metrics object has the same shape and meaning as the TextMetrics object (see\n   * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics ):\n   * - width: sum of character advancements (minus kerning adjustments)\n   * - actualBoundingBoxLeft: actualBoundingBoxLeft of first character\n   * - actualBoundingBoxRight: sum of advancements (excluding last) + last char's actualBoundingBoxRight\n   *\n   * @param {string} text - Text to measure\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {TextProperties} [textProperties] - Text rendering configuration (optional)\n   * @returns {{metrics: {width: number, actualBoundingBoxLeft: number, actualBoundingBoxRight: number, actualBoundingBoxAscent: number, actualBoundingBoxDescent: number, fontBoundingBoxAscent: number, fontBoundingBoxDescent: number}|null, status: {code: number, missingChars?: Set}}}\n   *   All numeric values in metrics are CSS pixels\n   */\n  static measureText(text, fontProperties, textProperties) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n\n    // FAST PATH: Handle empty text (100% success)\n    if (text.length === 0) {\n      return {\n        metrics: {\n          width: 0,\n          actualBoundingBoxLeft: 0,\n          actualBoundingBoxRight: 0,\n          actualBoundingBoxAscent: 0,\n          actualBoundingBoxDescent: 0,\n          fontBoundingBoxAscent: 0,\n          fontBoundingBoxDescent: 0\n        },\n        status: SUCCESS_STATUS\n      };\n    }\n\n    // Check if FontMetrics exists at all\n    const fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n    if (!fontMetrics) {\n      return {\n        metrics: null,\n        status: createErrorStatus(StatusCode.NO_METRICS)\n      };\n    }\n\n    // Scan text for missing glyphs (excluding spaces which are handled specially)\n    const missingChars = new Set();\n    for (const char of text) {\n      if (char !== ' ' && !fontMetrics.hasGlyph(char)) {\n        missingChars.add(char);\n      }\n    }\n\n    // If any glyphs missing, can't calculate accurate metrics\n    if (missingChars.size > 0) {\n      return {\n        metrics: null,\n        status: createErrorStatus(StatusCode.PARTIAL_METRICS, {\n          missingChars: missingChars\n        })\n      };\n    }\n\n    // SUCCESS PATH: Calculate metrics normally\n    const chars = [...text];\n    let width_CssPx = 0;\n    let characterMetrics = fontMetrics.getCharacterMetrics(chars[0]);\n    const actualBoundingBoxLeft_CssPx = characterMetrics.actualBoundingBoxLeft;\n    let actualBoundingBoxAscent = 0;\n    let actualBoundingBoxDescent = 0;\n    let actualBoundingBoxRight_CssPx;\n    let advancement_CssPx = 0;\n\n    for (let i = 0; i < chars.length; i++) {\n      const char = chars[i];\n      const nextChar = chars[i + 1];\n\n      characterMetrics = fontMetrics.getCharacterMetrics(char);\n\n      actualBoundingBoxAscent = Math.max(actualBoundingBoxAscent, characterMetrics.actualBoundingBoxAscent);\n      actualBoundingBoxDescent = Math.min(actualBoundingBoxDescent, characterMetrics.actualBoundingBoxDescent);\n\n      advancement_CssPx = this.calculateAdvancement_CssPx(fontMetrics, fontProperties, char, nextChar, textProperties, characterMetrics);\n      width_CssPx += advancement_CssPx;\n    }\n\n    actualBoundingBoxRight_CssPx = width_CssPx - advancement_CssPx;\n    actualBoundingBoxRight_CssPx += characterMetrics.actualBoundingBoxRight;\n\n    return {\n      metrics: {\n        width: width_CssPx,\n        actualBoundingBoxLeft: actualBoundingBoxLeft_CssPx,\n        actualBoundingBoxRight: actualBoundingBoxRight_CssPx,\n        actualBoundingBoxAscent,\n        actualBoundingBoxDescent,\n        fontBoundingBoxAscent: characterMetrics.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: characterMetrics.fontBoundingBoxDescent\n      },\n      status: SUCCESS_STATUS\n    };\n  }\n\n  /**\n   * Draw text using pre-rendered glyphs from atlas\n   *\n   * COORDINATE SYSTEM:\n   * - All coordinates are in CSS PIXELS relative to canvas origin (0,0)\n   * - BitmapText IGNORES all context transforms (scale, translate, rotate, etc.)\n   * - Internal conversion: physicalPixels = cssPixels × fontProperties.pixelDensity\n   * - Transform is reset to identity during rendering, then restored\n   *\n   * TRANSFORM BEHAVIOR:\n   * BitmapText will reset the context transform to identity before drawing,\n   * meaning any ctx.scale(), ctx.translate(), ctx.rotate(), etc. are IGNORED.\n   * This ensures pixel-perfect rendering at exact physical pixel positions.\n   *\n   * Example:\n   *   ctx.scale(2, 2);          // User scales context\n   *   ctx.translate(100, 50);    // User translates\n   *   BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 30, fontProps);\n   *   // Text renders at (10, 30) CSS pixels from origin, NOT (120, 80)!\n   *   // Transforms are ignored - coordinates are always absolute\n   *\n   * PIXEL DENSITY:\n   * - Specified via fontProperties.pixelDensity (e.g., window.devicePixelRatio)\n   * - Canvas should be sized: canvas.width = cssWidth × pixelDensity\n   * - Do NOT use ctx.scale(dpr, dpr) - BitmapText handles density internally\n   *\n   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context (transform will be temporarily reset)\n   * @param {string} text - Text to render\n   * @param {number} x_CssPx - X position in CSS pixels (absolute, from canvas origin)\n   * @param {number} y_CssPx - Y position in CSS pixels (absolute, from canvas origin, bottom baseline)\n   * @param {FontProperties} fontProperties - Font configuration (including pixelDensity)\n   * @param {TextProperties} [textProperties] - Text rendering configuration (optional)\n   * @returns {{rendered: boolean, status: {code: number, missingChars?: Set, missingAtlasChars?: Set, placeholdersUsed?: boolean}}}\n   *   Rendering result and status information\n   */\n  static drawTextFromAtlas(ctx, text, x_CssPx, y_CssPx, fontProperties, textProperties = null) {\n    textProperties = textProperties || new TextProperties();\n\n    // Lazy-initialize canvas on first render\n    if (!BitmapText.#coloredGlyphCanvas) {\n      // Explicit factory invocation: get factory, then call it\n      BitmapText.#coloredGlyphCanvas = BitmapText.getCanvasFactory()();\n      BitmapText.#coloredGlyphCtx = BitmapText.#coloredGlyphCanvas.getContext('2d');\n    }\n\n    // Check FontMetrics availability first\n    const fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n    if (!fontMetrics) {\n      return {\n        rendered: false,\n        status: createErrorStatus(StatusCode.NO_METRICS)\n      };\n    }\n\n    // Scan for missing metrics (can't render without metrics)\n    const missingMetricsChars = new Set();\n    for (const char of text) {\n      if (char !== ' ' && !fontMetrics.hasGlyph(char)) {\n        missingMetricsChars.add(char);\n      }\n    }\n\n    if (missingMetricsChars.size > 0) {\n      return {\n        rendered: false,\n        status: createErrorStatus(StatusCode.PARTIAL_METRICS, {\n          missingChars: missingMetricsChars\n        })\n      };\n    }\n\n    // Check atlas data availability\n    const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n    const atlasValid = BitmapText.#isValidAtlas(atlasData);\n\n    // Track which glyphs are missing from atlas (for partial atlas status)\n    const missingAtlasChars = new Set();\n    let placeholdersUsed = false;\n\n    // CRITICAL: Reset transform to identity for pixel-perfect physical rendering\n    // BitmapText ignores ALL context transforms (scale, translate, rotate, etc.)\n    // Coordinates are ALWAYS relative to canvas origin (0,0)\n    // This ensures:\n    // 1. Predictable positioning regardless of context state\n    // 2. Pixel-perfect rendering at physical pixel boundaries\n    // 3. No double-scaling when users apply ctx.scale(dpr, dpr)\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);  // Reset to identity matrix\n\n    // Render text\n    const chars = [...text];\n    const textColor = textProperties.textColor;\n\n    // BASELINE SUPPORT: Convert user's y from their chosen baseline to 'bottom' baseline\n    // Get baseline data from first character (baseline values are identical for all characters in a font)\n    // Use first actual character, or fallback to space character for baseline calculation\n    const firstChar = chars.find(c => fontMetrics.hasGlyph(c)) || chars[0];\n    const characterMetricsForBaseline = fontMetrics.getCharacterMetrics(firstChar);\n    const baselineOffset_CssPx = characterMetricsForBaseline\n      ? BitmapText.#calculateBaselineOffsetToBottom(textProperties.textBaseline, characterMetricsForBaseline)\n      : 0;\n\n    // ALIGNMENT SUPPORT: Convert user's x from their chosen alignment to 'left' alignment\n    // Measure text width to calculate alignment offset (measureText accounts for kerning if enabled)\n    let alignmentOffset_CssPx = 0;\n    if (textProperties.textAlign !== 'left') {\n      const measureResult = BitmapText.measureText(text, fontProperties, textProperties);\n      if (measureResult.status.code === 0 && measureResult.metrics) {\n        // Successfully measured text - calculate alignment offset\n        alignmentOffset_CssPx = BitmapText.#calculateAlignmentOffsetToLeft(\n          textProperties.textAlign,\n          measureResult.metrics.width\n        );\n      } else {\n        // Failed to measure (missing glyphs, etc.) - default to left alignment (offset = 0)\n        // Text will still render but won't be aligned as requested\n        console.warn(`BitmapText: Failed to measure text for alignment '${textProperties.textAlign}', defaulting to left alignment`);\n      }\n    }\n\n    // Apply baseline and alignment offsets, then convert to physical pixels\n    const position_PhysPx = {\n      x: (x_CssPx + alignmentOffset_CssPx) * fontProperties.pixelDensity,\n      y: (y_CssPx + baselineOffset_CssPx) * fontProperties.pixelDensity\n    };\n\n    for (let i = 0; i < chars.length; i++) {\n      const currentChar = chars[i];\n      const nextChar = chars[i + 1];\n\n      // Check if atlas has a glyph for this character (excluding spaces)\n      if (currentChar !== ' ') {\n        if (!atlasValid || !atlasData.hasPositioning(currentChar)) {\n          missingAtlasChars.add(currentChar);\n          placeholdersUsed = true;\n        }\n      }\n\n      // Draw (either real glyph or placeholder)\n      BitmapText.#drawCharacter(ctx,\n        currentChar,\n        position_PhysPx,\n        atlasData,\n        fontMetrics,\n        textColor\n      );\n\n      position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties);\n    }\n\n    // Determine status code\n    let statusCode;\n    if (!atlasValid) {\n      statusCode = StatusCode.NO_ATLAS;\n    } else if (missingAtlasChars.size > 0) {\n      statusCode = StatusCode.PARTIAL_ATLAS;\n    } else {\n      // Complete success\n      ctx.restore();  // Restore original transform\n      return {\n        rendered: true,\n        status: SUCCESS_STATUS\n      };\n    }\n\n    // Return detailed status for non-success cases\n    ctx.restore();  // Restore original transform\n    return {\n      rendered: true,\n      status: createErrorStatus(statusCode, {\n        missingAtlasChars: missingAtlasChars.size > 0 ? missingAtlasChars : undefined,\n        placeholdersUsed: placeholdersUsed\n      })\n    };\n  }\n\n  // ============================================\n  // Internal Rendering Helpers\n  // ============================================\n  // Get the advancement of the i-th character i.e. needed AFTER the i-th character\n  // so that the i+1-th character is drawn at the right place\n  // This depends on both the advancement specified by the glyph of the i-th character\n  // AND by the kerning correction depending on the pair of the i-th and i+1-th characters\n\n  static calculateAdvancement_CssPx(fontMetrics, fontProperties, char, nextChar, textProperties, characterMetrics = null) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n    if (!characterMetrics) {\n      characterMetrics = fontMetrics.getCharacterMetrics(char);\n    }\n    let x_CssPx = 0;\n\n    // LIMITATION: Only handles standard space (U+0020), not other Unicode space characters\n\n    // Handle space first ------------------------------------------\n    // You could add the space advancement as we got it from the browser\n    // (remember that the space doesn't have the tightCanvasBox)\n    // but since at small sizes we meddle with kerning quite a bit, we want\n    // to also meddle with this to try to make the width of text\n    // similar to what the browser paints normally.\n    // console.log(characterMetrics.width + \" \" + x_CSS_Px);\n    // deal with the size of the \" \" character\n    if (char === \" \") {\n      const spaceAdvancementOverrideForSmallSizesInPx_CssPx = fontMetrics.getSpaceAdvancementOverride();\n      if (spaceAdvancementOverrideForSmallSizesInPx_CssPx !== null) {\n        x_CssPx += spaceAdvancementOverrideForSmallSizesInPx_CssPx;\n      }\n      else {\n        x_CssPx += characterMetrics.width;\n      }\n    }\n    // Non-space characters\n    else {\n      x_CssPx += characterMetrics.width;\n    }\n\n    // Apply kerning correction\n    let kerningCorrection = BitmapText.#getKerningCorrection(fontMetrics, char, nextChar, textProperties);\n\n    // Kerning adjustments are measured in 1/1000 em units (font-size relative).\n    // We convert to pixels by multiplying font size by the kerning correction\n    // and dividing by 1000. This keeps kerning proportional to font size while\n    // maintaining precision in the stored kerning values.\n    x_CssPx -= fontProperties.fontSize * kerningCorrection / BitmapText.KERNING_UNIT_DIVISOR;\n\n    // since we might want to actually _place_ a glyph,\n    // following this measurement, we want to return an\n    // integer coordinate here\n    return Math.round(x_CssPx);\n  }\n\n  static #getKerningCorrection(fontMetrics, char, nextChar, textProperties) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n\n    if (textProperties.isKerningEnabled && nextChar) {\n      return fontMetrics.getKerningAdjustment(char, nextChar);\n    }\n\n    return 0;\n  }\n\n  /**\n   * Calculate y-offset to convert from specified textBaseline to 'bottom' baseline\n   *\n   * INTERNAL REFERENCE: BitmapText uses 'bottom' baseline for all dy calculations.\n   * All glyph dy offsets are pre-calculated assuming y is at the bottom of the em square.\n   * This method converts user's chosen baseline to that internal reference.\n   *\n   * COORDINATE SYSTEM: y increases downward (Canvas convention)\n   * All baseline distances are in CSS pixels and relative to alphabetic baseline (ab = 0)\n   *\n   * BASELINE GEOMETRY:\n   * - top: At fontBoundingBoxAscent above alphabetic\n   * - hanging: At hangingBaseline above alphabetic (Tibetan, Devanagari)\n   * - middle: At (fontBoundingBoxAscent - fontBoundingBoxDescent) / 2 above alphabetic\n   * - alphabetic: At 0 (reference point for Latin scripts)\n   * - ideographic: At ideographicBaseline below alphabetic (CJK scripts, negative value)\n   * - bottom: At fontBoundingBoxDescent below alphabetic\n   *\n   * @private\n   * @param {string} textBaseline - User's chosen baseline ('top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom')\n   * @param {Object} characterMetrics - Metrics containing baseline data (fba, fbd, hb, ab, ib)\n   * @returns {number} Offset in CSS pixels to add to y coordinate to reach 'bottom' baseline\n   */\n  static #calculateBaselineOffsetToBottom(textBaseline, characterMetrics) {\n    // Extract baseline measurements from character metrics\n    // These values are captured from browser's TextMetrics during font generation\n    const fba = characterMetrics.fontBoundingBoxAscent;    // Distance from alphabetic to top of em square (positive)\n    const fbd = characterMetrics.fontBoundingBoxDescent;   // Distance from alphabetic to bottom of em square (positive, downward)\n    const hb = characterMetrics.hangingBaseline;           // Distance from alphabetic to hanging baseline (positive, upward)\n    const ib = characterMetrics.ideographicBaseline;       // Distance from alphabetic to ideographic baseline (negative, downward)\n\n    // Convert from user's baseline to bottom baseline\n    // Formulas derived from geometric relationships in em square coordinate system\n    switch (textBaseline) {\n      case 'top':\n        // Top of em square → Bottom of em square\n        // Move down by full em height: ascent + descent\n        return fba + fbd;\n\n      case 'hanging':\n        // Hanging baseline → Bottom of em square\n        // Hanging is hb above alphabetic, bottom is fbd below alphabetic\n        // Total distance: hb (up to alphabetic) + fbd (down to bottom)\n        return hb + fbd;\n\n      case 'middle':\n        // Middle of em square → Bottom of em square\n        // Middle is halfway between top and bottom\n        // Distance from middle to bottom: (ascent + descent) / 2\n        return (fba + fbd) / 2;\n\n      case 'alphabetic':\n        // Alphabetic baseline → Bottom of em square\n        // Alphabetic is fbd above bottom (standard for Latin text)\n        return fbd;\n\n      case 'ideographic':\n        // Ideographic baseline → Bottom of em square\n        // Ideographic is ib pixels relative to alphabetic (negative = below alphabetic)\n        // Distance from ideographic to bottom: fbd + ib\n        // Example: if fbd=4 and ib=-4.0264, offset = 4 + (-4.0264) = -0.0264\n        // This small negative offset places ideographic just above bottom, matching native Canvas\n        return fbd + ib;\n\n      case 'bottom':\n        // Already at bottom baseline - no offset needed\n        return 0;\n\n      default:\n        // Unknown baseline value - warn and default to bottom\n        console.warn(`BitmapText: Unknown textBaseline '${textBaseline}', defaulting to 'bottom'. Valid values: top, hanging, middle, alphabetic, ideographic, bottom`);\n        return 0;\n    }\n  }\n\n  /**\n   * Calculate x-offset to convert from specified textAlign to 'left' alignment\n   *\n   * INTERNAL REFERENCE: BitmapText uses 'left' alignment for internal rendering.\n   * All text rendering starts from the x-coordinate and advances rightward.\n   * This method converts user's chosen alignment to that internal reference.\n   *\n   * COORDINATE SYSTEM: x increases rightward (Canvas convention)\n   * All measurements are in CSS pixels\n   *\n   * ALIGNMENT GEOMETRY:\n   * - left: x marks the start of the text (no offset needed)\n   * - center: x marks the center of the text (offset by -width/2)\n   * - right: x marks the end of the text (offset by -width)\n   *\n   * @private\n   * @param {string} textAlign - User's chosen alignment ('left', 'center', 'right')\n   * @param {number} textWidth_CssPx - Total width of the text in CSS pixels\n   * @returns {number} Offset in CSS pixels to add to x coordinate to reach 'left' alignment\n   */\n  static #calculateAlignmentOffsetToLeft(textAlign, textWidth_CssPx) {\n    // Convert from user's alignment to left alignment (internal reference)\n    switch (textAlign) {\n      case 'left':\n        // Already at left alignment - no offset needed\n        return 0;\n\n      case 'center':\n        // Center alignment → Left alignment\n        // Text is centered at x, need to shift left by half width to get start position\n        return -textWidth_CssPx / 2;\n\n      case 'right':\n        // Right alignment → Left alignment\n        // Text ends at x, need to shift left by full width to get start position\n        return -textWidth_CssPx;\n\n      default:\n        // Unknown alignment value - warn and default to left\n        console.warn(`BitmapText: Unknown textAlign '${textAlign}', defaulting to 'left'. Valid values: left, center, right`);\n        return 0;\n    }\n  }\n\n  // Rendering optimizations:\n  // 1. ✓ IMPLEMENTED: Black text fast path (see #drawCharacterDirect for 2-3x speedup)\n  // 2. FUTURE: Cache colored glyphs in LRU cache to avoid re-coloring same characters\n  // 3. FUTURE: Batch coloring (color unique glyphs once, then blit all)\n  static #drawCharacter(ctx, char, position_PhysPx, atlasData, fontMetrics, textColor) {\n    // If atlasData is missing but metrics exist, draw simplified placeholder rectangle\n    if (!BitmapText.#isValidAtlas(atlasData)) {\n      const characterMetrics = fontMetrics.getCharacterMetrics(char);\n      if (characterMetrics) {\n        BitmapText.#drawPlaceholderRectangle(ctx, char, position_PhysPx, characterMetrics, textColor);\n      }\n      return;\n    }\n\n    // FAST PATH: Black text renders directly from atlas (2-3x faster)\n    // Skips scratch canvas + composite operations when using default color\n    if (textColor === BitmapText.#DEFAULT_TEXT_COLOR) {\n      BitmapText.#drawCharacterDirect(ctx, char, position_PhysPx, atlasData, fontMetrics);\n      return;\n    }\n\n    // SLOW PATH: Colored text requires double-pass rendering\n    // 1. Copy glyph from atlas to scratch canvas\n    // 2. Apply color using composite operation\n    // 3. Draw colored glyph to main canvas\n    if (!atlasData.hasPositioning(char)) return;\n\n    const atlasPositioning = atlasData.atlasPositioning.getPositioning(char);\n    const atlasImage = atlasData.atlasImage.image;\n    const coloredGlyphCanvas = BitmapText.#createColoredGlyph(atlasImage, atlasPositioning, textColor);\n    BitmapText.#renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position_PhysPx, atlasPositioning);\n  }\n\n  static #createColoredGlyph(atlasImage, atlasPositioning, textColor) {\n    const { xInAtlas, tightWidth, tightHeight } = atlasPositioning;\n\n    // Setup temporary canvas, same size as the glyph\n    BitmapText.#coloredGlyphCanvas.width = tightWidth;\n    BitmapText.#coloredGlyphCanvas.height = tightHeight;\n    BitmapText.#coloredGlyphCtx.clearRect(0, 0, tightWidth, tightHeight);\n\n    // Draw original glyph\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-over';\n    BitmapText.#coloredGlyphCtx.drawImage(\n      atlasImage,\n      xInAtlas, 0,\n      tightWidth, tightHeight,\n      0, 0,\n      tightWidth, tightHeight\n    );\n\n    // Apply color\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-in';\n    BitmapText.#coloredGlyphCtx.fillStyle = textColor;\n    BitmapText.#coloredGlyphCtx.fillRect(0, 0, tightWidth, tightHeight);\n\n    return BitmapText.#coloredGlyphCanvas;\n  }\n\n  static #renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position_PhysPx, atlasPositioning) {\n    const { tightWidth, tightHeight, dx, dy } = atlasPositioning;\n\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    // see https://stackoverflow.com/a/6061102\n    ctx.drawImage(\n      coloredGlyphCanvas,\n      0, 0,\n      tightWidth, tightHeight,\n      Math.round(position_PhysPx.x + dx),\n      Math.round(position_PhysPx.y + dy),\n      tightWidth, tightHeight\n    );\n  }\n\n  /**\n   * Fast path: Draw character directly from atlas (black text only)\n   * Skips scratch canvas and color composite operations for 2-3x faster rendering\n   * @private\n   */\n  static #drawCharacterDirect(ctx, char, position_PhysPx, atlasData, fontMetrics) {\n    if (!atlasData.hasPositioning(char)) return;\n\n    const atlasPositioning = atlasData.atlasPositioning.getPositioning(char);\n    const atlasImage = atlasData.atlasImage.image;\n    const { xInAtlas, tightWidth, tightHeight, dx, dy } = atlasPositioning;\n\n    // Single drawImage operation: atlas → main canvas\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    ctx.drawImage(\n      atlasImage,\n      xInAtlas, 0,\n      tightWidth, tightHeight,\n      Math.round(position_PhysPx.x + dx),\n      Math.round(position_PhysPx.y + dy),\n      tightWidth, tightHeight\n    );\n  }\n\n  static #drawPlaceholderRectangle(ctx, char, position_PhysPx, characterMetrics, textColor) {\n    if (char === ' ') return;\n\n    if (characterMetrics.actualBoundingBoxLeft === undefined ||\n        characterMetrics.actualBoundingBoxRight === undefined ||\n        characterMetrics.actualBoundingBoxAscent === undefined ||\n        characterMetrics.actualBoundingBoxDescent === undefined) {\n      console.warn(`Missing bounding box metrics for character '${char}'`);\n      return;\n    }\n\n    const pixelDensity = characterMetrics.pixelDensity || 1;\n\n    // Use CHARACTER-SPECIFIC actual bounding box (not font-wide fontBoundingBox)\n    // This makes:\n    // - 'a' shorter than 'A' (x-height vs cap-height)\n    // - 'g' extends below baseline (shows descender)\n    // - '.' very short (near baseline only)\n    // Width: actualBoundingBoxLeft + actualBoundingBoxRight (CSS px) * pixelDensity → physical px\n    // Height: actualBoundingBoxAscent + actualBoundingBoxDescent (CSS px) * pixelDensity → physical px\n    const width_PhysPx = Math.round(\n      characterMetrics.actualBoundingBoxLeft + characterMetrics.actualBoundingBoxRight\n    ) * pixelDensity;\n\n\n    const height_PhysPx = Math.round(\n      characterMetrics.actualBoundingBoxAscent + characterMetrics.actualBoundingBoxDescent\n    ) * pixelDensity;\n\n    // X position: Account for actualBoundingBoxLeft (glyphs may protrude left, e.g., italic 'f')\n    // This matches the dx offset calculation in atlas rendering (AtlasPositioningFAB.js:92)\n    const rectX_PhysPx = position_PhysPx.x\n      - Math.round(characterMetrics.actualBoundingBoxLeft) * pixelDensity;\n\n    // Y position calculation:\n    // - position_PhysPx.y is at em square BOTTOM (textBaseline='bottom')\n    // - Em square bottom is fontBoundingBoxDescent below the alphabetic baseline\n    // - So: alphabetic_baseline_y = position_PhysPx.y - fontBoundingBoxDescent * pixelDensity\n    // - Character top = alphabetic_baseline_y - actualBoundingBoxAscent * pixelDensity\n    // Result: rectY = position_PhysPx.y - fontBoundingBoxDescent * pixelDensity - actualBoundingBoxAscent * pixelDensity\n    const rectY_PhysPx = position_PhysPx.y\n      - characterMetrics.fontBoundingBoxDescent * pixelDensity\n      - characterMetrics.actualBoundingBoxAscent * pixelDensity;\n\n    const actualColor = textColor || 'black';\n\n    // Draw character-specific rectangle\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    ctx.fillStyle = actualColor;\n    ctx.fillRect(\n      Math.round(rectX_PhysPx),\n      Math.round(rectY_PhysPx),\n      Math.round(width_PhysPx),\n      Math.round(height_PhysPx)\n    );\n  }\n\n  static #calculateCharacterAdvancement_PhysPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties) {\n    return this.calculateAdvancement_CssPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties)\n      * fontProperties.pixelDensity;\n  }\n\n  /**\n   * Check if atlas data is valid and ready for rendering\n   * @private\n   * @param {*} atlasData - Potential AtlasData instance\n   * @returns {boolean} True if atlasData is an AtlasData instance and is valid\n   */\n  static #isValidAtlas(atlasData) {\n    if (!(atlasData instanceof AtlasData)) {\n      return false;\n    }\n    return atlasData.isValid();\n  }\n\n  // ============================================\n  // Loading API (Delegates to FontLoader)\n  // ============================================\n\n  /**\n   * Load a single font\n   * @param {string} idString - Font ID string\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @returns {Promise} Resolves when font is loaded\n   */\n  static async loadFont(idString, options = {}) {\n    BitmapText.#ensureFontLoader();\n    return BitmapText.#fontLoader.loadFont(idString, options, BitmapText);\n  }\n\n  /**\n   * Load multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {boolean} [options.loadMetrics] - Load metrics (default: true)\n   * @param {boolean} [options.loadAtlases] - Load atlases (default: true)\n   * @returns {Promise} Resolves when all fonts are loaded\n   */\n  static async loadFonts(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    return BitmapText.#fontLoader.loadFonts(idStrings, options, BitmapText);\n  }\n\n  /**\n   * Load only metrics for fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetrics(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    return BitmapText.#fontLoader.loadMetrics(idStrings, options, BitmapText);\n  }\n\n  /**\n   * Load only atlases for fonts (metrics must be loaded first)\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @returns {Promise} Resolves when atlases are loaded\n   */\n  static async loadAtlases(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    return BitmapText.#fontLoader.loadAtlases(idStrings, options, BitmapText);\n  }\n\n  // ============================================\n  // Builder/Testing Tool API\n  // ============================================\n\n  /**\n   * Set atlas data for a font (for builder/testing tools)\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {AtlasData} atlasData - Atlas data to store\n   */\n  static setAtlasData(fontProperties, atlasData) {\n    AtlasDataStore.setAtlasData(fontProperties, atlasData);\n  }\n\n  /**\n   * Get atlas data for a font\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {AtlasData|undefined} Atlas data or undefined if not found\n   */\n  static getAtlasData(fontProperties) {\n    return AtlasDataStore.getAtlasData(fontProperties);\n  }\n\n  /**\n   * Delete atlas data for a font\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if atlas was deleted\n   */\n  static deleteAtlas(fontProperties) {\n    return AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Set font metrics for a font (for builder/testing tools)\n   * Public API - delegates to FontMetricsStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {FontMetrics} fontMetrics - Font metrics to store\n   */\n  static setFontMetrics(fontProperties, fontMetrics) {\n    FontMetricsStore.setFontMetrics(fontProperties, fontMetrics);\n  }\n\n  /**\n   * Get font metrics for a font\n   * Public API - delegates to FontMetricsStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {FontMetrics|undefined} Font metrics or undefined if not found\n   */\n  static getFontMetrics(fontProperties) {\n    return FontMetricsStore.getFontMetrics(fontProperties);\n  }\n\n  /**\n   * Unload both metrics and atlas for a font\n   * @param {string} idString - Font ID string\n   */\n  static unloadFont(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    FontMetricsStore.deleteFontMetrics(fontProperties);\n    AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Unload multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   */\n  static unloadFonts(idStrings) {\n    idStrings.forEach(id => this.unloadFont(id));\n  }\n\n  /**\n   * Unload metrics (cascades to unload atlas)\n   * @param {string} idString - Font ID string\n   */\n  static unloadMetrics(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    FontMetricsStore.deleteFontMetrics(fontProperties);\n    AtlasDataStore.deleteAtlas(fontProperties); // Cascade: no metrics = no atlas\n  }\n\n  /**\n   * Unload atlas only (keeps metrics)\n   * @param {string} idString - Font ID string\n   */\n  static unloadAtlas(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Unload all fonts (both metrics and atlases)\n   */\n  static unloadAllFonts() {\n    FontMetricsStore.clear();\n    AtlasDataStore.clear();\n  }\n\n  /**\n   * Unload all atlases (keep metrics)\n   */\n  static unloadAllAtlases() {\n    AtlasDataStore.clear();\n  }\n\n  // ============================================\n  // Query API\n  // ============================================\n\n  /**\n   * Check if font is fully loaded (both metrics and atlas)\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if both metrics and atlas are loaded\n   */\n  static hasFont(idString) {\n    return this.hasMetrics(idString) && this.hasAtlas(idString);\n  }\n\n  /**\n   * Check if metrics are loaded for a font\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if metrics are loaded\n   */\n  static hasMetrics(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    return FontMetricsStore.hasFontMetrics(fontProperties);\n  }\n\n  /**\n   * Check if atlas is loaded for a font\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if atlas is loaded\n   */\n  static hasAtlas(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n    return atlasData && BitmapText.#isValidAtlas(atlasData);\n  }\n\n  /**\n   * Get list of fully loaded fonts (both metrics and atlas)\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedFonts() {\n    const loaded = [];\n    for (const key of FontMetricsStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n      if (atlasData && BitmapText.#isValidAtlas(atlasData)) {\n        loaded.push(fontProperties.idString);\n      }\n    }\n    return loaded;\n  }\n\n  /**\n   * Get list of fonts with loaded metrics\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedMetrics() {\n    const loaded = [];\n    for (const key of FontMetricsStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      loaded.push(fontProperties.idString);\n    }\n    return loaded;\n  }\n\n  /**\n   * Get list of fonts with loaded atlases\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedAtlases() {\n    const loaded = [];\n    for (const key of AtlasDataStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n      if (BitmapText.#isValidAtlas(atlasData)) {\n        loaded.push(fontProperties.idString);\n      }\n    }\n    return loaded;\n  }\n\n  // ============================================\n  // Testing Helpers\n  // ============================================\n\n  /**\n   * Reset all state for testing\n   * @private\n   */\n  static __resetForTesting() {\n    FontMetricsStore.clear();\n    AtlasDataStore.clear();\n    // Clear FontLoader state\n    if (FontLoaderBase._loadingPromises) {\n      FontLoaderBase._loadingPromises.clear();\n    }\n    if (FontLoaderBase._tempAtlasPackages) {\n      FontLoaderBase._tempAtlasPackages = {};\n    }\n    if (FontLoaderBase._pendingAtlases) {\n      FontLoaderBase._pendingAtlases.clear();\n    }\n    // Reset FontLoader configuration\n    if (FontLoaderBase.setFontDirectory) {\n      FontLoaderBase.setFontDirectory(null);\n    }\n    BitmapText.#coloredGlyphCanvas = null;\n    BitmapText.#coloredGlyphCtx = null;\n    BitmapText.#canvasFactory = null;\n    BitmapText.#fontLoader = null;\n  }\n\n  // ============================================\n  // Character Set Generation\n  // ============================================\n\n  /**\n   * Generate character set programmatically\n   * Creates a sorted string of 204 characters including:\n   * - ASCII printable (32-126): 95 characters\n   * - Windows-1252 subset (128-159): 14 characters\n   * - Latin-1 Supplement (161-255): 94 characters (excluding soft hyphen)\n   * - Full Block character (█): 1 character\n   * @private\n   * @returns {string} Sorted character set string\n   */\n  static #generateCharacterSet() {\n    const chars = [];\n\n    // ASCII printable characters (32-126)\n    // Includes space, numbers, letters, and common symbols\n    for (let i = 32; i <= 126; i++) {\n      chars.push(String.fromCharCode(i));\n    }\n\n    // A selection from Windows-1252 (CP-1252) printable characters.\n    // This is the most standard definition of \"extended ASCII codes\" from 128 to 159\n    // and many of these are common/useful symbols that people \"expect to have\".\n    // However fromCharCode doesn't work on those as that range is not defined\n    // in UTF-8/Unicode (modern web standard, so we want to include (some of) them but we have\n    // to map them to specific Unicode code points, not the byte values themselves.\n    // NOTE: we could likely shave some of these off, as they are not easily printable\n    // in Javascript and some of them are fairly arcane/\n    const cp1252PrintableChars = [\n      8364, // € Euro sign (CP-1252: 128)\n      //  8218, // ‚ Single low-9 quotation mark (CP-1252: 130)\n      //  402,  // ƒ Latin small letter f with hook (CP-1252: 131)\n      //  8222, // „ Double low-9 quotation mark (CP-1252: 132)\n      8230, // … Horizontal ellipsis (CP-1252: 133)\n      //  8224, // † Dagger (CP-1252: 134)\n      //  8225, // ‡ Double dagger (CP-1252: 135)\n      //  710,  // ˆ Modifier letter circumflex accent (CP-1252: 136)\n      8240, // ‰ Per mille sign (CP-1252: 137)\n      //  352,  // Š Latin capital letter S with caron (CP-1252: 138)\n      8249, // ‹ Single left-pointing angle quotation (CP-1252: 139)\n      //  338,  // Œ Latin capital ligature OE (CP-1252: 140)\n      381,  // Ž Latin capital letter Z with caron (CP-1252: 142)\n      //  8216, // ' Left single quotation mark (CP-1252: 145)\n\n      // UNFORTUNATELY SOMETIMES USED INSTEAD OF APOSTROPHE\n      8217, // ' \"\"curly apostrophe\"\" or \"right single quotation mark\" (CP-1252: 146)\n\n      //  8220, // \" Left double quotation mark (CP-1252: 147)\n      //  8221, // \" Right double quotation mark (CP-1252: 148)\n      8226, // • Bullet (CP-1252: 149)\n      //  8211, // – En dash (CP-1252: 150)\n      8212, // — Em dash (CP-1252: 151)\n      //  732,  // ˜ Small tilde (CP-1252: 152)\n      8482, // ™ Trade mark sign (CP-1252: 153)\n      353,  // š Latin small letter s with caron (CP-1252: 154)\n      8250, // › Single right-pointing angle quotation mark (CP-1252: 155)\n      339,  // œ Latin small ligature oe (CP-1252: 156)\n      382,  // ž Latin small letter z with caron (CP-1252: 158)\n      376   // Ÿ Latin capital letter Y with diaeresis (CP-1252: 159)\n    ];\n\n    for (const code of cp1252PrintableChars) {\n      chars.push(String.fromCharCode(code));\n    }\n\n    // Latin-1 Supplement characters (161-255)\n    // These are properly defined in UTF-8/Unicode\n    // Exclude U+00AD (173) - soft hyphen, which has zero width\n    for (let i = 161; i <= 255; i++) {\n      if (i !== 173) { // Skip soft hyphen\n        chars.push(String.fromCharCode(i));\n      }\n    }\n\n    // Add Full Block character (allows us to see the maximum space taken by a glyph)\n    chars.push('█');\n\n    // Sort the character set (this is how it's used throughout the codebase)\n    return chars.sort().join('');\n  }\n}\n\n// TIER 6b OPTIMIZATION: Short aliases for registration methods (saves ~15 bytes per file)\nBitmapText.r = BitmapText.registerMetrics;\nBitmapText.a = BitmapText.registerAtlas;\n\n// ============================================================================\n// MetricsExpander.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/builder/MetricsExpander.js\n// ============================================================================\n\n// Static utility class for expanding minified font metrics data (runtime only)\n// Converts compact format back to FontMetrics instances for use by the rendering engine\n// NOTE: Requires BitmapText.js to be loaded first (uses BitmapText.CHARACTER_SET)\n\nclass MetricsExpander {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('MetricsExpander cannot be instantiated - use static methods');\n  }\n\n  /**\n   * TIER 6c OPTIMIZATION: Decode base64 string to array of integers\n   * Reverses the base64 byte encoding from MetricsMinifier\n   *\n   * @param {string} base64 - Base64 encoded string\n   * @returns {Array<number>} Array of integers (0-255)\n   */\n  static #decodeFromBase64Bytes(base64) {\n    // In browser: use atob\n    // In Node.js: use Buffer\n    let bytes;\n\n    if (typeof Buffer !== 'undefined') {\n      // Node.js environment\n      bytes = Buffer.from(base64, 'base64');\n    } else {\n      // Browser environment\n      const binary = atob(base64);\n      bytes = new Uint8Array(binary.length);\n      for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n      }\n    }\n\n    return Array.from(bytes);\n  }\n\n  /**\n   * TIER 6c OPTIMIZATION: Decode varint+zigzag+base64 to signed integers\n   * Reverses the VarInt encoding from MetricsMinifier\n   *\n   * @param {string} base64 - Base64 encoded varint bytes\n   * @returns {Array<number>} Array of signed integers\n   */\n  static #decodeVarInts(base64) {\n    const bytes = this.#decodeFromBase64Bytes(base64);\n    const integers = [];\n    let i = 0;\n\n    while (i < bytes.length) {\n      // Decode VarInt: 7 bits per byte, MSB indicates continuation\n      let value = 0;\n      let shift = 0;\n      let byte;\n\n      do {\n        byte = bytes[i++];\n        value |= (byte & 0x7F) << shift;\n        shift += 7;\n      } while (byte & 0x80);\n\n      // Zigzag decoding: convert unsigned back to signed\n      // 0→0, 1→-1, 2→1, 3→-2, 4→2, ...\n      const signed = (value & 1) ? -(value + 1) / 2 : value / 2;\n      integers.push(signed);\n    }\n\n    return integers;\n  }\n\n  /**\n   * TIER 7 OPTIMIZATION: Decompress value lookup array from delta encoding + base64\n   *\n   * Reverses the compression:\n   * 1. Decode base64 → varint → zigzag → deltas\n   * 2. Reconstruct sorted values from deltas\n   * 3. Return as unsorted array (order doesn't matter for lookup)\n   *\n   * @param {string} base64 - Base64 encoded delta-compressed string\n   * @returns {Array<number>} Array of metric value integers\n   */\n  static #decompressValueArray(base64) {\n    // Decode base64 → deltas\n    const deltas = this.#decodeVarInts(base64);\n\n    // Reconstruct sorted values from deltas\n    const sorted = [deltas[0]]; // First value is absolute\n    for (let i = 1; i < deltas.length; i++) {\n      sorted.push(sorted[i - 1] + deltas[i]);\n    }\n\n    // Return as-is (order doesn't matter for value lookup)\n    // The indices in tuplets refer to sorted positions\n    return sorted;\n  }\n\n  /**\n   * Expands minified metrics back to FontMetrics instance for runtime use\n   * TIER 7 FORMAT (backward compatible with Tier 6c)\n   *\n   * @param {Array} minified - Minified metrics array [kv, k, b, v, t, g, s, cl]\n   *   - v can be array (Tier 6c) or base64 string (Tier 7)\n   * @returns {FontMetrics} FontMetrics instance with expanded data\n   * @throws {Error} If invalid format detected\n   */\n  static expand(minified) {\n    // Check if FontMetrics class is available\n    if (typeof FontMetrics === 'undefined') {\n      throw new Error('FontMetrics class not found. Please ensure FontMetrics.js is loaded before MetricsExpander.js');\n    }\n\n    // Validate Tier 6c format: 8-element array only\n    if (!Array.isArray(minified) || minified.length !== 8) {\n      throw new Error(\n        `Invalid format - expected 8-element array (Tier 6c), got ${typeof minified === 'object' ? 'array' : typeof minified} with ${minified?.length || 0} elements.\\n` +\n        `Please regenerate font assets with the current version.`\n      );\n    }\n\n    // Extract values from Tier 6c/7 array format\n    let [kv, k, b, v, t, g, s, cl] = minified;\n\n    // Convert integer values back to floats (divide by 10000)\n    kv = this.#convertIntegersToValues(kv);\n\n    // TIER 7: Handle value lookup array - can be array (Tier 6c) or base64 string (Tier 7)\n    if (typeof v === 'string') {\n      // Tier 7: Decompress from delta-encoded base64\n      v = this.#decompressValueArray(v);\n      v = this.#convertIntegersToValues(v);\n    } else if (Array.isArray(v)) {\n      // Tier 6c: Already an array of integers\n      v = this.#convertIntegersToValues(v);\n    } else {\n      throw new Error('Invalid value lookup format - expected array or string');\n    }\n\n    // Unflatten baseline array to object\n    b = this.#unflattenBaseline(b);\n\n    // Decode base64-encoded binary data\n    // t = VarInt+zigzag encoded flattened tuplets\n    // g = byte-encoded tuplet indices\n    t = this.#decodeVarInts(t);\n    g = this.#decodeFromBase64Bytes(g);\n\n    // Unflatten tuplet data from negative-delimiter format\n    t = this.#unflattenTuplets(t);\n\n    const expandedData = {\n      kerningTable: this.#expandKerningTable(k, kv),\n      characterMetrics: this.#expandCharacterMetrics(g, b, v, t, cl),\n      spaceAdvancementOverrideForSmallSizesInPx: s\n    };\n\n    // Verify pixelDensity was preserved\n    const firstChar = Object.keys(expandedData.characterMetrics)[0];\n    const pixelDensity = expandedData.characterMetrics[firstChar]?.pixelDensity;\n    console.debug(`🔍 MetricsExpander: Restored pixelDensity=${pixelDensity} for ${Object.keys(expandedData.characterMetrics).length} characters`);\n\n    return new FontMetrics(expandedData);\n  }\n  \n  /**\n   * Expands kerning table with range notation support\n   * TIER 3 OPTIMIZATION: Two-dimensional expansion (reverse order of compression)\n   * TIER 4 OPTIMIZATION: Value indexing (looks up actual kerning values from indices)\n   *   Pass 1 (left-side):  {\"A-B\":{\"s\":0}} → {\"A\":{\"s\":0},\"B\":{\"s\":0}}\n   *   Pass 2 (right-side): {\"A\":{\"0-1\":0}} → {\"A\":{\"0\":0,\"1\":0}}\n   *   Pass 3 (values):     {\"A\":{\"s\":0}} → {\"A\":{\"s\":20}} (lookup from kerningValueLookup[0])\n   * Always uses BitmapText.CHARACTER_SET for range expansion\n   * Later entries override earlier ones, allowing exceptions to ranges\n   * @param {Object} minified - Minified kerning table with indexed values\n   * @param {Array} kerningValueLookup - Value lookup table for kerning values\n   * @private\n   */\n  static #expandKerningTable(minified, kerningValueLookup) {\n    // PASS 1: Expand left side (characters that come before)\n    const leftExpanded = this.#expandLeftSide(minified);\n\n    // PASS 2: Expand right side (characters that follow)\n    const rangeExpanded = {};\n    for (const [leftChar, pairs] of Object.entries(leftExpanded)) {\n      rangeExpanded[leftChar] = this.#expandKerningPairs(pairs);\n    }\n\n    // PASS 3 (TIER 4): Replace all indices with actual values from lookup table\n    const expanded = {};\n    for (const [leftChar, pairs] of Object.entries(rangeExpanded)) {\n      expanded[leftChar] = {};\n      for (const [rightChar, index] of Object.entries(pairs)) {\n        expanded[leftChar][rightChar] = kerningValueLookup[index];\n      }\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Expands left side of kerning table (characters that come before)\n   * TIER 3 OPTIMIZATION: Two-dimensional expansion pass 1\n   * Handles left-side range notation like \"A-C\":{\"s\":20} → {\"A\":{\"s\":20},\"B\":{\"s\":20},\"C\":{\"s\":20}}\n   * Always uses BitmapText.CHARACTER_SET for range expansion\n   * @param {Object} minified - Minified kerning table with potential left-side ranges\n   * @returns {Object} Left-expanded kerning table\n   * @private\n   */\n  static #expandLeftSide(minified) {\n    const expanded = {};\n\n    // Process entries in order so later entries can override earlier ones\n    for (const [key, rightSideObj] of Object.entries(minified)) {\n      if (key.includes('-') && key.length >= 3) {\n        // Potential range notation (e.g., \"A-Z\" or \"0-9\")\n        const hyphenIndex = key.indexOf('-');\n        const startChar = key.substring(0, hyphenIndex);\n        const endChar = key.substring(hyphenIndex + 1);\n\n        // Check if both start and end are single characters in the character set\n        if (startChar.length === 1 && endChar.length === 1) {\n          const startIndex = BitmapText.CHARACTER_SET.indexOf(startChar);\n          const endIndex = BitmapText.CHARACTER_SET.indexOf(endChar);\n\n          if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {\n            // Valid range, expand it\n            for (let i = startIndex; i <= endIndex; i++) {\n              expanded[BitmapText.CHARACTER_SET[i]] = rightSideObj;\n            }\n            continue;\n          }\n        }\n      }\n\n      // Not a range, or invalid range - treat as literal character\n      expanded[key] = rightSideObj;\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Expands kerning pairs from compact string notation to individual character pairs\n   * TIER 6b OPTIMIZATION: Handles advanced compact notation with non-sequential grouping\n   *\n   * Parses compact strings like \"-,.:;ac-egj-s\" which means:\n   * - Dash at START is literal\n   * - Individual chars: comma, dot, colon, semicolon\n   * - Ranges: a, c-e (c,d,e), g, j-s (j,k,l,m,n,o,p,q,r,s)\n   *\n   * Always uses BitmapText.CHARACTER_SET for range expansion\n   * @param {Object} pairs - Compressed pairs like {\"-,.:;ac-egj-s\":20}\n   * @returns {Object} Expanded pairs like {\"-\":20,\",\":20,\".\":20,...,\"s\":20}\n   * @private\n   */\n  static #expandKerningPairs(pairs) {\n    const expanded = {};\n\n    // Process entries in order so later entries can override earlier ones\n    for (const [key, value] of Object.entries(pairs)) {\n      // Parse the compact string notation\n      const chars = this.#parseCompactCharString(key);\n\n      // Assign value to all parsed characters\n      for (const char of chars) {\n        expanded[char] = value;\n      }\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Parses compact character string notation\n   * TIER 6b OPTIMIZATION: Handles dash-at-start and range notation\n   *\n   * Format:\n   * - First char is dash → literal dash character\n   * - \"a-z\" → range from a to z\n   * - \"abc\" → individual characters a, b, c\n   * - \"-,.:;ac-egj-s\" → dash, comma, dot, colon, semicolon, a, c-e range, g, j-s range\n   *\n   * @param {string} compactStr - Compact string like \"-,.:;ac-egj-s\"\n   * @returns {string[]} Array of individual characters\n   * @private\n   */\n  static #parseCompactCharString(compactStr) {\n    const chars = [];\n    let i = 0;\n\n    // Handle dash at start (literal)\n    if (compactStr[0] === '-') {\n      chars.push('-');\n      i = 1;\n    }\n\n    // Parse rest of string\n    while (i < compactStr.length) {\n      const currentChar = compactStr[i];\n\n      // Check if this is the start of a range pattern\n      if (i + 2 < compactStr.length && compactStr[i + 1] === '-') {\n        // Pattern: \"X-Y\" where X and Y are single characters\n        const startChar = currentChar;\n        const endChar = compactStr[i + 2];\n\n        // Verify it's a valid range in BitmapText.CHARACTER_SET\n        const startIndex = BitmapText.CHARACTER_SET.indexOf(startChar);\n        const endIndex = BitmapText.CHARACTER_SET.indexOf(endChar);\n\n        if (startIndex !== -1 && endIndex !== -1 && startIndex < endIndex) {\n          // Valid range - expand it\n          for (let j = startIndex; j <= endIndex; j++) {\n            chars.push(BitmapText.CHARACTER_SET[j]);\n          }\n          i += 3; // Skip X, -, Y\n        } else {\n          // Not a valid range - treat as individual characters\n          chars.push(currentChar);\n          i++;\n        }\n      } else {\n        // Individual character\n        chars.push(currentChar);\n        i++;\n      }\n    }\n\n    return chars;\n  }\n  \n  /**\n   * Expands glyph metrics from arrays back to full objects\n   * TIER 2 OPTIMIZATION: Reconstructs from array of arrays using BitmapText.CHARACTER_SET\n   * TIER 4 OPTIMIZATION: Looks up actual values from indices using valueLookup table\n   * TIER 5a OPTIMIZATION: Decompresses variable-length tuplets (2/3/4/5 elements)\n   * TIER 5b OPTIMIZATION: Looks up tuplets from tuplet indices\n   * TIER 6b OPTIMIZATION: 2-element tuplets using common left index\n   *\n   * Tuplet decompression (deterministic based on length):\n   *   - Length 2: [w, a] → [w, CL, w, a, CL]  (w===r AND l===CL AND d===CL)\n   *   - Length 3: [w, l, a] → [w, l, w, a, l]  (w===r AND l===d)\n   *   - Length 4: [w, l, a, d] → [w, l, w, a, d]  (w===r only)\n   *   - Length 5: [w, l, r, a, d] (no decompression)\n   *\n   * Reconstructs full TextMetrics-compatible objects from compact arrays\n   * Always uses BitmapText.CHARACTER_SET for character order\n   * @param {Array} tupletIndices - Array of tuplet indices (single integers)\n   * @param {Object} metricsCommonToAllCharacters - Common metrics shared across all characters\n   * @param {Array} valueLookup - Value lookup table mapping indices to actual values\n   * @param {Array} tupletLookup - Tuplet lookup table mapping tuplet indices to index arrays\n   * @param {number} [commonLeftIndex] - Common left bounding box index (Tier 6b, optional)\n   * @private\n   */\n  static #expandCharacterMetrics(tupletIndices, metricsCommonToAllCharacters, valueLookup, tupletLookup, commonLeftIndex) {\n    const expanded = {};\n\n    // Convert BitmapText.CHARACTER_SET string to array of characters\n    const chars = Array.from(BitmapText.CHARACTER_SET);\n\n    // Reconstruct object by mapping array positions to characters\n    chars.forEach((char, index) => {\n      // TIER 5b: Look up tuplet from tuplet index\n      const tupletIndex = tupletIndices[index];\n      const compressed = tupletLookup[tupletIndex];\n\n      let indices;\n\n      // TIER 5+6b: Decompress tuplet based on length\n      if (compressed.length === 2) {\n        // Case D (TIER 6b): [w, a] → [w, CL, w, a, CL]\n        // All three patterns: w===r AND l===CL AND d===CL\n        if (commonLeftIndex === undefined) {\n          throw new Error(\n            `2-element tuplet found but no common left index provided.\\n` +\n            `Character \"${char}\" at index ${index}: [${compressed.join(',')}]\\n` +\n            `This indicates a corrupted Tier 6b font file. Please regenerate font assets.`\n          );\n        }\n        indices = [\n          compressed[0],    // width\n          commonLeftIndex,  // left = common left\n          compressed[0],    // right = width (pattern 1)\n          compressed[1],    // ascent\n          commonLeftIndex   // descent = common left (pattern 2)\n        ];\n      }\n      else if (compressed.length === 3) {\n        // Case C: [w, l, a] → [w, l, w, a, l]\n        // Both w===r and l===d\n        indices = [\n          compressed[0],  // width\n          compressed[1],  // left\n          compressed[0],  // right = width (pattern 1)\n          compressed[2],  // ascent\n          compressed[1]   // descent = left (pattern 2)\n        ];\n      }\n      else if (compressed.length === 4) {\n        // Case B: [w, l, a, d] → [w, l, w, a, d]\n        // Only w===r\n        indices = [\n          compressed[0],  // width\n          compressed[1],  // left\n          compressed[0],  // right = width (pattern 1)\n          compressed[2],  // ascent\n          compressed[3]   // descent\n        ];\n      }\n      else if (compressed.length === 5) {\n        // Case A: [w, l, r, a, d] - no decompression needed\n        indices = compressed;\n      }\n      else {\n        throw new Error(\n          `Invalid glyph tuplet length for character \"${char}\" at index ${index}.\\n` +\n          `Expected 2, 3, 4, or 5 elements, got ${compressed.length}: [${compressed.join(',')}]\\n` +\n          `This indicates a corrupted font file. Please regenerate font assets.`\n        );\n      }\n\n      // TIER 4: Look up actual values from indices\n      const width = valueLookup[indices[0]];\n      const actualBoundingBoxLeft = valueLookup[indices[1]];\n      const actualBoundingBoxRight = valueLookup[indices[2]];\n      const actualBoundingBoxAscent = valueLookup[indices[3]];\n      const actualBoundingBoxDescent = valueLookup[indices[4]];\n\n      expanded[char] = {\n        // Glyph-specific metrics looked up from value table\n        width,\n        actualBoundingBoxLeft,\n        actualBoundingBoxRight,\n        actualBoundingBoxAscent,\n        actualBoundingBoxDescent,\n\n        // Copy over the metrics common to all characters.\n        // This is a bit of a waste of memory, however this object needs to\n        // look as much as possible like a TextMetrics object, and this\n        // is what it looks like.\n        fontBoundingBoxAscent: metricsCommonToAllCharacters.fba,\n        fontBoundingBoxDescent: metricsCommonToAllCharacters.fbd,\n        emHeightAscent: metricsCommonToAllCharacters.fba,          // Same as fontBoundingBoxAscent\n        emHeightDescent: metricsCommonToAllCharacters.fbd,         // Same as fontBoundingBoxDescent\n        hangingBaseline: metricsCommonToAllCharacters.hb,\n        alphabeticBaseline: metricsCommonToAllCharacters.ab,\n        ideographicBaseline: metricsCommonToAllCharacters.ib,\n        pixelDensity: metricsCommonToAllCharacters.pd              // pixelDensity (CRITICAL for atlas reconstruction)\n      };\n    });\n    return expanded;\n  }\n\n  /**\n   * Converts array of integer values back to floats by dividing by 10000\n   * TIER 6 OPTIMIZATION: Integer to value conversion\n   *\n   * @param {number[]} integers - Array of integer values\n   * @returns {number[]} Array of float values\n   * @private\n   */\n  static #convertIntegersToValues(integers) {\n    return integers.map(int => int / 10000);\n  }\n\n  /**\n   * Unflattens baseline array back to object\n   * TIER 6 OPTIMIZATION: Baseline array → object\n   *\n   * @param {number[]} baselineArray - Array [fba, fbd, hb, ab, ib, pd]\n   * @returns {Object} Baseline object with {fba, fbd, hb, ab, ib, pd}\n   * @private\n   */\n  static #unflattenBaseline(baselineArray) {\n    if (!Array.isArray(baselineArray) || baselineArray.length !== 6) {\n      throw new Error(\n        `Invalid baseline array - expected 6 elements, got ${baselineArray?.length}.\\n` +\n        `This indicates a corrupted font file. Please regenerate font assets.`\n      );\n    }\n\n    // Fixed order: fba, fbd, hb, ab, ib, pd\n    return {\n      fba: baselineArray[0],\n      fbd: baselineArray[1],\n      hb: baselineArray[2],\n      ab: baselineArray[3],\n      ib: baselineArray[4],\n      pd: baselineArray[5]\n    };\n  }\n\n  /**\n   * Unflattens tuplet data from negative delimiter format\n   * TIER 6b OPTIMIZATION: Tuplet array unflattening with negative delimiters\n   *\n   * Parses negative-delimited format and shifts back to 0-based indices.\n   * Negative numbers mark the end of each tuplet.\n   *\n   * Converts: [3,2,-15,1,2,16,-8] → [[2,1,14],[0,1,15,7]]\n   * Each tuplet ends with a negative number (1-based) which becomes last element (0-based)\n   *\n   * @param {number[]} flattened - Flattened array with negative delimiters (1-based indices)\n   * @returns {Array<Array<number>>} Array of tuplet arrays (0-based indices)\n   * @private\n   */\n  static #unflattenTuplets(flattened) {\n    const tuplets = [];\n    let currentTuplet = [];\n\n    for (let i = 0; i < flattened.length; i++) {\n      const value = flattened[i];\n\n      if (value < 0) {\n        // Negative marks end of tuplet\n        // Negate back and subtract 1 to get 0-based index\n        currentTuplet.push((-value) - 1);\n\n        // Validate tuplet length\n        if (currentTuplet.length < 2 || currentTuplet.length > 5) {\n          throw new Error(\n            `Invalid tuplet length ${currentTuplet.length} at position ${i}.\\n` +\n            `Expected 2, 3, 4, or 5. This indicates a corrupted font file.\\n` +\n            `Please regenerate font assets.`\n          );\n        }\n\n        tuplets.push(currentTuplet);\n        currentTuplet = [];\n      } else {\n        // Positive value: subtract 1 to get 0-based index\n        currentTuplet.push(value - 1);\n      }\n    }\n\n    // Check for incomplete tuplet at end\n    if (currentTuplet.length > 0) {\n      throw new Error(\n        `Incomplete tuplet at end of data.\\n` +\n        `Found ${currentTuplet.length} elements without negative delimiter.\\n` +\n        `This indicates a corrupted font file. Please regenerate font assets.`\n      );\n    }\n\n    return tuplets;\n  }\n\n}\n// ============================================================================\n// AtlasPositioning.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasPositioning.js\n// ============================================================================\n\n// AtlasPositioning - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It encapsulates atlas positioning data for a single font configuration as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasPositioningFAB for font assets building capabilities (if needed)\n// - Contains only essential positioning data and accessor methods\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas positioning for ONE font configuration\n// - Pre-computed lookups for optimal performance during glyph rendering\n// - xInAtlas values are reconstructed from tightWidth during deserialization (not serialized)\n// - Reconstruction happens once at load time, not per-character at render time\n// - All positioning data stored in memory for O(1) access during rendering\n// - Provides clean API for accessing glyph positioning within atlas\n// - Follows same immutable pattern as FontProperties and FontMetrics\n//\n// SEPARATION RATIONALE:\n// - Encapsulates related atlas positioning data together\n// - Eliminates repeated parameter passing for positioning lookups\n// - Serves as domain object for atlas positioning\n// - Enables cleaner, more object-oriented API\n//\nclass AtlasPositioning {\n  constructor(data, options = {}) {\n    // Validate input data structure\n    if (!data || typeof data !== 'object') {\n      throw new Error('AtlasPositioning constructor requires data object');\n    }\n\n    // Atlas positioning data for glyph rendering\n    this._tightWidth = data.tightWidth || {};\n    this._tightHeight = data.tightHeight || {};\n    this._dx = data.dx || {};\n    this._dy = data.dy || {};\n    // NOTE: xInAtlas is reconstructed from tightWidth during deserialization (not serialized to reduce file size)\n    // At build time: populated by AtlasPositioningFAB during atlas packing\n    // At runtime: reconstructed by TightAtlasReconstructor during atlas loading\n    this._xInAtlas = data.xInAtlas || {};\n\n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this._tightWidth);\n      Object.freeze(this._tightHeight);\n      Object.freeze(this._dx);\n      Object.freeze(this._dy);\n      Object.freeze(this._xInAtlas);\n      Object.freeze(this);\n    }\n  }\n\n  /**\n   * Get positioning metrics for glyph rendering from atlas\n   * @param {string} char - Character (code point) to get positioning for\n   * @returns {Object} Object with xInAtlas, tightWidth, tightHeight, dx, dy\n   */\n  getPositioning(char) {\n    return {\n      xInAtlas: this._xInAtlas[char],\n      tightWidth: this._tightWidth[char],\n      tightHeight: this._tightHeight[char],\n      dx: this._dx[char],\n      dy: this._dy[char]\n    };\n  }\n\n  /**\n   * Check if positioning data exists for a character\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if positioning data exists\n   */\n  hasPositioning(char) {\n    return this._xInAtlas[char] !== undefined &&\n           this._tightWidth[char] !== undefined &&\n           this._tightHeight[char] !== undefined;\n  }\n\n  /**\n   * Check if atlas position (xInAtlas) exists for a character\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if atlas position exists\n   */\n  hasAtlasPosition(char) {\n    return this._xInAtlas[char] !== undefined;\n  }\n\n  /**\n   * Get all available characters in this atlas positioning\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    return Object.keys(this._xInAtlas);\n  }\n\n  /**\n   * Get tight width for a character\n   * @param {string} char - Character (code point) to get width for\n   * @returns {number|undefined} Tight width or undefined if not found\n   */\n  getTightWidth(char) {\n    return this._tightWidth[char];\n  }\n\n  /**\n   * Get tight height for a character\n   * @param {string} char - Character (code point) to get height for\n   * @returns {number|undefined} Tight height or undefined if not found\n   */\n  getTightHeight(char) {\n    return this._tightHeight[char];\n  }\n\n  /**\n   * Get X position in atlas for a character\n   * @param {string} char - Character (code point) to get X position for\n   * @returns {number|undefined} X position in atlas or undefined if not found\n   */\n  getXInAtlas(char) {\n    return this._xInAtlas[char];\n  }\n\n  /**\n   * Get dx offset for a character\n   * @param {string} char - Character (code point) to get dx for\n   * @returns {number|undefined} dx offset or undefined if not found\n   */\n  getDx(char) {\n    return this._dx[char];\n  }\n\n  /**\n   * Get dy offset for a character\n   * @param {string} char - Character (code point) to get dy for\n   * @returns {number|undefined} dy offset or undefined if not found\n   */\n  getDy(char) {\n    return this._dy[char];\n  }\n\n  /**\n   * Generate a deterministic hash of the positioning data\n   * Uses a simple but stable algorithm that works cross-browser/cross-platform\n   * @returns {string} 6-character hex hash\n   */\n  getHash() {\n    // Get sorted characters for deterministic ordering\n    const chars = this.getAvailableCharacters().sort();\n\n    // Build deterministic string representation\n    const parts = [];\n    for (const char of chars) {\n      const pos = this.getPositioning(char);\n      // Use fixed-precision to avoid floating point variations\n      parts.push(\n        `${char}:` +\n        `w${pos.tightWidth}` +\n        `h${pos.tightHeight}` +\n        `x${pos.dx}` +\n        `y${pos.dy}` +\n        `a${pos.xInAtlas}`\n      );\n    }\n\n    // Simple hash function (FNV-1a variant)\n    const str = parts.join('|');\n    let hash = 2166136261; // FNV offset basis\n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n    }\n\n    // Return as 6-character hex (24 bits)\n    return (hash >>> 0).toString(16).substring(0, 6).padStart(6, '0');\n  }\n\n}\n// ============================================================================\n// AtlasImage.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasImage.js\n// ============================================================================\n\n// AtlasImage - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It encapsulates atlas image data as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasImageFAB for font assets building capabilities\n// - Contains only essential image data and accessor methods\n// - No image generation, validation, or serialization code\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas image for ONE font configuration\n// - Provides clean API for accessing image properties and validation\n// - Follows same immutable pattern as FontProperties, TextProperties, FontMetrics, and AtlasPositioning\n// - Establishes architectural symmetry: AtlasImage + AtlasPositioning = AtlasData\n//\n// SEPARATION RATIONALE:\n// - Encapsulates image-related functionality in dedicated domain object\n// - Eliminates raw Canvas/Image element handling throughout the codebase\n// - Provides consistent interface for image validation and access\n// - Enables cleaner, more object-oriented API design\n//\n// For font assets building capabilities, use AtlasImageFAB which extends this class.\nclass AtlasImage {\n  constructor(image, options = {}) {\n    // Validate input image\n    if (!image) {\n      throw new Error('AtlasImage constructor requires image (Canvas or Image element)');\n    }\n\n    if (typeof image !== 'object' || (image.width === undefined && image.naturalWidth === undefined)) {\n      throw new Error('AtlasImage constructor requires Canvas or Image element with width property');\n    }\n\n    // Store image (Canvas or Image element) - public field (object is frozen)\n    this.image = image;\n\n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this);\n    }\n  }\n\n  /**\n   * Get the width of the atlas image\n   * @returns {number} Width in pixels\n   */\n  get width() {\n    // Handle both Canvas (width) and Image (naturalWidth/width) elements\n    return this.image.naturalWidth || this.image.width || 0;\n  }\n\n  /**\n   * Get the height of the atlas image\n   * @returns {number} Height in pixels\n   */\n  get height() {\n    // Handle both Canvas (height) and Image (naturalHeight/height) elements\n    return this.image.naturalHeight || this.image.height || 0;\n  }\n\n  /**\n   * Check if this atlas image is valid for rendering\n   * @returns {boolean} True if image has valid dimensions\n   */\n  isValid() {\n    return this.image &&\n           typeof this.image === 'object' &&\n           this.width > 0 &&\n           this.height > 0;\n  }\n\n  /**\n   * Check if the image is ready for rendering operations\n   * @returns {boolean} True if image can be used for drawing operations\n   */\n  canRender() {\n    if (!this.isValid()) return false;\n\n    // For Image elements, check if they're loaded\n    if (this.image instanceof Image) {\n      return this.image.complete && this.image.naturalWidth > 0;\n    }\n\n    // Canvas elements are always ready if they have valid dimensions\n    return true;\n  }\n\n  /**\n   * Get the type of the underlying image element\n   * @returns {string} 'canvas' or 'image'\n   */\n  getImageType() {\n    if (this.image instanceof HTMLCanvasElement ||\n        (typeof OffscreenCanvas !== 'undefined' && this.image instanceof OffscreenCanvas)) {\n      return 'canvas';\n    }\n    if (this.image instanceof Image || this.image instanceof HTMLImageElement) {\n      return 'image';\n    }\n    return 'unknown';\n  }\n\n  /**\n   * Get a canvas context for drawing operations (if image is a canvas)\n   * @param {string} contextType - Context type (default: '2d')\n   * @returns {CanvasRenderingContext2D|null} Canvas context or null if not a canvas\n   */\n  getContext(contextType = '2d') {\n    if (this.getImageType() === 'canvas') {\n      return this.image.getContext(contextType);\n    }\n    return null;\n  }\n\n  /**\n   * Check if this atlas image equals another atlas image\n   * @param {AtlasImage} other - Another AtlasImage instance\n   * @returns {boolean} True if they reference the same image\n   */\n  equals(other) {\n    if (!(other instanceof AtlasImage)) return false;\n    return this.image === other.image;\n  }\n\n  /**\n   * Get debug information about this atlas image\n   * @returns {Object} Debug information\n   */\n  getDebugInfo() {\n    return {\n      type: this.getImageType(),\n      width: this.width,\n      height: this.height,\n      isValid: this.isValid(),\n      canRender: this.canRender()\n    };\n  }\n}\n// ============================================================================\n// AtlasData.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasData.js\n// ============================================================================\n\n// AtlasData - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It encapsulates both atlas image and positioning data for a font configuration.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Combines AtlasImage with AtlasPositioning data\n// - Provides unified interface for atlas image and positioning access\n// - Establishes architectural symmetry: AtlasImage + AtlasPositioning = AtlasData\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas image + positioning for ONE font configuration\n// - Stores AtlasImage instance with AtlasPositioning instance\n// - Provides clean API for accessing both image and positioning data\n// - Validates atlas integrity for rendering safety\n//\n// SEPARATION RATIONALE:\n// - Atlas positioning data moved from FontMetrics to be co-located with atlas images\n// - Reduces metrics file sizes (positioning only loaded when atlas is loaded)\n// - Better separation: metrics for measurement, atlas for rendering\n// - Perfect symmetry: both image and positioning are encapsulated in domain objects\n//\nclass AtlasData {\n  constructor(atlasImage, atlasPositioning) {\n    // Validate AtlasImage instance\n    if (!(atlasImage instanceof AtlasImage)) {\n      throw new Error('AtlasData constructor requires AtlasImage instance (not raw Canvas/Image)');\n    }\n\n    // Validate AtlasPositioning instance (optional but recommended)\n    if (atlasPositioning && !(atlasPositioning instanceof AtlasPositioning)) {\n      throw new Error('AtlasData constructor requires AtlasPositioning instance (not raw positioning object)');\n    }\n\n    // Store AtlasImage instance (public field - object is frozen)\n    this.atlasImage = atlasImage;\n\n    // Store AtlasPositioning instance (public field - object is frozen)\n    this.atlasPositioning = atlasPositioning;\n\n    // Freeze for immutability (safe to use as value object)\n    Object.freeze(this);\n  }\n\n  /**\n   * Check if positioning data exists for a character\n   * Null-safe convenience method that delegates to the AtlasPositioning instance.\n   * This demonstrates the delegation pattern: AtlasData wraps AtlasPositioning\n   * and provides a simplified interface for checking character availability.\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if positioning data exists\n   */\n  hasPositioning(char) {\n    if (!this.atlasPositioning) return false;\n\n    // Delegate to AtlasPositioning instance\n    return this.atlasPositioning.hasPositioning(char);\n  }\n\n  /**\n   * Check if this atlas data is valid for rendering\n   * @returns {boolean} True if atlas has valid image and dimensions\n   */\n  isValid() {\n    return this.atlasImage?.isValid();\n  }\n\n  /**\n   * Get all available characters in this atlas\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    if (!this.atlasPositioning) return [];\n\n    // Delegate to AtlasPositioning instance\n    return this.atlasPositioning.getAvailableCharacters();\n  }\n\n  /**\n   * Get the width of the atlas image\n   * @returns {number} Width in pixels\n   */\n  get width() {\n    return this.atlasImage.width;\n  }\n\n  /**\n   * Get the height of the atlas image\n   * @returns {number} Height in pixels\n   */\n  get height() {\n    return this.atlasImage.height;\n  }\n\n  /**\n   * Check if the atlas can be rendered\n   * @returns {boolean} True if atlas is ready for rendering operations\n   */\n  canRender() {\n    return this.atlasImage?.canRender();\n  }\n\n  /**\n   * Check if this atlas data equals another atlas data\n   * @param {AtlasData} other - Another AtlasData instance\n   * @returns {boolean} True if they reference the same image and positioning\n   */\n  equals(other) {\n    if (!(other instanceof AtlasData)) return false;\n    return this.atlasImage.equals(other.atlasImage) &&\n           this.atlasPositioning === other.atlasPositioning;\n  }\n\n  /**\n   * Get debug information about this atlas data\n   * @returns {Object} Debug information\n   */\n  getDebugInfo() {\n    return {\n      atlasImage: this.atlasImage ? this.atlasImage.getDebugInfo() : null,\n      atlasPositioning: this.atlasPositioning ? {\n        availableCharacters: this.atlasPositioning.getAvailableCharacters().length,\n        characters: this.atlasPositioning.getAvailableCharacters().slice(0, 10) // First 10 for brevity\n      } : null,\n      isValid: this.isValid(),\n      canRender: this.canRender()\n    };\n  }\n}\n// ============================================================================\n// AtlasReconstructionUtils.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/builder/AtlasReconstructionUtils.js\n// ============================================================================\n\n// AtlasReconstructionUtils - Shared utility for image data extraction\n// Used by TightAtlasReconstructor for atlas image processing\n//\n// ARCHITECTURAL DESIGN RATIONALE:\n// This utility class provides cross-platform image data extraction that works\n// in both browser and Node.js environments. It handles different image sources\n// (HTMLImageElement, Canvas, AtlasImage wrapper) and creates temporary canvases\n// as needed for pixel data access.\n//\n// By centralizing this logic here, we ensure:\n// - Zero code duplication across different reconstruction contexts\n// - Single source of truth for image data extraction\n// - Consistent cross-platform behavior (browser vs Node.js)\n// - Easy to unit test independently\n\nclass AtlasReconstructionUtils {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('AtlasReconstructionUtils cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Gets ImageData from various image sources\n   * Handles: HTMLImageElement (PNG), Canvas (QOI), AtlasImage wrapper\n   * @param {Image|Canvas|AtlasImage} image - Image source\n   * @returns {ImageData} ImageData object with pixel data\n   * @throws {Error} If image is not a valid source\n   */\n  static getImageData(image) {\n    // Unwrap AtlasImage if needed\n    const actualImage = image?.image ? image.image : image;\n\n    if (!actualImage) {\n      throw new Error('getImageData: Invalid image source (null or undefined)');\n    }\n\n    // If Canvas, directly get image data\n    if (actualImage.getContext) {\n      const ctx = actualImage.getContext('2d');\n      return ctx.getImageData(0, 0, actualImage.width, actualImage.height);\n    }\n\n    // If Image element, draw to temporary canvas first\n    if (actualImage.naturalWidth !== undefined || actualImage.width !== undefined) {\n      // Create canvas using explicit double invocation\n      const canvas = BitmapText.getCanvasFactory()();\n      canvas.width = actualImage.naturalWidth || actualImage.width;\n      canvas.height = actualImage.naturalHeight || actualImage.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(actualImage, 0, 0);\n      return ctx.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    throw new Error('getImageData: Image source is not a Canvas or Image element');\n  }\n}\n\n// ============================================================================\n// AtlasCellDimensions.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/utils/AtlasCellDimensions.js\n// ============================================================================\n\n// AtlasCellDimensions - Utility for calculating atlas cell dimensions\n//\n// Provides centralized formulas for calculating cell dimensions from character metrics.\n// These formulas MUST be consistent across AtlasBuilder and TightAtlasReconstructor.\n//\n// Cell dimensions follow the Atlas format (variable-width cells):\n// - Cell width: actualBoundingBoxLeft + actualBoundingBoxRight (varies per character)\n// - Cell height: fontBoundingBoxAscent + fontBoundingBoxDescent (constant per font)\n\nclass AtlasCellDimensions {\n  // Private constructor - prevent instantiation\n  constructor() {\n    throw new Error('AtlasCellDimensions cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Calculate cell width for a character\n   * CRITICAL: Must match GlyphFAB.js:155-160 which uses Math.round()\n   * @param {Object} charMetrics - Character metrics from FontMetrics\n   * @returns {number} Cell width in pixels (rounded, matching GlyphFAB canvas creation)\n   */\n  static getWidth(charMetrics) {\n    return Math.round(\n      charMetrics.actualBoundingBoxLeft +\n      charMetrics.actualBoundingBoxRight\n    );\n  }\n\n  /**\n   * Calculate cell height for a font\n   * CRITICAL: Must match GlyphFAB.js:170-175 which uses Math.round()\n   * @param {Object} charMetrics - Character metrics (any character from the font)\n   * @returns {number} Cell height in pixels (rounded, constant for entire font)\n   */\n  static getHeight(charMetrics) {\n    return Math.round(\n      charMetrics.fontBoundingBoxAscent +\n      charMetrics.fontBoundingBoxDescent\n    );\n  }\n\n  /**\n   * Calculate both dimensions\n   * @param {Object} charMetrics - Character metrics\n   * @returns {{width: number, height: number}}\n   */\n  static getDimensions(charMetrics) {\n    return {\n      width: this.getWidth(charMetrics),\n      height: this.getHeight(charMetrics)\n    };\n  }\n}\n\n// ============================================================================\n// TightAtlasReconstructor.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/TightAtlasReconstructor.js\n// ============================================================================\n\n// TightAtlasReconstructor - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for reconstructing tight atlases from\n// standard atlases via pixel scanning.\n//\n// DISTRIBUTION ROLE:\n// - Used by font-assets-builder.html and also by the runtime to reconstruct tight\n//   atlases for display and storage\n// - Reconstructs tight atlas + positioning data from atlas image\n//\n// ARCHITECTURE:\n// - Takes atlas image (variable-width cells) and FontMetrics\n// - Scans each character cell to find tight bounding box\n// - Repacks into tight atlas\n// - Calculates positioning data (dx, dy) using EXACT formulas from AtlasPositioningFAB\n//\n// CRITICAL REQUIREMENTS:\n// - MUST use sorted character order (same as AtlasBuilder)\n// - dx/dy formulas MUST match AtlasPositioningFAB.js:87-88 exactly\n// - MUST handle multi-part glyphs (i, j with dots) correctly\n// - MUST use 4-step optimized tight bounds detection algorithm\n//\nclass TightAtlasReconstructor {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('TightAtlasReconstructor cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Main entry point - reconstructs tight atlas from standard atlas\n   *\n   * PARAMETER ORDER: Standardized to (fontMetrics, data) for API consistency\n   *\n   * @param {FontMetrics} fontMetrics - Font metrics for cell dimensions (CSS pixels) and positioning\n   * @param {Image|Canvas|AtlasImage} atlasImage - Atlas image (variable-width cells, already at physical pixels)\n   * @returns {{atlasImage: AtlasImage, atlasPositioning: AtlasPositioning}}\n   */\n  static reconstructFromAtlas(fontMetrics, atlasImage) {\n    // 1. Get ImageData from atlas for pixel scanning\n    const imageData = AtlasReconstructionUtils.getImageData(atlasImage);\n\n    // 2. Get SORTED character list (CRITICAL for determinism)\n    // Must match the order used in AtlasBuilder\n    const characters = fontMetrics.getAvailableCharacters().sort();\n\n    if (characters.length === 0) {\n      throw new Error('TightAtlasReconstructor: No characters found in FontMetrics');\n    }\n\n    console.debug(`TightAtlasReconstructor: Processing ${characters.length} characters`);\n\n    // 3. Calculate cell dimensions from font metrics\n    // Cell height is constant across all characters in this font\n    // Character metrics contain CSS pixel values, but we need to infer physical pixel dimensions\n    // from the actual atlas image by detecting pixelDensity from the ratio\n    const firstChar = characters[0];\n    const firstMetrics = fontMetrics.getCharacterMetrics(firstChar);\n\n    // Infer pixelDensity from first character's metrics vs atlas dimensions\n    // This works because: physical_pixels = CSS_pixels * pixelDensity\n    const height_CssPx = AtlasCellDimensions.getHeight(firstMetrics);\n    const pixelDensity = firstMetrics.pixelDensity || 1; // Use pixelDensity from metrics if available\n    const cellHeight_PhysPx = Math.round(height_CssPx * pixelDensity);\n\n    console.debug(`🔍 TightAtlasReconstructor: pixelDensity=${pixelDensity}, height_CssPx=${height_CssPx}, cellHeight_PhysPx=${cellHeight_PhysPx}`);\n\n    // 4. Scan each cell to find tight bounds within the atlas cell\n    let cellX_PhysPx = 0;\n    const tightBounds = {};\n    const cellDebugInfo = []; // Track first 5 chars for debugging\n\n    for (const char of characters) {\n      const charMetrics = fontMetrics.getCharacterMetrics(char);\n\n      // Cell width is variable per character (scale CSS pixels to physical pixels)\n      const width_CssPx = AtlasCellDimensions.getWidth(charMetrics);\n      const cellWidth_PhysPx = Math.round(width_CssPx * pixelDensity);\n\n      // Debug first few characters\n      if (cellDebugInfo.length < 5) {\n        cellDebugInfo.push(`${char}:css=${width_CssPx},phys=${cellWidth_PhysPx},x=${cellX_PhysPx}`);\n      }\n\n      // Find tight bounds within this cell using 4-step optimized algorithm\n      const bounds = this.findTightBounds(\n        imageData,\n        cellX_PhysPx,\n        0,\n        cellWidth_PhysPx,\n        cellHeight_PhysPx\n      );\n\n      if (bounds) {\n        tightBounds[char] = bounds;\n      }\n\n      cellX_PhysPx += cellWidth_PhysPx;\n    }\n\n    console.debug(`🔍 Cell dimensions (first 5): ${cellDebugInfo.join(', ')}`);\n\n    // 5. Repack into tight atlas with positioning data\n    return this.packTightAtlas(\n      fontMetrics,\n      tightBounds,\n      characters,\n      atlasImage,\n      pixelDensity,\n      cellHeight_PhysPx\n    );\n  }\n\n  /**\n   * Find tight bounds within a cell using 4-step optimized algorithm\n   * This scans for the minimal bounding box of non-transparent pixels\n   *\n   * @param {ImageData} imageData - Image data from original atlas\n   * @param {number} cellX_PhysPx - X position of cell in atlas (physical pixels)\n   * @param {number} cellY_PhysPx - Y position of cell in atlas (physical pixels, always 0)\n   * @param {number} cellWidth_PhysPx - Width of this character's cell (physical pixels)\n   * @param {number} cellHeight_PhysPx - Height of cell (physical pixels, constant for font)\n   * @returns {{left, top, width, height} | null} - Tight bounds relative to cell origin, or null if empty\n   */\n  static findTightBounds(imageData, cellX_PhysPx, cellY_PhysPx, cellWidth_PhysPx, cellHeight_PhysPx) {\n    const pixels = imageData.data;\n    const atlasWidth_PhysPx = imageData.width;\n\n    // Helper to get alpha value at position\n    // Optimized: pre-calculate stride and use bit shift for x*4\n    const stride = atlasWidth_PhysPx * 4;\n    const getAlpha = (x, y) => pixels[y * stride + (x << 2) + 3];\n\n    // STEP 1: Find bottom edge (scan UP from bottom) - early exit\n    // This finds the bottommost row with any non-transparent pixel\n    let bottom_PhysPx = -1;\n    for (let y = cellY_PhysPx + cellHeight_PhysPx - 1; y >= cellY_PhysPx && bottom_PhysPx === -1; y--) {\n      for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx && bottom_PhysPx === -1; x++) {\n        if (getAlpha(x, y) > 0) {\n          bottom_PhysPx = y;\n        }\n      }\n    }\n\n    // Empty cell (no visible pixels)\n    if (bottom_PhysPx === -1) return null;\n\n    // STEP 2: Find top edge (scan DOWN, only to bottom) - early exit\n    // This finds the topmost row with any non-transparent pixel\n    let top_PhysPx = cellY_PhysPx;\n    for (let y = cellY_PhysPx; y <= bottom_PhysPx; y++) {\n      let found = false;\n      for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx; x++) {\n        if (getAlpha(x, y) > 0) {\n          top_PhysPx = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // STEP 3: Find left edge (scan columns, only vertical range found above) - early exit\n    // This finds the leftmost column with any non-transparent pixel\n    let left_PhysPx = cellX_PhysPx;\n    for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx; x++) {\n      let found = false;\n      for (let y = top_PhysPx; y <= bottom_PhysPx; y++) {\n        if (getAlpha(x, y) > 0) {\n          left_PhysPx = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // STEP 4: Find right edge (scan right→left, only vertical range) - early exit\n    // This finds the rightmost column with any non-transparent pixel\n    let right_PhysPx = cellX_PhysPx + cellWidth_PhysPx - 1;\n    for (let x = cellX_PhysPx + cellWidth_PhysPx - 1; x >= cellX_PhysPx; x--) {\n      let found = false;\n      for (let y = top_PhysPx; y <= bottom_PhysPx; y++) {\n        if (getAlpha(x, y) > 0) {\n          right_PhysPx = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // Return bounds relative to cell origin (not absolute atlas coordinates)\n    return {\n      left: left_PhysPx - cellX_PhysPx,        // Relative to cell left edge (physical pixels)\n      top: top_PhysPx - cellY_PhysPx,          // Relative to cell top edge (physical pixels)\n      width: right_PhysPx - left_PhysPx + 1,   // Inclusive width (physical pixels)\n      height: bottom_PhysPx - top_PhysPx + 1   // Inclusive height (physical pixels)\n    };\n  }\n\n  /**\n   * Pack tight glyphs and calculate positioning data\n   *\n   * PARAMETER ORDER: Standardized to (fontMetrics, data, options) for API consistency\n   *\n   * @param {FontMetrics} fontMetrics - Font metrics for positioning calculations\n   * @param {Object} tightBounds - Map of char → {left, top, width, height} within cells\n   * @param {Array<string>} characters - Sorted array of characters\n   * @param {Image|Canvas} sourceAtlasImage - Source Atlas image for extraction\n   * @param {number} pixelDensity - Pixel density multiplier for positioning calculations\n   * @param {number} cellHeight_PhysPx - Cell height in physical pixels (for distanceBetweenBottomAndBottomOfCanvas calculation)\n   * @returns {{atlasImage: AtlasImage, atlasPositioning: AtlasPositioning}}\n   */\n  static packTightAtlas(fontMetrics, tightBounds, characters, sourceAtlasImage, pixelDensity, cellHeight_PhysPx) {\n    // Calculate tight atlas dimensions (all in physical pixels)\n    let totalWidth_PhysPx = 0;\n    let maxHeight_PhysPx = 0;\n\n    for (const char of characters) {\n      if (tightBounds[char]) {\n        totalWidth_PhysPx += tightBounds[char].width;\n        maxHeight_PhysPx = Math.max(maxHeight_PhysPx, tightBounds[char].height);\n      }\n    }\n\n    // Create tight atlas canvas (explicit double invocation: get factory, call factory)\n    const tightCanvas = BitmapText.getCanvasFactory()();\n    tightCanvas.width = totalWidth_PhysPx;\n    tightCanvas.height = maxHeight_PhysPx;\n    const ctx = tightCanvas.getContext('2d');\n\n    // Initialize positioning data structure\n    let xInTightAtlas_PhysPx = 0;\n    const positioning = {\n      tightWidth: {},\n      tightHeight: {},\n      dx: {},\n      dy: {},\n      xInAtlas: {}\n    };\n\n    // Extract and pack each tight glyph\n    let cellX_PhysPx = 0;\n\n    for (const char of characters) {\n      const charMetrics = fontMetrics.getCharacterMetrics(char);\n\n      // Calculate cell width in physical pixels (CSS pixels * pixelDensity)\n      // MUST be calculated for ALL characters to track cellX_PhysPx correctly\n      const width_CssPx = AtlasCellDimensions.getWidth(charMetrics);\n      const cellWidth_PhysPx = Math.round(width_CssPx * pixelDensity);\n      // cellHeight_PhysPx is passed as parameter (already in physical pixels)\n\n      const bounds = tightBounds[char];\n      if (!bounds) {\n        // No visible pixels, but still need to advance cellX_PhysPx for next character\n        cellX_PhysPx += cellWidth_PhysPx;\n        continue;\n      }\n\n      // Extract tight glyph from original atlas\n      const tempCanvas = BitmapText.getCanvasFactory()();\n      tempCanvas.width = bounds.width;\n      tempCanvas.height = bounds.height;\n      const tempCtx = tempCanvas.getContext('2d');\n\n      // Copy tight region from atlas to temp canvas\n      const srcX_PhysPx = Math.floor(cellX_PhysPx + bounds.left);\n      const srcY_PhysPx = Math.floor(bounds.top);\n      const srcWidth_PhysPx = Math.floor(bounds.width);\n      const srcHeight_PhysPx = Math.floor(bounds.height);\n\n      tempCtx.drawImage(\n        sourceAtlasImage,\n        srcX_PhysPx, srcY_PhysPx,      // Source position in atlas (physical pixels)\n        srcWidth_PhysPx, srcHeight_PhysPx,  // Source dimensions (physical pixels)\n        0, 0,                           // Dest position in temp canvas\n        srcWidth_PhysPx, srcHeight_PhysPx   // Dest dimensions (physical pixels)\n      );\n\n      // Draw to tight atlas at sequential position\n      ctx.drawImage(tempCanvas, xInTightAtlas_PhysPx, 0);\n\n      // ═══════════════════════════════════════════════════════════════════════\n      // POSITIONING CALCULATION\n      // ═══════════════════════════════════════════════════════════════════════\n      //\n      // We need to calculate dx/dy offsets for rendering the tight glyph.\n      // These formulas MUST match AtlasPositioningFAB.js:91-92 exactly.\n      //\n      // Coordinate System Overview:\n      //\n      //   Atlas Cell (variable-width):        Tight Bounds:\n      //   ┌──────────────────────────┐\n      //   │ actualBoundingBox        │        ┌──────────┐\n      //   │ ┌──────────────────┐     │        │  ████    │  ← Minimal box\n      //   │ │                  │     │   →    │  ████    │     around pixels\n      //   │ │    ████          │     │        └──────────┘\n      //   │ │    ████          │     │\n      //   │ └──────────────────┘     │        dx = horizontal offset to align\n      //   │ fontBoundingBox          │        dy = vertical offset from baseline\n      //   └──────────────────────────┘\n      //     ↑                          ↑\n      //     cellX_PhysPx             cellX_PhysPx + cellWidth_PhysPx\n      //\n      // dx: Horizontal offset from rendering position to tight glyph position\n      //     Components:\n      //     - actualBoundingBoxLeft: Distance from text baseline to left edge of actual glyph\n      //     - bounds.left: Left edge of tight bounds within cell\n      //     Formula: -actualBoundingBoxLeft * pixelDensity + bounds.left\n      //\n      // dy: Vertical offset from baseline to top of tight glyph\n      //     Components:\n      //     - bounds.height: Height of tight glyph\n      //     - distanceBetweenBottomAndBottomOfCanvas: Gap below glyph (accounts for descenders)\n      //     - pixelDensity: Scale factor for high-DPI displays\n      //     Formula: -bounds.height - distanceBetweenBottomAndBottomOfCanvas + pixelDensity\n      //\n      //     The distanceBetweenBottomAndBottomOfCanvas accounts for descenders (like 'g', 'y')\n      //     and ensures proper vertical alignment relative to the text baseline.\n      //\n      // Note: pixelDensity is passed as a parameter (charMetrics only contains CSS pixel measurements)\n\n      // Calculate distance from bottom of tight bounds to bottom of character canvas\n      // This is used in the dy calculation\n      // Note: bounds.top + bounds.height - 1 gives the Y coordinate of the bottom pixel (like bottomRightCorner.y)\n      const distanceBetweenBottomAndBottomOfCanvas_PhysPx =\n        cellHeight_PhysPx - (bounds.top + bounds.height - 1) - 1;\n\n      // Store positioning data (all in physical pixels)\n      positioning.tightWidth[char] = bounds.width;    // Physical pixels\n      positioning.tightHeight[char] = bounds.height;  // Physical pixels\n      positioning.xInAtlas[char] = xInTightAtlas_PhysPx;  // Physical pixels\n\n      // EXACT dx formula from AtlasPositioningFAB.js:91 (physical pixels)\n      positioning.dx[char] =\n        - Math.round(charMetrics.actualBoundingBoxLeft) * pixelDensity\n        + bounds.left;\n\n      // EXACT dy formula from AtlasPositioningFAB.js:92 (physical pixels)\n      positioning.dy[char] =\n        - bounds.height\n        - distanceBetweenBottomAndBottomOfCanvas_PhysPx\n        + 1 * pixelDensity;\n\n      xInTightAtlas_PhysPx += bounds.width;\n      cellX_PhysPx += cellWidth_PhysPx;\n    }\n\n    // Create domain objects\n    const tightAtlasImage = new AtlasImage(tightCanvas);\n    const atlasPositioning = new AtlasPositioning(positioning);\n\n    console.debug(`TightAtlasReconstructor: Packed ${Object.keys(positioning.xInAtlas).length} glyphs into ${totalWidth_PhysPx}×${maxHeight_PhysPx} atlas`);\n\n    return { atlasImage: tightAtlasImage, atlasPositioning };\n  }\n}\n\n// ============================================================================\n// AtlasDataStore.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasDataStore.js\n// ============================================================================\n\n// AtlasDataStore - Core Runtime Static Class\n//\n// This is a CORE RUNTIME static class designed for minimal bundle size (~2-3KB).\n// It provides essential atlas data storage and retrieval for text rendering.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasDataStoreFAB for font assets building and generation\n// - Contains only atlas data structures and accessors needed at runtime\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Static class with private storage for AtlasData objects\n// - Uses Map-based storage for O(1) atlas lookups by font properties\n// - Provides the minimal atlas interface needed by BitmapText for glyph rendering\n// - Optimized for fast atlas access during text drawing\n// - Separate from FontMetricsStore to enable independent loading strategies\n//\n// SEPARATION RATIONALE:\n// - Atlas data contains both large binary images and positioning data loaded from atlas-*.js files\n// - Can be lazy-loaded on demand to optimize memory usage\n// - Independent of font metrics which are small and loaded upfront\n// - Aligns with file structure: atlas-*.js vs metrics-*.js\n//\n// For font assets building and generation capabilities, use AtlasDataStoreFAB.\nclass AtlasDataStore {\n  // Private static storage\n  // Keys are FontProperties.key strings for O(1) lookup\n  static #atlases = new Map(); // fontProperties.key → AtlasData\n\n  static getAtlasData(fontProperties) {\n    return AtlasDataStore.#atlases.get(fontProperties.key);\n  }\n\n  static setAtlasData(fontProperties, atlasData) {\n    // Only accept AtlasData instances\n    if (!(atlasData instanceof AtlasData)) {\n      throw new Error('AtlasDataStore.setAtlasData requires AtlasData instance (not raw images)');\n    }\n    AtlasDataStore.#atlases.set(fontProperties.key, atlasData);\n  }\n\n  // Helper method to check if an atlas is valid for rendering\n  static isValidAtlas(atlas) {\n    // Only work with AtlasData instances\n    if (!(atlas instanceof AtlasData)) {\n      return false;\n    }\n    return atlas.isValid();\n  }\n\n  // Get all available font properties keys\n  static getAvailableFonts() {\n    return Array.from(AtlasDataStore.#atlases.keys());\n  }\n\n  // Check if atlas exists for font properties\n  static hasAtlas(fontProperties) {\n    return AtlasDataStore.#atlases.has(fontProperties.key);\n  }\n\n  // Remove atlas for font properties\n  static deleteAtlas(fontProperties) {\n    return AtlasDataStore.#atlases.delete(fontProperties.key);\n  }\n\n  // Clear all atlases\n  static clear() {\n    AtlasDataStore.#atlases.clear();\n  }\n\n  // Get count of stored atlases\n  static size() {\n    return AtlasDataStore.#atlases.size;\n  }\n}\n\n// ============================================================================\n// FontMetricsStore.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontMetricsStore.js\n// ============================================================================\n\n// FontMetricsStore - Core Runtime Static Class\n//\n// This is a CORE RUNTIME static class designed for minimal bundle size (~2-3KB).\n// It provides essential font metrics storage and retrieval as a repository of FontMetrics instances.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontMetricsStoreFAB for font assets building and generation\n// - Contains only FontMetrics instance storage and retrieval\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Static class with private storage for FontMetrics instances\n// - Stores FontMetrics instances for fast O(1) lookup by font properties\n// - Simple repository pattern with get/set/has operations\n// - FontMetrics instances encapsulate all metrics data and behavior\n// - Separate from AtlasDataStore to enable independent loading strategies\n//\n// SEPARATION RATIONALE:\n// - Font metrics are small data loaded from metrics-*.js files\n// - Can be loaded upfront for immediate text measurement capabilities\n// - Independent of atlas images which are larger and can be lazy-loaded\n// - FontMetrics instances provide clean API without fontProperties parameter passing\n//\n// For font assets building and generation capabilities, use FontMetricsStoreFAB.\nclass FontMetricsStore {\n  // Private static storage\n  // Keys are FontProperties.key strings for O(1) FontMetrics instance lookup\n  static #fontMetrics = new Map(); // fontProperties.key → FontMetrics instance\n\n  /**\n   * Get FontMetrics instance for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {FontMetrics|undefined} FontMetrics instance or undefined if not found\n   */\n  static getFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.get(fontProperties.key);\n  }\n\n  /**\n   * Set FontMetrics instance for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {FontMetrics} fontMetrics - FontMetrics instance to store\n   */\n  static setFontMetrics(fontProperties, fontMetrics) {\n    FontMetricsStore.#fontMetrics.set(fontProperties.key, fontMetrics);\n  }\n\n  /**\n   * Check if FontMetrics exists for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if FontMetrics instance exists\n   */\n  static hasFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.has(fontProperties.key);\n  }\n\n  /**\n   * Remove FontMetrics for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if FontMetrics was removed\n   */\n  static deleteFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.delete(fontProperties.key);\n  }\n\n  /**\n   * Get all available font configurations\n   * @returns {string[]} Array of fontProperties.key strings\n   */\n  static getAvailableFonts() {\n    return Array.from(FontMetricsStore.#fontMetrics.keys());\n  }\n\n  /**\n   * Clear all stored FontMetrics instances\n   */\n  static clear() {\n    FontMetricsStore.#fontMetrics.clear();\n  }\n\n  /**\n   * Get count of stored FontMetrics instances\n   * @returns {number} Number of stored font configurations\n   */\n  static size() {\n    return FontMetricsStore.#fontMetrics.size;\n  }\n}\n\n// ============================================================================\n// FontManifest.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontManifest.js\n// ============================================================================\n\n// FontManifest - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It provides centralized font registry management for test and development environments.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Manages available font IDs without polluting global namespace\n// - Provides clean API for font registry operations\n// - Designed for use in test-renderer and development tools\n//\n// ARCHITECTURE:\n// - Static-only class for singleton behavior\n// - Modern private fields for encapsulation\n// - Returns copies of arrays to prevent external modification\n// - Simple, focused API for font ID management\n//\n// This class replaces the global bitmapTextManifest variable and provides\n// better encapsulation and a cleaner API for managing font registrations.\nclass FontManifest {\n  // Private static field to store font IDs\n  static #fontIDs = [];\n\n  // Add one or more font IDs to the registry\n  // Accepts either a single string ID or an array of IDs\n  static addFontIDs(ids) {\n    // Handle both single ID and array inputs\n    const idsArray = Array.isArray(ids) ? ids : [ids];\n\n    // Add IDs, avoiding duplicates\n    for (const id of idsArray) {\n      if (typeof id === 'string' && !this.#fontIDs.includes(id)) {\n        this.#fontIDs.push(id);\n      }\n    }\n  }\n\n  // Get all registered font IDs\n  // Returns a shallow copy to prevent external modification\n  static allFontIDs() {\n    return [...this.#fontIDs];\n  }\n\n  // Check if a specific font ID is registered\n  static hasFontID(id) {\n    return this.#fontIDs.includes(id);\n  }\n\n  // Get the count of registered font IDs\n  static count() {\n    return this.#fontIDs.length;\n  }\n\n  // Clear all registered font IDs\n  // Useful for testing and resetting state\n  static clear() {\n    this.#fontIDs.length = 0;\n  }\n\n  // Get font IDs as a sorted array\n  // Useful for consistent iteration order\n  static allFontIDsSorted() {\n    return [...this.#fontIDs].sort();\n  }\n}\n// ============================================================================\n// FontLoaderBase.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontLoaderBase.js\n// ============================================================================\n\n// FontLoaderBase - Abstract Static Base Class for Font Loading\n//\n// This abstract static class provides the core font loading infrastructure\n// for BitmapText. It defines the public API and shared logic for font loading,\n// while platform-specific implementations (browser, Node.js) extend this class.\n//\n// DISTRIBUTION ROLE:\n// - Used by both browser and Node.js distributions\n// - Defines abstract methods implemented by platform-specific loaders\n// - Contains shared loading orchestration and atlas reconstruction logic\n//\n// ARCHITECTURE:\n// - Abstract static class (not instantiated)\n// - Extended by FontLoaderBrowser and FontLoaderNode\n// - Owns fontDirectory configuration (#fontDirectory private field)\n// - Works with BitmapText's internal stores (#fontMetrics, #atlasData)\n// - Uses Template Method Pattern for platform-specific operations\n// - BitmapText delegates fontDirectory get/set to FontLoader (this class owns what it uses)\n//\n// LOADING FLOW:\n// 1. loadFonts() orchestrates loading of multiple fonts\n// 2. loadMetricsFile() loads metrics (platform-specific)\n// 3. loadAtlasFile() loads atlas image (platform-specific)\n// 4. loadAtlasFromPackage() reconstructs atlas from image (shared)\n// 5. processPendingAtlas() handles async atlas/metrics loading (shared)\n\nclass FontLoaderBase {\n  // ============================================\n  // Shared Static Storage\n  // ============================================\n\n  // Temporary storage for atlas packages before reconstruction\n  static _tempAtlasPackages = {};\n\n  // Pending atlases waiting for metrics\n  static _pendingAtlases = new Map();\n\n  // Loading promises to prevent duplicate loads\n  static _loadingPromises = new Map();\n\n  // ============================================\n  // Configuration\n  // ============================================\n\n  /**\n   * Default font directory for all platforms\n   * @constant {string}\n   */\n  static DEFAULT_FONT_DIRECTORY = './font-assets/';\n\n  /**\n   * User-configured font directory override (null = use default)\n   * @private\n   */\n  static #fontDirectory = null;\n\n  /**\n   * Set font directory (overrides default)\n   * @param {string} path - Path to font assets directory\n   */\n  static setFontDirectory(path) {\n    FontLoaderBase.#fontDirectory = path;\n  }\n\n  /**\n   * Get font directory (returns override or default)\n   * @returns {string} Font directory path\n   */\n  static getFontDirectory() {\n    return FontLoaderBase.#fontDirectory ?? FontLoaderBase.DEFAULT_FONT_DIRECTORY;\n  }\n\n  /**\n   * Get default font directory (shared across all platforms)\n   * @deprecated Use getFontDirectory() instead\n   * @returns {string} Font directory path\n   */\n  static getDefaultFontDirectory() {\n    return FontLoaderBase.DEFAULT_FONT_DIRECTORY;\n  }\n\n  // ============================================\n  // Registration API (called by asset files)\n  // ============================================\n\n  /**\n   * Register font metrics from metrics-*.js file\n   * Called by self-registering metrics files\n   * @param {string} idString - Font ID string\n   * @param {Object} compactedData - Compacted metrics data\n   * @param {Object} bitmapTextClass - BitmapText class reference (for backward compatibility)\n   */\n  static registerMetrics(idString, compactedData, bitmapTextClass) {\n    if (typeof idString !== 'string') {\n      console.warn('FontLoader.registerMetrics: Invalid idString - must be string');\n      return;\n    }\n\n    if (typeof MetricsExpander === 'undefined') {\n      console.warn('FontLoader.registerMetrics: MetricsExpander not available');\n      return;\n    }\n\n    if (typeof FontProperties === 'undefined') {\n      console.warn('FontLoader.registerMetrics: FontProperties not available');\n      return;\n    }\n\n    const fontProperties = FontProperties.fromIDString(idString);\n    const fontMetrics = MetricsExpander.expand(compactedData);\n\n    // Store metrics directly in FontMetricsStore\n    FontMetricsStore.setFontMetrics(fontProperties, fontMetrics);\n\n    // Process any pending atlases that were waiting for these metrics\n    FontLoaderBase._processPendingAtlas(idString);\n  }\n\n  /**\n   * Register atlas from atlas-*.js file (base64 only, positioning reconstructed later)\n   * Called by self-registering atlas files\n   * @param {string} idString - Font ID string\n   * @param {string} base64Data - Base64-encoded atlas data\n   */\n  static registerAtlas(idString, base64Data) {\n    if (typeof idString !== 'string' || typeof base64Data !== 'string') {\n      console.warn('FontLoader.registerAtlas: Invalid arguments - idString and base64Data must be strings');\n      return;\n    }\n\n    FontLoaderBase._tempAtlasPackages[idString] = { base64Data };\n  }\n\n  // ============================================\n  // Public Loading API\n  // ============================================\n\n  /**\n   * Load a single font\n   * @param {string} idString - Font ID string\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when font is loaded\n   */\n  static async loadFont(idString, options, bitmapTextClass) {\n    return this.loadFonts([idString], options, bitmapTextClass);\n  }\n\n  /**\n   * Load multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {boolean} [options.loadMetrics] - Load metrics (default: true)\n   * @param {boolean} [options.loadAtlases] - Load atlases (default: true)\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when all fonts are loaded\n   */\n  static async loadFonts(idStrings, options = {}, bitmapTextClass) {\n    const {\n      onProgress = null,\n      isFileProtocol = false,\n      loadMetrics = true,\n      loadAtlases = true\n    } = options;\n\n    const filesPerFont = (loadMetrics ? 1 : 0) + (loadAtlases ? 1 : 0);\n    const totalFiles = idStrings.length * filesPerFont;\n    let loadedFiles = 0;\n\n    const reportProgress = () => {\n      if (onProgress) onProgress(loadedFiles, totalFiles);\n    };\n\n    for (const idString of idStrings) {\n      // Check if already loading\n      if (FontLoaderBase._loadingPromises.has(idString)) {\n        await FontLoaderBase._loadingPromises.get(idString);\n        continue;\n      }\n\n      const loadPromise = (async () => {\n        try {\n          if (loadMetrics) {\n            await this.loadMetricsFile(idString, bitmapTextClass);\n            loadedFiles++;\n            reportProgress();\n          }\n\n          if (loadAtlases) {\n            await this.loadAtlasFile(idString, isFileProtocol, bitmapTextClass);\n            loadedFiles++;\n            reportProgress();\n          }\n        } finally {\n          FontLoaderBase._loadingPromises.delete(idString);\n        }\n      })();\n\n      FontLoaderBase._loadingPromises.set(idString, loadPromise);\n      await loadPromise;\n    }\n  }\n\n  /**\n   * Load only metrics for fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetrics(idStrings, options, bitmapTextClass) {\n    return this.loadFonts(idStrings, { ...options, loadAtlases: false }, bitmapTextClass);\n  }\n\n  /**\n   * Load only atlases for fonts (metrics must be loaded first)\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlases are loaded\n   */\n  static async loadAtlases(idStrings, options, bitmapTextClass) {\n    return this.loadFonts(idStrings, { ...options, loadMetrics: false }, bitmapTextClass);\n  }\n\n  // ============================================\n  // Platform-Specific Loading (Abstract Methods)\n  // ============================================\n\n  /**\n   * Load metrics file for a font\n   * @abstract Must be implemented by derived classes\n   * @param {string} idString - Font ID string\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetricsFile(idString, bitmapTextClass) {\n    throw new Error('FontLoaderBase.loadMetricsFile() must be implemented by derived class');\n  }\n\n  /**\n   * Load atlas file for a font\n   * @abstract Must be implemented by derived classes\n   * @param {string} idString - Font ID string\n   * @param {boolean} isFileProtocol - Whether using file:// protocol\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlas is loaded\n   */\n  static async loadAtlasFile(idString, isFileProtocol, bitmapTextClass) {\n    throw new Error('FontLoaderBase.loadAtlasFile() must be implemented by derived class');\n  }\n\n  // ============================================\n  // Shared Atlas Reconstruction Logic\n  // ============================================\n\n  /**\n   * Load atlas from package (image + metrics) and reconstruct positioning\n   * @param {string} idString - Font ID string\n   * @param {HTMLImageElement|HTMLCanvasElement} atlasImage - Atlas source image\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {boolean} True if atlas was reconstructed, false if pending metrics\n   */\n  static _loadAtlasFromPackage(idString, atlasImage, bitmapTextClass) {\n    const fontProperties = FontProperties.fromIDString(idString);\n\n    // Clean up temporary package storage\n    delete FontLoaderBase._tempAtlasPackages[idString];\n\n    // Get font metrics (required for reconstruction)\n    const fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n\n    if (!fontMetrics) {\n      // Store atlas for later reconstruction when metrics become available\n      FontLoaderBase._pendingAtlases.set(idString, {atlasImage, bitmapTextClass});\n      return false;\n    }\n\n    // Check if TightAtlasReconstructor is available\n    if (typeof TightAtlasReconstructor === 'undefined') {\n      throw new Error(`FontLoader: TightAtlasReconstructor required for font loading - not available for ${idString}`);\n    }\n\n    // Reconstruct tight atlas + positioning from Atlas image\n    const { atlasImage: tightAtlasImage, atlasPositioning } =\n      TightAtlasReconstructor.reconstructFromAtlas(fontMetrics, atlasImage);\n\n    // Create AtlasData instance\n    const atlasData = new AtlasData(tightAtlasImage, atlasPositioning);\n\n    // Store directly in AtlasDataStore\n    AtlasDataStore.setAtlasData(fontProperties, atlasData);\n\n    return true;\n  }\n\n  /**\n   * Process pending atlas that was waiting for metrics\n   * @param {string} idString - Font ID string\n   */\n  static _processPendingAtlas(idString) {\n    // Check if there's a pending atlas waiting for these metrics\n    if (!FontLoaderBase._pendingAtlases.has(idString)) {\n      return;\n    }\n\n    const {atlasImage, bitmapTextClass} = FontLoaderBase._pendingAtlases.get(idString);\n    FontLoaderBase._pendingAtlases.delete(idString);\n\n    // Try to load the atlas now that metrics are available\n    FontLoaderBase._loadAtlasFromPackage(idString, atlasImage, bitmapTextClass);\n  }\n}\n\n// ============================================================================\n// QOIDecode.js - Source: /Users/davidedellacasa/code/BitmapText.js/lib/QOIDecode.js\n// ============================================================================\n\n/**\n * Decode a QOI file given as an ArrayBuffer.\n *\n * @param {ArrayBuffer} arrayBuffer ArrayBuffer containing the QOI file.\n * @param {int|null} [byteOffset] Offset to the start of the QOI file in arrayBuffer\n * @param {int|null} [byteLength] Length of the QOI file in bytes\n * @param {int|null} [outputChannels] Number of channels to include in the decoded array\n *\n * @returns {{channels: number, data: Uint8Array, colorspace: number, width: number, error: boolean, height: number}}\n */\nfunction QOIDecode (arrayBuffer, byteOffset, byteLength, outputChannels) {\n    if (typeof byteOffset === 'undefined' || byteOffset === null) {\n        byteOffset = 0;\n    }\n\n    if (typeof byteLength === 'undefined' || byteLength === null) {\n        byteLength = arrayBuffer.byteLength - byteOffset;\n    }\n\n    const uint8 = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n\n    const magic1 = uint8[0];\n    const magic2 = uint8[1];\n    const magic3 = uint8[2];\n    const magic4 = uint8[3];\n\n    const width = ((uint8[4] << 24) | (uint8[5] << 16) | (uint8[6] << 8) | uint8[7]) >>> 0;\n    const height = ((uint8[8] << 24) | (uint8[9] << 16) | (uint8[10] << 8) | uint8[11]) >>> 0;\n\n    const channels = uint8[12];\n    const colorspace = uint8[13];\n\n    if (typeof outputChannels === 'undefined' || outputChannels === null) {\n        outputChannels = channels;\n    }\n\n    if (magic1 !== 0x71 || magic2 !== 0x6F || magic3 !== 0x69 || magic4 !== 0x66) {\n        throw new Error('QOI.decode: The signature of the QOI file is invalid');\n    }\n\n    if (channels < 3 || channels > 4) {\n        throw new Error('QOI.decode: The number of channels declared in the file is invalid');\n    }\n\n    if (colorspace > 1) {\n        throw new Error('QOI.decode: The colorspace declared in the file is invalid');\n    }\n\n    if (outputChannels < 3 || outputChannels > 4) {\n        throw new Error('QOI.decode: The number of channels for the output is invalid');\n    }\n\n    const pixelLength = width * height * outputChannels;\n    const result = new Uint8Array(pixelLength);\n\n    let arrayPosition = 14;\n\n    const index = new Uint8Array(64 * 4);\n    let indexPosition = 0;\n\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    let alpha = 255;\n\n    const chunksLength = byteLength - 8;\n\n    let run = 0;\n    let pixelPosition = 0;\n\n    for (; pixelPosition < pixelLength && arrayPosition < byteLength - 4; pixelPosition += outputChannels) {\n        if (run > 0) {\n            run--;\n        } else if (arrayPosition < chunksLength) {\n            const byte1 = uint8[arrayPosition++];\n\n            if (byte1 === 0b11111110) { // QOI_OP_RGB\n                red = uint8[arrayPosition++];\n                green = uint8[arrayPosition++];\n                blue = uint8[arrayPosition++];\n            } else if (byte1 === 0b11111111) { // QOI_OP_RGBA\n                red = uint8[arrayPosition++];\n                green = uint8[arrayPosition++];\n                blue = uint8[arrayPosition++];\n                alpha = uint8[arrayPosition++];\n            } else if ((byte1 & 0b11000000) === 0b00000000) { // QOI_OP_INDEX\n                red = index[byte1 * 4];\n                green = index[byte1 * 4 + 1];\n                blue = index[byte1 * 4 + 2];\n                alpha = index[byte1 * 4 + 3];\n            } else if ((byte1 & 0b11000000) === 0b01000000) { // QOI_OP_DIFF\n                red += ((byte1 >> 4) & 0b00000011) - 2;\n                green += ((byte1 >> 2) & 0b00000011) - 2;\n                blue += (byte1 & 0b00000011) - 2;\n\n                // handle wraparound\n                red = (red + 256) % 256;\n                green = (green + 256) % 256;\n                blue = (blue + 256) % 256;\n            } else if ((byte1 & 0b11000000) === 0b10000000) { // QOI_OP_LUMA\n                const byte2 = uint8[arrayPosition++];\n                const greenDiff = (byte1 & 0b00111111) - 32;\n                const redDiff = greenDiff + ((byte2 >> 4) & 0b00001111) - 8;\n                const blueDiff = greenDiff + (byte2 & 0b00001111) - 8;\n\n                // handle wraparound\n                red = (red + redDiff + 256) % 256;\n                green = (green + greenDiff + 256) % 256;\n                blue = (blue + blueDiff + 256) % 256;\n            } else if ((byte1 & 0b11000000) === 0b11000000) { // QOI_OP_RUN\n                run = byte1 & 0b00111111;\n            }\n\n            indexPosition = ((red * 3 + green * 5 + blue * 7 + alpha * 11) % 64) * 4;\n            index[indexPosition] = red;\n            index[indexPosition + 1] = green;\n            index[indexPosition + 2] = blue;\n            index[indexPosition + 3] = alpha;\n        }\n\n        if (outputChannels === 4) { // RGBA\n            result[pixelPosition] = red;\n            result[pixelPosition + 1] = green;\n            result[pixelPosition + 2] = blue;\n            result[pixelPosition + 3] = alpha;\n        } else { // RGB\n            result[pixelPosition] = red;\n            result[pixelPosition + 1] = green;\n            result[pixelPosition + 2] = blue;\n        }\n    }\n\n    if (pixelPosition < pixelLength) {\n        throw new Error('QOI.decode: Incomplete image');\n    }\n\n    // checking the 00000001 padding is not required, as per specs\n\n    return {\n        width: width,\n        height: height,\n        colorspace: colorspace,\n        channels: outputChannels,\n        data: result\n    };\n}\n// ============================================================================\n// FontLoader-node.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/platform/FontLoader-node.js\n// ============================================================================\n\n// FontLoader - Node.js-Specific Font Loader\n//\n// This static class extends FontLoaderBase to provide Node.js-specific\n// font loading implementation using Node.js APIs (fs, path, require).\n//\n// DISTRIBUTION ROLE:\n// - Only included in Node.js distributions\n// - Excluded from browser bundles via build scripts\n// - Uses Node.js-specific APIs (fs, path, eval)\n//\n// ARCHITECTURE:\n// - Static class extending FontLoaderBase\n// - Implements abstract methods for Node.js environment\n// - Uses fs.readFileSync for metrics and atlas loading\n// - Uses eval() to execute metrics registration code\n// - Uses QOIDecode for atlas decompression\n//\n// LOADING STRATEGIES:\n// - Metrics: fs.readFileSync + eval()\n// - Atlas: fs.readFileSync QOI file + QOIDecode + canvas creation\n\nclass FontLoader extends FontLoaderBase {\n\n  // ============================================\n  // File Name Constants (from BitmapText)\n  // ============================================\n\n  static METRICS_PREFIX = 'metrics-';\n  static ATLAS_PREFIX = 'atlas-';\n  static JS_EXTENSION = '.js';\n\n  // ============================================\n  // Node.js-Specific Loading Implementation\n  // ============================================\n\n  /**\n   * Load metrics file via fs.readFileSync + eval\n   * @param {string} idString - Font ID string\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetricsFile(idString, bitmapTextClass) {\n    if (typeof require === 'undefined') {\n      throw new Error('FontLoader.loadMetricsFile requires Node.js environment');\n    }\n\n    const fs = require('fs');\n    const path = require('path');\n\n    const fontDirectory = FontLoaderBase.getFontDirectory();\n    const metricsPath = path.resolve(fontDirectory, `${FontLoader.METRICS_PREFIX}${idString}${FontLoader.JS_EXTENSION}`);\n\n    try {\n      const metricsCode = fs.readFileSync(metricsPath, 'utf8');\n      // Execute with BitmapText in scope\n      // The metrics file will call BitmapText.registerMetrics()\n      eval(metricsCode);\n    } catch (error) {\n      console.warn(`Metrics file not found: ${metricsPath}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Load atlas file via fs.readFileSync + QOIDecode\n   * @param {string} idString - Font ID string\n   * @param {boolean} isFileProtocol - Not used in Node.js\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlas is loaded\n   */\n  static async loadAtlasFile(idString, isFileProtocol, bitmapTextClass) {\n    if (typeof require === 'undefined') {\n      throw new Error('FontLoader.loadAtlasFile requires Node.js environment');\n    }\n\n    const fs = require('fs');\n    const path = require('path');\n\n    const fontDirectory = FontLoaderBase.getFontDirectory();\n    const atlasPath = path.resolve(fontDirectory, `${FontLoader.ATLAS_PREFIX}${idString}-qoi${FontLoader.JS_EXTENSION}`);\n\n    try {\n      const atlasCode = fs.readFileSync(atlasPath, 'utf8');\n      // Execute with BitmapText in scope to call registerAtlas\n      // The atlas file will call BitmapText.registerAtlas()\n      eval(atlasCode);\n\n      // Now reconstruct the atlas\n      const pkg = FontLoaderBase._tempAtlasPackages[idString];\n      if (pkg && pkg.base64Data) {\n        // Decode QOI\n        if (typeof QOIDecode === 'undefined') {\n          throw new Error('FontLoader: QOIDecode not available - required for atlas loading');\n        }\n\n        const qoiData = Uint8Array.from(atob(pkg.base64Data), c => c.charCodeAt(0));\n        const decoded = QOIDecode(qoiData.buffer);\n\n        // Create canvas and draw (explicit double invocation: get factory, call factory)\n        const canvas = bitmapTextClass.getCanvasFactory()();\n        canvas.width = decoded.width;\n        canvas.height = decoded.height;\n        const ctx = canvas.getContext('2d');\n        const imageData = ctx.createImageData(decoded.width, decoded.height);\n        imageData.data.set(decoded.data);\n        ctx.putImageData(imageData, 0, 0);\n\n        // Reconstruct atlas\n        FontLoaderBase._loadAtlasFromPackage(idString, canvas, bitmapTextClass);\n      }\n    } catch (error) {\n      console.warn(`Atlas loading error for ${atlasPath}: ${error.message}`);\n      console.warn('Will use placeholder rectangles');\n    }\n  }\n}\n\n// ============================================================================\n// GLOBAL EXPORTS (Node.js)\n// ============================================================================\n// Expose classes globally for Node.js require() usage\nif (typeof global !== 'undefined') {\n  global.StatusCode = StatusCode;\n  global.SUCCESS_STATUS = SUCCESS_STATUS;\n  global.createErrorStatus = createErrorStatus;\n  global.getStatusDescription = getStatusDescription;\n  global.FontProperties = FontProperties;\n  global.TextProperties = TextProperties;\n  global.FontMetrics = FontMetrics;\n  global.BitmapText = BitmapText;\n  global.AtlasDataStore = AtlasDataStore;\n  global.FontMetricsStore = FontMetricsStore;\n  global.FontManifest = FontManifest;\n  global.QOIDecode = QOIDecode;\n}\n"],"mappings":"AAmEA,MAAMA,WAAaC,OAAOC,OAAO,CAC/BC,QAAS,EACTC,WAAY,EACZC,gBAAiB,EACjBC,SAAU,EACVC,cAAe,IAOXC,eAAiBP,OAAOC,OAAO,CACnCO,KAAMT,WAAWG,UASnB,SAASO,kBAAkBD,EAAME,EAAU,CAAC,GAC1C,OAAOV,OAAOC,OAAO,CACnBO,UACGE,GAEP,CAOA,SAASC,UAAUC,GACjB,OAAOA,GAAQJ,OAAST,WAAWG,OACrC,CAQA,SAASW,kBAAkBD,GACzB,OAAOA,IACLA,EAAOJ,OAAST,WAAWI,YAC3BS,EAAOJ,OAAST,WAAWK,gBAE/B,CAQA,SAASU,iBAAiBF,GACxB,OAAOA,IACLA,EAAOJ,OAAST,WAAWM,UAC3BO,EAAOJ,OAAST,WAAWO,cAE/B,CAOA,SAASS,qBAAqBH,GAC5B,IAAKA,GAAiC,iBAAhBA,EAAOJ,KAC3B,MAAO,iBAGT,OAAQI,EAAOJ,MACb,KAAKT,WAAWG,QACd,MAAO,UACT,KAAKH,WAAWI,WACd,MAAO,4BACT,KAAKJ,WAAWK,gBACd,MAAO,mCAAmCQ,EAAOI,aAAe,IAAIJ,EAAOI,cAAcC,KAAK,IAAM,YACtG,KAAKlB,WAAWM,SACd,MAAO,0CACT,KAAKN,WAAWO,cACd,MAAO,sCAAsCM,EAAOM,kBAAoB,IAAIN,EAAOM,mBAAmBD,KAAK,IAAM,iCACnH,QACE,MAAO,wBAAwBL,EAAOJ,OAE5C,CAuBA,MAAMW,eACJ,WAAAC,CAAYC,EAAcC,EAAYC,EAAWC,EAAYC,GAE3DC,KAAKL,aAAeA,GAAgB,EACpCK,KAAKJ,WAAaA,EAClBI,KAAKH,UAAYA,GAAa,SAC9BG,KAAKF,WAAaA,GAAc,SAChCE,KAAKD,SAAWA,EAIhBC,KAAKC,KAAO,GAAGD,KAAKL,gBAAgBK,KAAKJ,cAAcI,KAAKH,aAAaG,KAAKF,cAAcE,KAAKD,WAIjGC,KAAKE,UAAY,WAAWF,MAAKG,EAAcH,KAAKL,iBAAiBK,KAAKJ,oBAAoBI,KAAKH,oBAAoBG,KAAKF,mBAAmBE,MAAKG,EAAcH,KAAKD,YAGvKzB,OAAOC,OAAOyB,KAChB,CAGA,EAAAG,CAAcC,GACZ,MAAMC,EAAMC,OAAOF,GACnB,OAAOC,EAAIE,SAAS,KAAOF,EAAIG,QAAQ,IAAK,KAAO,GAAGH,KACxD,CAGA,OAAII,GACF,OAAOT,KAAKC,IACd,CAGA,YAAIS,GACF,OAAOV,KAAKE,SACd,CAKA,mBAAOS,CAAaD,GAClB,MAAME,EAAQF,EAASG,MAAM,KAGvBlB,EAAemB,WAAWrB,gBAAesB,EAAmBH,EAAM,GAAIA,EAAM,KAC5Eb,EAAWe,WAAWrB,gBAAesB,EAAmBH,EAAM,GAAIA,EAAM,MACxEhB,EAAagB,EAAM,GACnBf,EAAYe,EAAM,GAClBd,EAAac,EAAM,GAGzB,OAAO,IAAInB,eAAeE,EAAcC,EAAYC,EAAWC,EAAYC,EAC7E,CAIA,cAAOiB,CAAQP,GACb,MAAOd,EAAcC,EAAYC,EAAWC,EAAYC,GAAYU,EAAII,MAAM,KAG9E,OAAO,IAAIpB,eACTqB,WAAWnB,GACXC,EACAC,EACAC,EACAgB,WAAWf,GAEf,CAGA,QAAOgB,CAAmBE,EAAaC,GACrC,OAAKA,GAA+B,MAAhBA,EAGb,GAAGD,KAAeC,IAFhBD,CAGX,CAGA,MAAAE,CAAOC,GACL,OAAMA,aAAiB3B,gBAChBO,KAAKC,OAASmB,EAAMnB,IAC7B,EAyBF,MAAMoB,eACJ,WAAA3B,CAAY4B,EAAU,CAAC,GAErB,MAAMC,iBACJA,GAAmB,EAAIC,aACvBA,EAAe,SAAQC,UACvBA,EAAY,OAAMC,UAClBA,EAAY,WACVJ,EAGJtB,KAAKuB,iBAAmBA,EACxBvB,KAAKwB,aAAeA,EACpBxB,KAAKyB,UAAYA,EACjBzB,KAAK0B,UAAYA,EAGjB1B,KAAKC,KAAO,WAAWD,KAAKuB,6BAA6BvB,KAAKwB,sBAAsBxB,KAAKyB,mBAAmBzB,KAAK0B,YAGjHpD,OAAOC,OAAOyB,KAChB,CAGA,OAAIS,GACF,OAAOT,KAAKC,IACd,CAGA,kBAAO0B,CAAYJ,EAAkBD,EAAU,CAAC,GAC9C,OAAO,IAAID,eAAe,IACrBC,EACHC,oBAEJ,CAGA,gBAAOK,CAAUF,EAAWJ,EAAU,CAAC,GACrC,OAAO,IAAID,eAAe,IACrBC,EACHI,aAEJ,CAGA,oBAAOG,CAAcP,EAAU,CAAC,GAC9B,OAAO,IAAID,eAAe,CACxBG,aAAc,YACXF,GAEP,CAGA,kBAAAQ,CAAmBP,GACjB,OAAO,IAAIF,eAAe,CACxBE,mBACAC,aAAcxB,KAAKwB,aACnBC,UAAWzB,KAAKyB,UAChBC,UAAW1B,KAAK0B,WAEpB,CAGA,aAAAK,CAAcL,GACZ,OAAO,IAAIL,eAAe,CACxBE,iBAAkBvB,KAAKuB,iBACvBC,aAAcxB,KAAKwB,aACnBC,UAAWzB,KAAKyB,UAChBC,aAEJ,CAGA,MAAAP,CAAOC,GACL,OAAMA,aAAiBC,gBAChBrB,KAAKC,OAASmB,EAAMnB,IAC7B,CAGA,QAAA+B,GACE,MAAO,CACLT,iBAAkBvB,KAAKuB,iBACvBC,aAAcxB,KAAKwB,aACnBC,UAAWzB,KAAKyB,UAChBC,UAAW1B,KAAK0B,UAEpB,EA8BF,MAAMO,YACJ,WAAAvC,CAAYwC,EAAMZ,EAAU,CAAC,GAE3B,IAAKY,GAAwB,iBAATA,EAClB,MAAM,IAAIC,MAAM,gDAIlBnC,KAAKoC,cAAgBF,EAAKG,cAAgB,CAAC,EAG3CrC,KAAKsC,kBAAoBJ,EAAKK,kBAAoB,CAAC,EAGnDvC,KAAKwC,0BAA4BN,EAAKO,2CAA6C,KAI9EnB,EAAQoB,UACXpE,OAAOC,OAAOyB,KAAKoC,eACnB9D,OAAOC,OAAOyB,KAAKsC,mBACnBhE,OAAOC,OAAOyB,MAElB,CAOA,mBAAA2C,CAAoBC,GAClB,OAAO5C,KAAKsC,kBAAkBM,EAChC,CAQA,oBAAAC,CAAqBC,EAAUC,GAC7B,OAAKD,GAAaC,GACX/C,KAAKoC,cAAcU,KAAYC,IADF,CAEtC,CAOA,QAAAC,CAASJ,GACP,OAAOA,KAAQ5C,KAAKsC,iBACtB,CAMA,2BAAAW,GACE,OAAOjD,KAAKwC,yBACd,CAMA,eAAAU,GACE,OAAOlD,KAAKoC,aACd,CAMA,sBAAAe,GACE,OAAO7E,OAAO8E,KAAKpD,KAAKsC,kBAC1B,EAWF,QAA0B,IAAfjE,iBAAwD,IAAnBQ,qBAA+D,IAAtBE,kBACvF,MAAM,IAAIoD,MAAM,qDAqClB,MAAMkB,WAMJC,4BAA8B,IAG9BA,sBAAwB,WACxBA,oBAAsB,SACtBA,sBAAwB,QACxBA,qBAAuB,OACvBA,oBAAsB,MAGtBA,SAA6B,UAM7BA,qBAAuBD,YAAWE,IAWlCD,SAA6C,oBAAbE,SAA2B,IAAMA,SAASC,cAAc,UAAY,KAGpGH,SAA6B,KAC7BA,SAA0B,KAG1BA,SAAqB,KAWrB,uBAAOI,CAAiBC,GACtBN,YAAWO,IACXP,YAAWQ,EAAYH,iBAAiBC,EAC1C,CAOA,uBAAOG,GAEL,OADAT,YAAWO,IACJP,YAAWQ,EAAYC,kBAChC,CAkBA,uBAAOC,CAAiBC,GACtBX,YAAWY,EAAiBD,EAE5BX,YAAWa,EAAsB,KACjCb,YAAWc,EAAmB,IAChC,CAYA,uBAAOC,GACL,OAAOf,YAAWY,CACpB,CAQA,gBAAOI,CAAU/C,EAAU,CAAC,QACIgD,IAA1BhD,EAAQiD,eACVlB,WAAWK,iBAAiBpC,EAAQiD,oBAERD,IAA1BhD,EAAQ2C,eACVZ,WAAWU,iBAAiBzC,EAAQ2C,cAExC,CAMA,QAAOL,GACL,IAAIP,YAAWQ,EAAf,CAKA,QAA0B,IAAfW,WACT,MAAM,IAAIrC,MACR,uPAOJkB,YAAWQ,EAAcW,UAZzB,CAaF,CAiBA,QAAOC,CAAsBC,EAAS9E,EAAY+E,EAAUC,EAAWC,GAErE,MAAMC,EAAqB,IAAbH,EAAiB,SAAyB,IAAbA,EAAiB,SAAW,UACjEI,EAAuB,IAAdH,EAAkB,SAA0B,IAAdA,EAAkB,OAAStE,OAAOsE,GAGzEI,EAAa1E,OAAOoE,GACpBO,EAAmBD,EAAWzE,SAAS,KAAOyE,EAAWxE,QAAQ,IAAK,KAAO,GAAGwE,MAGhFE,EAAU5E,OAAOuE,GAIvB,MAAO,WAAWI,KAAoBrF,WAAoBkF,YAAgBC,UAHpDG,EAAQ3E,SAAS,KAAO2E,EAAQ1E,QAAQ,IAAK,KAAO,GAAG0E,OAI/E,CAaA,sBAAOC,CAAgBT,EAAS9E,EAAY+E,EAAUC,EAAWC,EAAMO,GACrE/B,YAAWO,IACX,MAAMyB,EAAehC,YAAWoB,EAAsBC,EAAS9E,EAAY+E,EAAUC,EAAWC,GAChGS,eAAeH,gBAAgBE,EAAcD,EAAe/B,WAC9D,CAYA,oBAAOkC,CAAcb,EAAS9E,EAAY+E,EAAUC,EAAWC,EAAMW,GACnEnC,YAAWO,IACX,MAAMyB,EAAehC,YAAWoB,EAAsBC,EAAS9E,EAAY+E,EAAUC,EAAWC,GAChGS,eAAeC,cAAcF,EAAcG,EAC7C,CA6BA,kBAAOC,CAAYC,EAAMC,EAAgBC,GAMvC,GALKA,IACHA,EAAiB,IAAIvE,gBAIH,IAAhBqE,EAAKG,OACP,MAAO,CACLC,QAAS,CACPC,MAAO,EACPC,sBAAuB,EACvBC,uBAAwB,EACxBC,wBAAyB,EACzBC,yBAA0B,EAC1BC,sBAAuB,EACvBC,uBAAwB,GAE1BnH,OAAQL,gBAKZ,MAAMyH,EAAcC,iBAAiBC,eAAeb,GACpD,IAAKW,EACH,MAAO,CACLR,QAAS,KACT5G,OAAQH,kBAAkBV,WAAWI,aAKzC,MAAMa,EAAe,IAAImH,IACzB,IAAK,MAAM7D,KAAQ8C,EACJ,MAAT9C,GAAiB0D,EAAYtD,SAASJ,IACxCtD,EAAaoH,IAAI9D,GAKrB,GAAItD,EAAauF,KAAO,EACtB,MAAO,CACLiB,QAAS,KACT5G,OAAQH,kBAAkBV,WAAWK,gBAAiB,CACpDY,aAAcA,KAMpB,MAAMqH,EAAQ,IAAIjB,GAClB,IAAIkB,EAAc,EACdrE,EAAmB+D,EAAY3D,oBAAoBgE,EAAM,IAC7D,MAAME,EAA8BtE,EAAiByD,sBACrD,IAEIc,EAFAZ,EAA0B,EAC1BC,EAA2B,EAE3BY,EAAoB,EAExB,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAMd,OAAQmB,IAAK,CACrC,MAAMpE,EAAO+D,EAAMK,GACbC,EAAWN,EAAMK,EAAI,GAE3BzE,EAAmB+D,EAAY3D,oBAAoBC,GAEnDsD,EAA0BgB,KAAKC,IAAIjB,EAAyB3D,EAAiB2D,yBAC7EC,EAA2Be,KAAKE,IAAIjB,EAA0B5D,EAAiB4D,0BAE/EY,EAAoB/G,KAAKqH,2BAA2Bf,EAAaX,EAAgB/C,EAAMqE,EAAUrB,EAAgBrD,GACjHqE,GAAeG,CACjB,CAKA,OAHAD,EAA+BF,EAAcG,EAC7CD,GAAgCvE,EAAiB0D,uBAE1C,CACLH,QAAS,CACPC,MAAOa,EACPZ,sBAAuBa,EACvBZ,uBAAwBa,EACxBZ,0BACAC,2BACAC,sBAAuB7D,EAAiB6D,sBACxCC,uBAAwB9D,EAAiB8D,wBAE3CnH,OAAQL,eAEZ,CAqCA,wBAAOyI,CAAkBC,EAAK7B,EAAM8B,EAASC,EAAS9B,EAAgBC,EAAiB,MACrFA,EAAiBA,GAAkB,IAAIvE,eAGlCgC,YAAWa,IAEdb,YAAWa,EAAsBb,WAAWe,kBAAXf,GACjCA,YAAWc,EAAmBd,YAAWa,EAAoBwD,WAAW,OAI1E,MAAMpB,EAAcC,iBAAiBC,eAAeb,GACpD,IAAKW,EACH,MAAO,CACLqB,UAAU,EACVzI,OAAQH,kBAAkBV,WAAWI,aAKzC,MAAMmJ,EAAsB,IAAInB,IAChC,IAAK,MAAM7D,KAAQ8C,EACJ,MAAT9C,GAAiB0D,EAAYtD,SAASJ,IACxCgF,EAAoBlB,IAAI9D,GAI5B,GAAIgF,EAAoB/C,KAAO,EAC7B,MAAO,CACL8C,UAAU,EACVzI,OAAQH,kBAAkBV,WAAWK,gBAAiB,CACpDY,aAAcsI,KAMpB,MAAMC,EAAYC,eAAeC,aAAapC,GACxCqC,EAAa3E,YAAW4E,EAAcJ,GAGtCrI,EAAoB,IAAIiH,IAC9B,IAAIyB,GAAmB,EASvBX,EAAIY,OACJZ,EAAIa,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,GAGhC,MAAMzB,EAAQ,IAAIjB,GACZhE,EAAYkE,EAAelE,UAK3B2G,EAAY1B,EAAM2B,MAAKC,GAAKjC,EAAYtD,SAASuF,MAAO5B,EAAM,GAC9D6B,EAA8BlC,EAAY3D,oBAAoB0F,GAC9DI,EAAuBD,EACzBnF,YAAWqF,EAAiC9C,EAAepE,aAAcgH,GACzE,EAIJ,IAAIG,EAAwB,EAC5B,GAAiC,SAA7B/C,EAAenE,UAAsB,CACvC,MAAMmH,EAAgBvF,WAAWoC,YAAYC,EAAMC,EAAgBC,GACjC,IAA9BgD,EAAc1J,OAAOJ,MAAc8J,EAAc9C,QAEnD6C,EAAwBtF,YAAWwF,EACjCjD,EAAenE,UACfmH,EAAc9C,QAAQC,OAKxB+C,QAAQC,KAAK,qDAAqDnD,EAAenE,2CAErF,CAGA,MAAMuH,EAAkB,CACtBC,GAAIzB,EAAUmB,GAAyBhD,EAAehG,aACtDuJ,GAAIzB,EAAUgB,GAAwB9C,EAAehG,cAGvD,IAAK,IAAIqH,EAAI,EAAGA,EAAIL,EAAMd,OAAQmB,IAAK,CACrC,MAAMmC,EAAcxC,EAAMK,GACpBC,EAAWN,EAAMK,EAAI,GAGP,MAAhBmC,IACGnB,GAAeH,EAAUuB,eAAeD,KAC3C3J,EAAkBkH,IAAIyC,GACtBjB,GAAmB,IAKvB7E,YAAWgG,EAAe9B,EACxB4B,EACAH,EACAnB,EACAvB,EACA5E,GAGFsH,EAAgBC,GAAK5F,YAAWiG,EAAsChD,EAAaX,EAAgBwD,EAAalC,EAAUrB,EAC5H,CAGA,IAAI2D,EACJ,GAAKvB,EAEE,MAAIxI,EAAkBqF,KAAO,GAKlC,OADA0C,EAAIiC,UACG,CACL7B,UAAU,EACVzI,OAAQL,gBANV0K,EAAalL,WAAWO,aAQ1B,MAVE2K,EAAalL,WAAWM,SAc1B,OADA4I,EAAIiC,UACG,CACL7B,UAAU,EACVzI,OAAQH,kBAAkBwK,EAAY,CACpC/J,kBAAmBA,EAAkBqF,KAAO,EAAIrF,OAAoB8E,EACpE4D,iBAAkBA,IAGxB,CAUA,iCAAOb,CAA2Bf,EAAaX,EAAgB/C,EAAMqE,EAAUrB,EAAgBrD,EAAmB,MAC3GqD,IACHA,EAAiB,IAAIvE,gBAElBkB,IACHA,EAAmB+D,EAAY3D,oBAAoBC,IAErD,IAAI4E,EAAU,EAYd,GAAa,MAAT5E,EAAc,CAChB,MAAM6G,EAAkDnD,EAAYrD,8BAElEuE,GADsD,OAApDiC,EACSA,EAGAlH,EAAiBwD,KAEhC,MAGEyB,GAAWjF,EAAiBwD,MAI9B,IAAI2D,EAAoBrG,YAAWsG,EAAsBrD,EAAa1D,EAAMqE,EAAUrB,GAWtF,OALA4B,GAAW7B,EAAe5F,SAAW2J,EAAoBrG,WAAWuG,qBAK7D1C,KAAK2C,MAAMrC,EACpB,CAEA,QAAOmC,CAAsBrD,EAAa1D,EAAMqE,EAAUrB,GAKxD,OAJKA,IACHA,EAAiB,IAAIvE,gBAGnBuE,EAAerE,kBAAoB0F,EAC9BX,EAAYzD,qBAAqBD,EAAMqE,GAGzC,CACT,CAyBA,QAAOyB,CAAiClH,EAAce,GAGpD,MAAMuH,EAAMvH,EAAiB6D,sBACvB2D,EAAMxH,EAAiB8D,uBACvB2D,EAAKzH,EAAiB0H,gBACtBC,EAAK3H,EAAiB4H,oBAI5B,OAAQ3I,GACN,IAAK,MAGH,OAAOsI,EAAMC,EAEf,IAAK,UAIH,OAAOC,EAAKD,EAEd,IAAK,SAIH,OAAQD,EAAMC,GAAO,EAEvB,IAAK,aAGH,OAAOA,EAET,IAAK,cAMH,OAAOA,EAAMG,EAEf,IAAK,SAEH,OAAO,EAET,QAGE,OADApB,QAAQC,KAAK,qCAAqCvH,mGAC3C,EAEb,CAsBA,QAAOqH,CAAgCpH,EAAW2I,GAEhD,OAAQ3I,GACN,IAAK,OAEH,OAAO,EAET,IAAK,SAGH,OAAQ2I,EAAkB,EAE5B,IAAK,QAGH,OAAQA,EAEV,QAGE,OADAtB,QAAQC,KAAK,kCAAkCtH,+DACxC,EAEb,CAMA,QAAO4H,CAAe9B,EAAK3E,EAAMoG,EAAiBnB,EAAWvB,EAAa5E,GAExE,IAAK2B,YAAW4E,EAAcJ,GAAY,CACxC,MAAMtF,EAAmB+D,EAAY3D,oBAAoBC,GAIzD,YAHIL,GACFc,YAAWgH,EAA0B9C,EAAK3E,EAAMoG,EAAiBzG,EAAkBb,GAGvF,CAIA,GAAIA,IAAc2B,YAAWiH,EAE3B,YADAjH,YAAWkH,EAAqBhD,EAAK3E,EAAMoG,EAAiBnB,EAAWvB,GAQzE,IAAKuB,EAAUuB,eAAexG,GAAO,OAErC,MAAM4H,EAAmB3C,EAAU2C,iBAAiBC,eAAe7H,GAC7D8H,EAAa7C,EAAU6C,WAAWC,MAClCzG,EAAqBb,YAAWuH,EAAoBF,EAAYF,EAAkB9I,GACxF2B,YAAWwH,EAAyBtD,EAAKrD,EAAoB8E,EAAiBwB,EAChF,CAEA,QAAOI,CAAoBF,EAAYF,EAAkB9I,GACvD,MAAMoJ,SAAEA,EAAQC,WAAEA,EAAUC,YAAEA,GAAgBR,EAsB9C,OAnBAnH,YAAWa,EAAoB6B,MAAQgF,EACvC1H,YAAWa,EAAoB+G,OAASD,EACxC3H,YAAWc,EAAiB+G,UAAU,EAAG,EAAGH,EAAYC,GAGxD3H,YAAWc,EAAiBgH,yBAA2B,cACvD9H,YAAWc,EAAiBiH,UAC1BV,EACAI,EAAU,EACVC,EAAYC,EACZ,EAAG,EACHD,EAAYC,GAId3H,YAAWc,EAAiBgH,yBAA2B,YACvD9H,YAAWc,EAAiBkH,UAAY3J,EACxC2B,YAAWc,EAAiBmH,SAAS,EAAG,EAAGP,EAAYC,GAEhD3H,YAAWa,CACpB,CAEA,QAAO2G,CAAyBtD,EAAKrD,EAAoB8E,EAAiBwB,GACxE,MAAMO,WAAEA,EAAUC,YAAEA,EAAWO,GAAEA,EAAEC,GAAEA,GAAOhB,EAM5CjD,EAAI6D,UACFlH,EACA,EAAG,EACH6G,EAAYC,EACZ9D,KAAK2C,MAAMb,EAAgBC,EAAIsC,GAC/BrE,KAAK2C,MAAMb,EAAgBE,EAAIsC,GAC/BT,EAAYC,EAEhB,CAOA,QAAOT,CAAqBhD,EAAK3E,EAAMoG,EAAiBnB,EAAWvB,GACjE,IAAKuB,EAAUuB,eAAexG,GAAO,OAErC,MAAM4H,EAAmB3C,EAAU2C,iBAAiBC,eAAe7H,GAC7D8H,EAAa7C,EAAU6C,WAAWC,OAClCG,SAAEA,EAAQC,WAAEA,EAAUC,YAAEA,EAAWO,GAAEA,EAAEC,GAAEA,GAAOhB,EAMtDjD,EAAI6D,UACFV,EACAI,EAAU,EACVC,EAAYC,EACZ9D,KAAK2C,MAAMb,EAAgBC,EAAIsC,GAC/BrE,KAAK2C,MAAMb,EAAgBE,EAAIsC,GAC/BT,EAAYC,EAEhB,CAEA,QAAOX,CAA0B9C,EAAK3E,EAAMoG,EAAiBzG,EAAkBb,GAC7E,GAAa,MAATkB,EAAc,OAElB,QAA+C0B,IAA3C/B,EAAiByD,4BAC2B1B,IAA5C/B,EAAiB0D,6BAC4B3B,IAA7C/B,EAAiB2D,8BAC6B5B,IAA9C/B,EAAiB4D,yBAEnB,YADA2C,QAAQC,KAAK,+CAA+CnG,MAI9D,MAAMjD,EAAe4C,EAAiB5C,cAAgB,EAShD8L,EAAevE,KAAK2C,MACxBtH,EAAiByD,sBAAwBzD,EAAiB0D,wBACxDtG,EAGE+L,EAAgBxE,KAAK2C,MACzBtH,EAAiB2D,wBAA0B3D,EAAiB4D,0BAC1DxG,EAIEgM,EAAe3C,EAAgBC,EACjC/B,KAAK2C,MAAMtH,EAAiByD,uBAAyBrG,EAQnDiM,EAAe5C,EAAgBE,EACjC3G,EAAiB8D,uBAAyB1G,EAC1C4C,EAAiB2D,wBAA0BvG,EAEzCkM,EAAcnK,GAAa,QAMjC6F,EAAI8D,UAAYQ,EAChBtE,EAAI+D,SACFpE,KAAK2C,MAAM8B,GACXzE,KAAK2C,MAAM+B,GACX1E,KAAK2C,MAAM4B,GACXvE,KAAK2C,MAAM6B,GAEf,CAEA,QAAOpC,CAAsChD,EAAaX,EAAgBwD,EAAalC,EAAUrB,GAC/F,OAAO5F,KAAKqH,2BAA2Bf,EAAaX,EAAgBwD,EAAalC,EAAUrB,GACvFD,EAAehG,YACrB,CAQA,QAAOsI,CAAcJ,GACnB,OAAMA,aAAqBiE,WAGpBjE,EAAUkE,SACnB,CAcA,qBAAaC,CAAStL,EAAUY,EAAU,CAAC,GAEzC,OADA+B,YAAWO,IACJP,YAAWQ,EAAYmI,SAAStL,EAAUY,EAAS+B,WAC5D,CAYA,sBAAa4I,CAAUC,EAAW5K,EAAU,CAAC,GAE3C,OADA+B,YAAWO,IACJP,YAAWQ,EAAYoI,UAAUC,EAAW5K,EAAS+B,WAC9D,CAQA,wBAAa8I,CAAYD,EAAW5K,EAAU,CAAC,GAE7C,OADA+B,YAAWO,IACJP,YAAWQ,EAAYsI,YAAYD,EAAW5K,EAAS+B,WAChE,CAQA,wBAAa+I,CAAYF,EAAW5K,EAAU,CAAC,GAE7C,OADA+B,YAAWO,IACJP,YAAWQ,EAAYuI,YAAYF,EAAW5K,EAAS+B,WAChE,CAYA,mBAAOgJ,CAAa1G,EAAgBkC,GAClCC,eAAeuE,aAAa1G,EAAgBkC,EAC9C,CAQA,mBAAOE,CAAapC,GAClB,OAAOmC,eAAeC,aAAapC,EACrC,CAQA,kBAAO2G,CAAY3G,GACjB,OAAOmC,eAAewE,YAAY3G,EACpC,CAQA,qBAAO4G,CAAe5G,EAAgBW,GACpCC,iBAAiBgG,eAAe5G,EAAgBW,EAClD,CAQA,qBAAOE,CAAeb,GACpB,OAAOY,iBAAiBC,eAAeb,EACzC,CAMA,iBAAO6G,CAAW9L,GAChB,MAAMiF,EAAiBlG,eAAekB,aAAaD,GACnD6F,iBAAiBkG,kBAAkB9G,GACnCmC,eAAewE,YAAY3G,EAC7B,CAMA,kBAAO+G,CAAYR,GACjBA,EAAUS,SAAQC,GAAM5M,KAAKwM,WAAWI,IAC1C,CAMA,oBAAOC,CAAcnM,GACnB,MAAMiF,EAAiBlG,eAAekB,aAAaD,GACnD6F,iBAAiBkG,kBAAkB9G,GACnCmC,eAAewE,YAAY3G,EAC7B,CAMA,kBAAOmH,CAAYpM,GACjB,MAAMiF,EAAiBlG,eAAekB,aAAaD,GACnDoH,eAAewE,YAAY3G,EAC7B,CAKA,qBAAOoH,GACLxG,iBAAiByG,QACjBlF,eAAekF,OACjB,CAKA,uBAAOC,GACLnF,eAAekF,OACjB,CAWA,cAAOE,CAAQxM,GACb,OAAOV,KAAKmN,WAAWzM,IAAaV,KAAKoN,SAAS1M,EACpD,CAOA,iBAAOyM,CAAWzM,GAChB,MAAMiF,EAAiBlG,eAAekB,aAAaD,GACnD,OAAO6F,iBAAiB8G,eAAe1H,EACzC,CAOA,eAAOyH,CAAS1M,GACd,MAAMiF,EAAiBlG,eAAekB,aAAaD,GAC7CmH,EAAYC,eAAeC,aAAapC,GAC9C,OAAOkC,GAAaxE,YAAW4E,EAAcJ,EAC/C,CAMA,qBAAOyF,GACL,MAAMC,EAAS,GACf,IAAK,MAAM9M,KAAO8F,iBAAiBiH,oBAAqB,CACtD,MAAM7H,EAAiBlG,eAAeuB,QAAQP,GACxCoH,EAAYC,eAAeC,aAAapC,GAC1CkC,GAAaxE,YAAW4E,EAAcJ,IACxC0F,EAAOE,KAAK9H,EAAejF,SAE/B,CACA,OAAO6M,CACT,CAMA,uBAAOG,GACL,MAAMH,EAAS,GACf,IAAK,MAAM9M,KAAO8F,iBAAiBiH,oBAAqB,CACtD,MAAM7H,EAAiBlG,eAAeuB,QAAQP,GAC9C8M,EAAOE,KAAK9H,EAAejF,SAC7B,CACA,OAAO6M,CACT,CAMA,uBAAOI,GACL,MAAMJ,EAAS,GACf,IAAK,MAAM9M,KAAOqH,eAAe0F,oBAAqB,CACpD,MAAM7H,EAAiBlG,eAAeuB,QAAQP,GACxCoH,EAAYC,eAAeC,aAAapC,GAC1CtC,YAAW4E,EAAcJ,IAC3B0F,EAAOE,KAAK9H,EAAejF,SAE/B,CACA,OAAO6M,CACT,CAUA,wBAAOK,GACLrH,iBAAiByG,QACjBlF,eAAekF,QAEX1H,eAAeuI,kBACjBvI,eAAeuI,iBAAiBb,QAE9B1H,eAAewI,qBACjBxI,eAAewI,mBAAqB,CAAC,GAEnCxI,eAAeyI,iBACjBzI,eAAeyI,gBAAgBf,QAG7B1H,eAAe5B,kBACjB4B,eAAe5B,iBAAiB,MAElCL,YAAWa,EAAsB,KACjCb,YAAWc,EAAmB,KAC9Bd,YAAWY,EAAiB,KAC5BZ,YAAWQ,EAAc,IAC3B,CAgBA,QAAON,GACL,MAAMoD,EAAQ,GAId,IAAK,IAAIK,EAAI,GAAIA,GAAK,IAAKA,IACzBL,EAAM8G,KAAKnN,OAAO0N,aAAahH,IAWjC,MAAMiH,EAAuB,CAC3B,KAIA,KAIA,KAEA,KAEA,IAIA,KAIA,KAEA,KAEA,KACA,IACA,KACA,IACA,IACA,KAGF,IAAK,MAAMnP,KAAQmP,EACjBtH,EAAM8G,KAAKnN,OAAO0N,aAAalP,IAMjC,IAAK,IAAIkI,EAAI,IAAKA,GAAK,IAAKA,IAChB,MAANA,GACFL,EAAM8G,KAAKnN,OAAO0N,aAAahH,IAQnC,OAHAL,EAAM8G,KAAK,KAGJ9G,EAAMuH,OAAO3O,KAAK,GAC3B,EAIF8D,WAAW8K,EAAI9K,WAAW8B,gBAC1B9B,WAAW+K,EAAI/K,WAAWkC,cAU1B,MAAM8I,gBAEJ,WAAA3O,GACE,MAAM,IAAIyC,MAAM,8DAClB,CASA,QAAOmM,CAAuBC,GAG5B,IAAIC,EAEJ,GAAsB,oBAAXC,OAETD,EAAQC,OAAOC,KAAKH,EAAQ,cACvB,CAEL,MAAMI,EAASC,KAAKL,GACpBC,EAAQ,IAAIK,WAAWF,EAAO9I,QAC9B,IAAK,IAAImB,EAAI,EAAGA,EAAI2H,EAAO9I,OAAQmB,IACjCwH,EAAMxH,GAAK2H,EAAOG,WAAW9H,EAEjC,CAEA,OAAO+H,MAAML,KAAKF,EACpB,CASA,QAAOQ,CAAeT,GACpB,MAAMC,EAAQxO,MAAKsO,EAAuBC,GACpCU,EAAW,GACjB,IAAIjI,EAAI,EAER,KAAOA,EAAIwH,EAAM3I,QAAQ,CAEvB,IAEIqJ,EAFAC,EAAQ,EACRC,EAAQ,EAGZ,GACEF,EAAOV,EAAMxH,KACbmI,IAAiB,IAAPD,IAAgBE,EAC1BA,GAAS,QACK,IAAPF,GAIT,MAAMG,EAAkB,EAARF,IAAeA,EAAQ,GAAK,EAAIA,EAAQ,EACxDF,EAASxB,KAAK4B,EAChB,CAEA,OAAOJ,CACT,CAaA,QAAOK,CAAsBf,GAE3B,MAAMgB,EAASvP,MAAKgP,EAAeT,GAG7BiB,EAAS,CAACD,EAAO,IACvB,IAAK,IAAIvI,EAAI,EAAGA,EAAIuI,EAAO1J,OAAQmB,IACjCwI,EAAO/B,KAAK+B,EAAOxI,EAAI,GAAKuI,EAAOvI,IAKrC,OAAOwI,CACT,CAWA,aAAOC,CAAOC,GAEZ,QAA2B,IAAhBzN,YACT,MAAM,IAAIE,MAAM,iGAIlB,IAAK4M,MAAMY,QAAQD,IAAiC,IAApBA,EAAS7J,OACvC,MAAM,IAAI1D,MACR,4DAAgF,iBAAbuN,EAAwB,eAAiBA,UAAiBA,GAAU7J,QAAU,wEAMrJ,IAAK+J,EAAIC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GAAMT,EAMjC,GAHAE,EAAK5P,MAAKoQ,EAAyBR,GAGlB,iBAANG,EAETA,EAAI/P,MAAKsP,EAAsBS,GAC/BA,EAAI/P,MAAKoQ,EAAyBL,OAC7B,KAAIhB,MAAMY,QAAQI,GAIvB,MAAM,IAAI5N,MAAM,0DAFhB4N,EAAI/P,MAAKoQ,EAAyBL,EAGpC,CAGAD,EAAI9P,MAAKqQ,EAAmBP,GAK5BE,EAAIhQ,MAAKgP,EAAegB,GACxBC,EAAIjQ,MAAKsO,EAAuB2B,GAGhCD,EAAIhQ,MAAKsQ,EAAkBN,GAE3B,MAAMO,EAAe,CACnBlO,aAAcrC,MAAKwQ,EAAoBX,EAAGD,GAC1CrN,iBAAkBvC,MAAKyQ,EAAwBR,EAAGH,EAAGC,EAAGC,EAAGG,GAC3D1N,0CAA2CyN,GAIvC7H,EAAY/J,OAAO8E,KAAKmN,EAAahO,kBAAkB,GACvD5C,EAAe4Q,EAAahO,iBAAiB8F,IAAY1I,aAG/D,OAFAmJ,QAAQ4H,MAAM,6CAA6C/Q,SAAoBrB,OAAO8E,KAAKmN,EAAahO,kBAAkBsD,qBAEnH,IAAI5D,YAAYsO,EACzB,CAeA,QAAOC,CAAoBd,EAAUiB,GAEnC,MAAMC,EAAe5Q,MAAK6Q,EAAgBnB,GAGpCoB,EAAgB,CAAC,EACvB,IAAK,MAAOhO,EAAUiO,KAAUzS,OAAO0S,QAAQJ,GAC7CE,EAAchO,GAAY9C,MAAKiR,EAAoBF,GAIrD,MAAMG,EAAW,CAAC,EAClB,IAAK,MAAOpO,EAAUiO,KAAUzS,OAAO0S,QAAQF,GAAgB,CAC7DI,EAASpO,GAAY,CAAC,EACtB,IAAK,MAAOC,EAAWoO,KAAU7S,OAAO0S,QAAQD,GAC9CG,EAASpO,GAAUC,GAAa4N,EAAmBQ,EAEvD,CAEA,OAAOD,CACT,CAWA,QAAOL,CAAgBnB,GACrB,MAAMwB,EAAW,CAAC,EAGlB,IAAK,MAAOzQ,EAAK2Q,KAAiB9S,OAAO0S,QAAQtB,GAAW,CAC1D,GAAIjP,EAAIF,SAAS,MAAQE,EAAIoF,QAAU,EAAG,CAExC,MAAMwL,EAAc5Q,EAAI6Q,QAAQ,KAC1BC,EAAY9Q,EAAI+Q,UAAU,EAAGH,GAC7BI,EAAUhR,EAAI+Q,UAAUH,EAAc,GAG5C,GAAyB,IAArBE,EAAU1L,QAAmC,IAAnB4L,EAAQ5L,OAAc,CAClD,MAAM6L,EAAarO,WAAWsO,cAAcL,QAAQC,GAC9CK,EAAWvO,WAAWsO,cAAcL,QAAQG,GAElD,IAAoB,IAAhBC,IAAmC,IAAdE,GAAmBF,GAAcE,EAAU,CAElE,IAAK,IAAI5K,EAAI0K,EAAY1K,GAAK4K,EAAU5K,IACtCkK,EAAS7N,WAAWsO,cAAc3K,IAAMoK,EAE1C,QACF,CACF,CACF,CAGAF,EAASzQ,GAAO2Q,CAClB,CAEA,OAAOF,CACT,CAgBA,QAAOD,CAAoBF,GACzB,MAAMG,EAAW,CAAC,EAGlB,IAAK,MAAOzQ,EAAK0O,KAAU7Q,OAAO0S,QAAQD,GAAQ,CAEhD,MAAMpK,EAAQ3G,MAAK6R,EAAwBpR,GAG3C,IAAK,MAAMmC,KAAQ+D,EACjBuK,EAAStO,GAAQuM,CAErB,CAEA,OAAO+B,CACT,CAgBA,QAAOW,CAAwBC,GAC7B,MAAMnL,EAAQ,GACd,IAAIK,EAAI,EASR,IANsB,MAAlB8K,EAAW,KACbnL,EAAM8G,KAAK,KACXzG,EAAI,GAICA,EAAI8K,EAAWjM,QAAQ,CAC5B,MAAMsD,EAAc2I,EAAW9K,GAG/B,GAAIA,EAAI,EAAI8K,EAAWjM,QAAgC,MAAtBiM,EAAW9K,EAAI,GAAY,CAE1D,MAAMuK,EAAYpI,EACZsI,EAAUK,EAAW9K,EAAI,GAGzB0K,EAAarO,WAAWsO,cAAcL,QAAQC,GAC9CK,EAAWvO,WAAWsO,cAAcL,QAAQG,GAElD,IAAoB,IAAhBC,IAAmC,IAAdE,GAAmBF,EAAaE,EAAU,CAEjE,IAAK,IAAIG,EAAIL,EAAYK,GAAKH,EAAUG,IACtCpL,EAAM8G,KAAKpK,WAAWsO,cAAcI,IAEtC/K,GAAK,CACP,MAEEL,EAAM8G,KAAKtE,GACXnC,GAEJ,MAEEL,EAAM8G,KAAKtE,GACXnC,GAEJ,CAEA,OAAOL,CACT,CAyBA,QAAO8J,CAAwBuB,EAAeC,EAA8BC,EAAaC,EAAcC,GACrG,MAAMlB,EAAW,CAAC,EA+FlB,OA5FcnC,MAAML,KAAKrL,WAAWsO,eAG9BhF,SAAQ,CAAC/J,EAAMuO,KAEnB,MAAMkB,EAAcL,EAAcb,GAC5BmB,EAAaH,EAAaE,GAEhC,IAAIE,EAGJ,GAA0B,IAAtBD,EAAWzM,OAAc,CAG3B,QAAwBvB,IAApB8N,EACF,MAAM,IAAIjQ,MAER,yEAAcS,eAAkBuO,OAAWmB,EAAW/S,KAAK,uFAI/DgT,EAAU,CACRD,EAAW,GACXF,EACAE,EAAW,GACXA,EAAW,GACXF,EAEJ,MACK,GAA0B,IAAtBE,EAAWzM,OAGlB0M,EAAU,CACRD,EAAW,GACXA,EAAW,GACXA,EAAW,GACXA,EAAW,GACXA,EAAW,SAGV,GAA0B,IAAtBA,EAAWzM,OAGlB0M,EAAU,CACRD,EAAW,GACXA,EAAW,GACXA,EAAW,GACXA,EAAW,GACXA,EAAW,QAGV,IAA0B,IAAtBA,EAAWzM,OAKlB,MAAM,IAAI1D,MACR,8CAA8CS,eAAkBuO,4CACxBmB,EAAWzM,YAAYyM,EAAW/S,KAAK,+EALjFgT,EAAUD,CAQZ,CAGA,MAAMvM,EAAQmM,EAAYK,EAAQ,IAC5BvM,EAAwBkM,EAAYK,EAAQ,IAC5CtM,EAAyBiM,EAAYK,EAAQ,IAC7CrM,EAA0BgM,EAAYK,EAAQ,IAC9CpM,EAA2B+L,EAAYK,EAAQ,IAErDrB,EAAStO,GAAQ,CAEfmD,QACAC,wBACAC,yBACAC,0BACAC,2BAMAC,sBAAuB6L,EAA6BnI,IACpDzD,uBAAwB4L,EAA6BlI,IACrDyI,eAAgBP,EAA6BnI,IAC7C2I,gBAAiBR,EAA6BlI,IAC9CE,gBAAiBgI,EAA6BjI,GAC9C0I,mBAAoBT,EAA6BU,GACjDxI,oBAAqB8H,EAA6B/H,GAClDvK,aAAcsS,EAA6BW,GAC5C,IAEI1B,CACT,CAUA,QAAOd,CAAyBnB,GAC9B,OAAOA,EAAS4D,KAAIC,GAAOA,EAAM,KACnC,CAUA,QAAOzC,CAAmB0C,GACxB,IAAKhE,MAAMY,QAAQoD,IAA2C,IAAzBA,EAAclN,OACjD,MAAM,IAAI1D,MACR,qDAAqD4Q,GAAelN,iFAMxE,MAAO,CACLiE,IAAKiJ,EAAc,GACnBhJ,IAAKgJ,EAAc,GACnB/I,GAAI+I,EAAc,GAClBJ,GAAII,EAAc,GAClB7I,GAAI6I,EAAc,GAClBH,GAAIG,EAAc,GAEtB,CAgBA,QAAOzC,CAAkB0C,GACvB,MAAMC,EAAU,GAChB,IAAIC,EAAgB,GAEpB,IAAK,IAAIlM,EAAI,EAAGA,EAAIgM,EAAUnN,OAAQmB,IAAK,CACzC,MAAMmI,EAAQ6D,EAAUhM,GAExB,GAAImI,EAAQ,EAAG,CAMb,GAHA+D,EAAczF,MAAO0B,EAAS,GAG1B+D,EAAcrN,OAAS,GAAKqN,EAAcrN,OAAS,EACrD,MAAM,IAAI1D,MACR,yBAAyB+Q,EAAcrN,sBAAsBmB,qGAMjEiM,EAAQxF,KAAKyF,GACbA,EAAgB,EAClB,MAEEA,EAAczF,KAAK0B,EAAQ,EAE/B,CAGA,GAAI+D,EAAcrN,OAAS,EACzB,MAAM,IAAI1D,MAER,4CAAS+Q,EAAcrN,qHAK3B,OAAOoN,CACT,EAiCF,MAAME,iBACJ,WAAAzT,CAAYwC,EAAMZ,EAAU,CAAC,GAE3B,IAAKY,GAAwB,iBAATA,EAClB,MAAM,IAAIC,MAAM,qDAIlBnC,KAAKoT,YAAclR,EAAK6I,YAAc,CAAC,EACvC/K,KAAKqT,aAAenR,EAAK8I,aAAe,CAAC,EACzChL,KAAKsT,IAAMpR,EAAKqJ,IAAM,CAAC,EACvBvL,KAAKuT,IAAMrR,EAAKsJ,IAAM,CAAC,EAIvBxL,KAAKwT,UAAYtR,EAAK4I,UAAY,CAAC,EAI9BxJ,EAAQoB,UACXpE,OAAOC,OAAOyB,KAAKoT,aACnB9U,OAAOC,OAAOyB,KAAKqT,cACnB/U,OAAOC,OAAOyB,KAAKsT,KACnBhV,OAAOC,OAAOyB,KAAKuT,KACnBjV,OAAOC,OAAOyB,KAAKwT,WACnBlV,OAAOC,OAAOyB,MAElB,CAOA,cAAAyK,CAAe7H,GACb,MAAO,CACLkI,SAAU9K,KAAKwT,UAAU5Q,GACzBmI,WAAY/K,KAAKoT,YAAYxQ,GAC7BoI,YAAahL,KAAKqT,aAAazQ,GAC/B2I,GAAIvL,KAAKsT,IAAI1Q,GACb4I,GAAIxL,KAAKuT,IAAI3Q,GAEjB,CAOA,cAAAwG,CAAexG,GACb,YAAgC0B,IAAzBtE,KAAKwT,UAAU5Q,SACY0B,IAA3BtE,KAAKoT,YAAYxQ,SACW0B,IAA5BtE,KAAKqT,aAAazQ,EAC3B,CAOA,gBAAA6Q,CAAiB7Q,GACf,YAAgC0B,IAAzBtE,KAAKwT,UAAU5Q,EACxB,CAMA,sBAAAO,GACE,OAAO7E,OAAO8E,KAAKpD,KAAKwT,UAC1B,CAOA,aAAAE,CAAc9Q,GACZ,OAAO5C,KAAKoT,YAAYxQ,EAC1B,CAOA,cAAA+Q,CAAe/Q,GACb,OAAO5C,KAAKqT,aAAazQ,EAC3B,CAOA,WAAAgR,CAAYhR,GACV,OAAO5C,KAAKwT,UAAU5Q,EACxB,CAOA,KAAAiR,CAAMjR,GACJ,OAAO5C,KAAKsT,IAAI1Q,EAClB,CAOA,KAAAkR,CAAMlR,GACJ,OAAO5C,KAAKuT,IAAI3Q,EAClB,CAOA,OAAAmR,GAEE,MAAMpN,EAAQ3G,KAAKmD,yBAAyB+K,OAGtCtN,EAAQ,GACd,IAAK,MAAMgC,KAAQ+D,EAAO,CACxB,MAAMqN,EAAMhU,KAAKyK,eAAe7H,GAEhChC,EAAM6M,KACJ,GAAG7K,MACCoR,EAAIjJ,cACJiJ,EAAIhJ,eACJgJ,EAAIzI,MACJyI,EAAIxI,MACJwI,EAAIlJ,WAEZ,CAGA,MAAMzK,EAAMO,EAAMrB,KAAK,KACvB,IAAI0U,EAAO,WACX,IAAK,IAAIjN,EAAI,EAAGA,EAAI3G,EAAIwF,OAAQmB,IAC9BiN,GAAQ5T,EAAIyO,WAAW9H,GACvBiN,IAASA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAI3E,OAAQA,IAAS,GAAGC,SAAS,IAAI1C,UAAU,EAAG,GAAG2C,SAAS,EAAG,IAC/D,EA+BF,MAAMC,WACJ,WAAA1U,CAAYiL,EAAOrJ,EAAU,CAAC,GAE5B,IAAKqJ,EACH,MAAM,IAAIxI,MAAM,mEAGlB,GAAqB,iBAAVwI,QAAuCrG,IAAhBqG,EAAM5E,YAA8CzB,IAAvBqG,EAAM0J,aACnE,MAAM,IAAIlS,MAAM,+EAIlBnC,KAAK2K,MAAQA,EAIRrJ,EAAQoB,SACXpE,OAAOC,OAAOyB,KAElB,CAMA,SAAI+F,GAEF,OAAO/F,KAAK2K,MAAM0J,cAAgBrU,KAAK2K,MAAM5E,OAAS,CACxD,CAMA,UAAIkF,GAEF,OAAOjL,KAAK2K,MAAM2J,eAAiBtU,KAAK2K,MAAMM,QAAU,CAC1D,CAMA,OAAAc,GACE,OAAO/L,KAAK2K,OACiB,iBAAf3K,KAAK2K,OACZ3K,KAAK+F,MAAQ,GACb/F,KAAKiL,OAAS,CACvB,CAMA,SAAAsJ,GACE,QAAKvU,KAAK+L,cAGN/L,KAAK2K,iBAAiB6J,QACjBxU,KAAK2K,MAAM8J,UAAYzU,KAAK2K,MAAM0J,aAAe,EAK5D,CAMA,YAAAK,GACE,OAAI1U,KAAK2K,iBAAiBgK,mBACM,oBAApBC,iBAAmC5U,KAAK2K,iBAAiBiK,gBAC5D,SAEL5U,KAAK2K,iBAAiB6J,OAASxU,KAAK2K,iBAAiBkK,iBAChD,QAEF,SACT,CAOA,UAAAnN,CAAWoN,EAAc,MACvB,MAA4B,WAAxB9U,KAAK0U,eACA1U,KAAK2K,MAAMjD,WAAWoN,GAExB,IACT,CAOA,MAAA3T,CAAOC,GACL,OAAMA,aAAiBgT,YAChBpU,KAAK2K,QAAUvJ,EAAMuJ,KAC9B,CAMA,YAAAoK,GACE,MAAO,CACLC,KAAMhV,KAAK0U,eACX3O,MAAO/F,KAAK+F,MACZkF,OAAQjL,KAAKiL,OACbc,QAAS/L,KAAK+L,UACdwI,UAAWvU,KAAKuU,YAEpB,EA6BF,MAAMzI,UACJ,WAAApM,CAAYgL,EAAYF,GAEtB,KAAME,aAAsB0J,YAC1B,MAAM,IAAIjS,MAAM,6EAIlB,GAAIqI,KAAsBA,aAA4B2I,kBACpD,MAAM,IAAIhR,MAAM,yFAIlBnC,KAAK0K,WAAaA,EAGlB1K,KAAKwK,iBAAmBA,EAGxBlM,OAAOC,OAAOyB,KAChB,CAUA,cAAAoJ,CAAexG,GACb,QAAK5C,KAAKwK,kBAGHxK,KAAKwK,iBAAiBpB,eAAexG,EAC9C,CAMA,OAAAmJ,GACE,OAAO/L,KAAK0K,YAAYqB,SAC1B,CAMA,sBAAA5I,GACE,OAAKnD,KAAKwK,iBAGHxK,KAAKwK,iBAAiBrH,yBAHM,EAIrC,CAMA,SAAI4C,GACF,OAAO/F,KAAK0K,WAAW3E,KACzB,CAMA,UAAIkF,GACF,OAAOjL,KAAK0K,WAAWO,MACzB,CAMA,SAAAsJ,GACE,OAAOvU,KAAK0K,YAAY6J,WAC1B,CAOA,MAAApT,CAAOC,GACL,OAAMA,aAAiB0K,WAChB9L,KAAK0K,WAAWvJ,OAAOC,EAAMsJ,aAC7B1K,KAAKwK,mBAAqBpJ,EAAMoJ,gBACzC,CAMA,YAAAuK,GACE,MAAO,CACLrK,WAAY1K,KAAK0K,WAAa1K,KAAK0K,WAAWqK,eAAiB,KAC/DvK,iBAAkBxK,KAAKwK,iBAAmB,CACxCyK,oBAAqBjV,KAAKwK,iBAAiBrH,yBAAyB0C,OACpEqP,WAAYlV,KAAKwK,iBAAiBrH,yBAAyBgS,MAAM,EAAG,KAClE,KACJpJ,QAAS/L,KAAK+L,UACdwI,UAAWvU,KAAKuU,YAEpB,EAqBF,MAAMa,yBAEJ,WAAA1V,GACE,MAAM,IAAIyC,MAAM,uEAClB,CASA,mBAAOkT,CAAa1K,GAElB,MAAM2K,EAAc3K,GAAOA,MAAQA,EAAMA,MAAQA,EAEjD,IAAK2K,EACH,MAAM,IAAInT,MAAM,0DAIlB,GAAImT,EAAY5N,WAEd,OADY4N,EAAY5N,WAAW,MACxB2N,aAAa,EAAG,EAAGC,EAAYvP,MAAOuP,EAAYrK,QAI/D,QAAiC3G,IAA7BgR,EAAYjB,mBAAoD/P,IAAtBgR,EAAYvP,MAAqB,CAE7E,MAAMwP,EAASlS,WAAWe,kBAAXf,GACfkS,EAAOxP,MAAQuP,EAAYjB,cAAgBiB,EAAYvP,MACvDwP,EAAOtK,OAASqK,EAAYhB,eAAiBgB,EAAYrK,OACzD,MAAM1D,EAAMgO,EAAO7N,WAAW,MAE9B,OADAH,EAAI6D,UAAUkK,EAAa,EAAG,GACvB/N,EAAI8N,aAAa,EAAG,EAAGE,EAAOxP,MAAOwP,EAAOtK,OACrD,CAEA,MAAM,IAAI9I,MAAM,8DAClB,EAgBF,MAAMqT,oBAEJ,WAAA9V,GACE,MAAM,IAAIyC,MAAM,kEAClB,CAQA,eAAOsT,CAASC,GACd,OAAOxO,KAAK2C,MACV6L,EAAY1P,sBACZ0P,EAAYzP,uBAEhB,CAQA,gBAAO0P,CAAUD,GACf,OAAOxO,KAAK2C,MACV6L,EAAYtP,sBACZsP,EAAYrP,uBAEhB,CAOA,oBAAOuP,CAAcF,GACnB,MAAO,CACL3P,MAAO/F,KAAKyV,SAASC,GACrBzK,OAAQjL,KAAK2V,UAAUD,GAE3B,EA6BF,MAAMG,wBAEJ,WAAAnW,GACE,MAAM,IAAIyC,MAAM,sEAClB,CAWA,2BAAO2T,CAAqBxP,EAAaoE,GAEvC,MAAMqL,EAAYX,yBAAyBC,aAAa3K,GAIlDwK,EAAa5O,EAAYnD,yBAAyB+K,OAExD,GAA0B,IAAtBgH,EAAWrP,OACb,MAAM,IAAI1D,MAAM,+DAGlB2G,QAAQ4H,MAAM,uCAAuCwE,EAAWrP,qBAMhE,MAAMwC,EAAY6M,EAAW,GACvBc,EAAe1P,EAAY3D,oBAAoB0F,GAI/C4N,EAAeT,oBAAoBG,UAAUK,GAC7CrW,EAAeqW,EAAarW,cAAgB,EAC5CuW,EAAoBhP,KAAK2C,MAAMoM,EAAetW,GAEpDmJ,QAAQ4H,MAAM,4CAA4C/Q,mBAA8BsW,wBAAmCC,KAG3H,IAAIC,EAAe,EACnB,MAAMC,EAAc,CAAC,EACfC,EAAgB,GAEtB,IAAK,MAAMzT,KAAQsS,EAAY,CAC7B,MAAMQ,EAAcpP,EAAY3D,oBAAoBC,GAG9CgE,EAAc4O,oBAAoBC,SAASC,GAC3CY,EAAmBpP,KAAK2C,MAAMjD,EAAcjH,GAG9C0W,EAAcxQ,OAAS,GACzBwQ,EAAc5I,KAAK,GAAG7K,SAAYgE,UAAoB0P,OAAsBH,KAI9E,MAAMI,EAASvW,KAAKwW,gBAClBT,EACAI,EACA,EACAG,EACAJ,GAGEK,IACFH,EAAYxT,GAAQ2T,GAGtBJ,GAAgBG,CAClB,CAKA,OAHAxN,QAAQ4H,MAAM,iCAAiC2F,EAAc9W,KAAK,SAG3DS,KAAKyW,eACVnQ,EACA8P,EACAlB,EACAxK,EACA/K,EACAuW,EAEJ,CAaA,sBAAOM,CAAgBT,EAAWI,EAAcO,EAAcJ,EAAkBJ,GAC9E,MAAMS,EAASZ,EAAU7T,KAKnB0U,EAA6B,EAJTb,EAAUhQ,MAK9B8Q,EAAW,CAAC5N,EAAGC,IAAMyN,EAAOzN,EAAI0N,GAAU3N,GAAK,GAAK,GAI1D,IAAI6N,GAAiB,EACrB,IAAK,IAAI5N,EAAIwN,EAAeR,EAAoB,EAAGhN,GAAKwN,IAAmC,IAAnBI,EAAsB5N,IAC5F,IAAK,IAAID,EAAIkN,EAAclN,EAAIkN,EAAeG,IAAuC,IAAnBQ,EAAsB7N,IAClF4N,EAAS5N,EAAGC,GAAK,IACnB4N,EAAgB5N,GAMtB,IAAuB,IAAnB4N,EAAsB,OAAO,KAIjC,IAAIC,EAAaL,EACjB,IAAK,IAAIxN,EAAIwN,EAAcxN,GAAK4N,EAAe5N,IAAK,CAClD,IAAI8N,GAAQ,EACZ,IAAK,IAAI/N,EAAIkN,EAAclN,EAAIkN,EAAeG,EAAkBrN,IAC9D,GAAI4N,EAAS5N,EAAGC,GAAK,EAAG,CACtB6N,EAAa7N,EACb8N,GAAQ,EACR,KACF,CAEF,GAAIA,EAAO,KACb,CAIA,IAAIC,EAAcd,EAClB,IAAK,IAAIlN,EAAIkN,EAAclN,EAAIkN,EAAeG,EAAkBrN,IAAK,CACnE,IAAI+N,GAAQ,EACZ,IAAK,IAAI9N,EAAI6N,EAAY7N,GAAK4N,EAAe5N,IAC3C,GAAI2N,EAAS5N,EAAGC,GAAK,EAAG,CACtB+N,EAAchO,EACd+N,GAAQ,EACR,KACF,CAEF,GAAIA,EAAO,KACb,CAIA,IAAIE,EAAef,EAAeG,EAAmB,EACrD,IAAK,IAAIrN,EAAIkN,EAAeG,EAAmB,EAAGrN,GAAKkN,EAAclN,IAAK,CACxE,IAAI+N,GAAQ,EACZ,IAAK,IAAI9N,EAAI6N,EAAY7N,GAAK4N,EAAe5N,IAC3C,GAAI2N,EAAS5N,EAAGC,GAAK,EAAG,CACtBgO,EAAejO,EACf+N,GAAQ,EACR,KACF,CAEF,GAAIA,EAAO,KACb,CAGA,MAAO,CACLG,KAAMF,EAAcd,EACpBiB,IAAKL,EAAaL,EAClB3Q,MAAOmR,EAAeD,EAAc,EACpChM,OAAQ6L,EAAgBC,EAAa,EAEzC,CAeA,qBAAON,CAAenQ,EAAa8P,EAAalB,EAAYmC,EAAkB1X,EAAcuW,GAE1F,IAAIoB,EAAoB,EACpBC,EAAmB,EAEvB,IAAK,MAAM3U,KAAQsS,EACbkB,EAAYxT,KACd0U,GAAqBlB,EAAYxT,GAAMmD,MACvCwR,EAAmBrQ,KAAKC,IAAIoQ,EAAkBnB,EAAYxT,GAAMqI,SAKpE,MAAMuM,EAAcnU,WAAWe,kBAAXf,GACpBmU,EAAYzR,MAAQuR,EACpBE,EAAYvM,OAASsM,EACrB,MAAMhQ,EAAMiQ,EAAY9P,WAAW,MAGnC,IAAI+P,EAAuB,EAC3B,MAAMC,EAAc,CAClB3M,WAAY,CAAC,EACbC,YAAa,CAAC,EACdO,GAAI,CAAC,EACLC,GAAI,CAAC,EACLV,SAAU,CAAC,GAIb,IAAIqL,EAAe,EAEnB,IAAK,MAAMvT,KAAQsS,EAAY,CAC7B,MAAMQ,EAAcpP,EAAY3D,oBAAoBC,GAI9CgE,EAAc4O,oBAAoBC,SAASC,GAC3CY,EAAmBpP,KAAK2C,MAAMjD,EAAcjH,GAG5C4W,EAASH,EAAYxT,GAC3B,IAAK2T,EAAQ,CAEXJ,GAAgBG,EAChB,QACF,CAGA,MAAMqB,EAAatU,WAAWe,kBAAXf,GACnBsU,EAAW5R,MAAQwQ,EAAOxQ,MAC1B4R,EAAW1M,OAASsL,EAAOtL,OAC3B,MAAM2M,EAAUD,EAAWjQ,WAAW,MAGhCmQ,EAAc3Q,KAAK4Q,MAAM3B,EAAeI,EAAOY,MAC/CY,EAAc7Q,KAAK4Q,MAAMvB,EAAOa,KAChCY,EAAkB9Q,KAAK4Q,MAAMvB,EAAOxQ,OACpCkS,EAAmB/Q,KAAK4Q,MAAMvB,EAAOtL,QAE3C2M,EAAQxM,UACNiM,EACAQ,EAAaE,EACbC,EAAiBC,EACjB,EAAG,EACHD,EAAiBC,GAInB1Q,EAAI6D,UAAUuM,EAAYF,EAAsB,GA6ChD,MAAMS,EACJhC,GAAqBK,EAAOa,IAAMb,EAAOtL,OAAS,GAAK,EAGzDyM,EAAY3M,WAAWnI,GAAQ2T,EAAOxQ,MACtC2R,EAAY1M,YAAYpI,GAAQ2T,EAAOtL,OACvCyM,EAAY5M,SAASlI,GAAQ6U,EAG7BC,EAAYnM,GAAG3I,IACXsE,KAAK2C,MAAM6L,EAAY1P,uBAAyBrG,EAChD4W,EAAOY,KAGXO,EAAYlM,GAAG5I,IACX2T,EAAOtL,OACPiN,EACA,EAAIvY,EAER8X,GAAwBlB,EAAOxQ,MAC/BoQ,GAAgBG,CAClB,CAGA,MAAM6B,EAAkB,IAAI/D,WAAWoD,GACjChN,EAAmB,IAAI2I,iBAAiBuE,GAI9C,OAFA5O,QAAQ4H,MAAM,mCAAmCpS,OAAO8E,KAAKsU,EAAY5M,UAAUjF,sBAAsByR,KAAqBC,WAEvH,CAAE7M,WAAYyN,EAAiB3N,mBACxC,EAgCF,MAAM1C,eAGJxE,SAAkB,IAAI8U,IAEtB,mBAAOrQ,CAAapC,GAClB,OAAOmC,gBAAeuQ,EAASC,IAAI3S,EAAelF,IACpD,CAEA,mBAAO4L,CAAa1G,EAAgBkC,GAElC,KAAMA,aAAqBiE,WACzB,MAAM,IAAI3J,MAAM,4EAElB2F,gBAAeuQ,EAASE,IAAI5S,EAAelF,IAAKoH,EAClD,CAGA,mBAAOI,CAAauQ,GAElB,OAAMA,aAAiB1M,WAGhB0M,EAAMzM,SACf,CAGA,wBAAOyB,GACL,OAAOuB,MAAML,KAAK5G,gBAAeuQ,EAASjV,OAC5C,CAGA,eAAOgK,CAASzH,GACd,OAAOmC,gBAAeuQ,EAASI,IAAI9S,EAAelF,IACpD,CAGA,kBAAO6L,CAAY3G,GACjB,OAAOmC,gBAAeuQ,EAASK,OAAO/S,EAAelF,IACvD,CAGA,YAAOuM,GACLlF,gBAAeuQ,EAASrL,OAC1B,CAGA,WAAOnI,GACL,OAAOiD,gBAAeuQ,EAASxT,IACjC,EAgCF,MAAM0B,iBAGJjD,SAAsB,IAAI8U,IAO1B,qBAAO5R,CAAeb,GACpB,OAAOY,kBAAiBD,EAAagS,IAAI3S,EAAelF,IAC1D,CAOA,qBAAO8L,CAAe5G,EAAgBW,GACpCC,kBAAiBD,EAAaiS,IAAI5S,EAAelF,IAAK6F,EACxD,CAOA,qBAAO+G,CAAe1H,GACpB,OAAOY,kBAAiBD,EAAamS,IAAI9S,EAAelF,IAC1D,CAOA,wBAAOgM,CAAkB9G,GACvB,OAAOY,kBAAiBD,EAAaoS,OAAO/S,EAAelF,IAC7D,CAMA,wBAAO+M,GACL,OAAOuB,MAAML,KAAKnI,kBAAiBD,EAAalD,OAClD,CAKA,YAAO4J,GACLzG,kBAAiBD,EAAa0G,OAChC,CAMA,WAAOnI,GACL,OAAO0B,kBAAiBD,EAAazB,IACvC,EA0BF,MAAM8T,aAEJrV,SAAkB,GAIlB,iBAAOsV,CAAWC,GAEhB,MAAMC,EAAW/J,MAAMY,QAAQkJ,GAAOA,EAAM,CAACA,GAG7C,IAAK,MAAMjM,KAAMkM,EACG,iBAAPlM,GAAoB5M,MAAK+Y,EAASxY,SAASqM,IACpD5M,MAAK+Y,EAAStL,KAAKb,EAGzB,CAIA,iBAAOoM,GACL,MAAO,IAAIhZ,MAAK+Y,EAClB,CAGA,gBAAOE,CAAUrM,GACf,OAAO5M,MAAK+Y,EAASxY,SAASqM,EAChC,CAGA,YAAOsM,GACL,OAAOlZ,MAAK+Y,EAASlT,MACvB,CAIA,YAAOmH,GACLhN,MAAK+Y,EAASlT,OAAS,CACzB,CAIA,uBAAOsT,GACL,MAAO,IAAInZ,MAAK+Y,GAAU7K,MAC5B,EAgCF,MAAM5I,eAMJhC,0BAA4B,CAAC,EAG7BA,uBAAyB,IAAI8U,IAG7B9U,wBAA0B,IAAI8U,IAU9B9U,8BAAgC,iBAMhCA,SAAwB,KAMxB,uBAAOI,CAAiBC,GACtB2B,gBAAef,EAAiBZ,CAClC,CAMA,uBAAOG,GACL,OAAOwB,gBAAef,GAAkBe,eAAe8T,sBACzD,CAOA,8BAAOC,GACL,OAAO/T,eAAe8T,sBACxB,CAaA,sBAAOjU,CAAgBzE,EAAU0E,EAAekU,GAC9C,GAAwB,iBAAb5Y,EAET,YADAoI,QAAQC,KAAK,iEAIf,QAA+B,IAApBsF,gBAET,YADAvF,QAAQC,KAAK,6DAIf,QAA8B,IAAnBtJ,eAET,YADAqJ,QAAQC,KAAK,4DAIf,MAAMpD,EAAiBlG,eAAekB,aAAaD,GAC7C4F,EAAc+H,gBAAgBoB,OAAOrK,GAG3CmB,iBAAiBgG,eAAe5G,EAAgBW,GAGhDhB,eAAeiU,qBAAqB7Y,EACtC,CAQA,oBAAO6E,CAAc7E,EAAU8E,GACL,iBAAb9E,GAA+C,iBAAf8E,EAK3CF,eAAewI,mBAAmBpN,GAAY,CAAE8E,cAJ9CsD,QAAQC,KAAK,wFAKjB,CAeA,qBAAaiD,CAAStL,EAAUY,EAASgY,GACvC,OAAOtZ,KAAKiM,UAAU,CAACvL,GAAWY,EAASgY,EAC7C,CAaA,sBAAarN,CAAUC,EAAW5K,EAAU,CAAC,EAAGgY,GAC9C,MAAME,WACJA,EAAa,KAAIC,eACjBA,GAAiB,EAAKtN,YACtBA,GAAc,EAAIC,YAClBA,GAAc,GACZ9K,EAEEoY,GAAgBvN,EAAc,EAAI,IAAMC,EAAc,EAAI,GAC1DuN,EAAazN,EAAUrG,OAAS6T,EACtC,IAAIE,EAAc,EAElB,MAAMC,EAAiB,KACjBL,GAAYA,EAAWI,EAAaD,EAAW,EAGrD,IAAK,MAAMjZ,KAAYwL,EAAW,CAEhC,GAAI5G,eAAeuI,iBAAiB4K,IAAI/X,GAAW,OAC3C4E,eAAeuI,iBAAiByK,IAAI5X,GAC1C,QACF,CAEA,MAAMoZ,EAAc,WAClB,IACM3N,UACInM,KAAK+Z,gBAAgBrZ,EAAU4Y,GACrCM,IACAC,KAGEzN,UACIpM,KAAKga,cAActZ,EAAU+Y,EAAgBH,GACnDM,IACAC,IAEJ,CAAE,QACAvU,eAAeuI,iBAAiB6K,OAAOhY,EACzC,CACD,EAhBmB,GAkBpB4E,eAAeuI,iBAAiB0K,IAAI7X,EAAUoZ,SACxCA,CACR,CACF,CASA,wBAAa3N,CAAYD,EAAW5K,EAASgY,GAC3C,OAAOtZ,KAAKiM,UAAUC,EAAW,IAAK5K,EAAS8K,aAAa,GAASkN,EACvE,CASA,wBAAalN,CAAYF,EAAW5K,EAASgY,GAC3C,OAAOtZ,KAAKiM,UAAUC,EAAW,IAAK5K,EAAS6K,aAAa,GAASmN,EACvE,CAaA,4BAAaS,CAAgBrZ,EAAU4Y,GACrC,MAAM,IAAInX,MAAM,wEAClB,CAUA,0BAAa6X,CAActZ,EAAU+Y,EAAgBH,GACnD,MAAM,IAAInX,MAAM,sEAClB,CAaA,4BAAO8X,CAAsBvZ,EAAUgK,EAAY4O,GACjD,MAAM3T,EAAiBlG,eAAekB,aAAaD,UAG5C4E,eAAewI,mBAAmBpN,GAGzC,MAAM4F,EAAcC,iBAAiBC,eAAeb,GAEpD,IAAKW,EAGH,OADAhB,eAAeyI,gBAAgBwK,IAAI7X,EAAU,CAACgK,aAAY4O,qBACnD,EAIT,QAAuC,IAA5BzD,wBACT,MAAM,IAAI1T,MAAM,qFAAqFzB,KAIvG,MAAQgK,WAAYyN,EAAe3N,iBAAEA,GACnCqL,wBAAwBC,qBAAqBxP,EAAaoE,GAGtD7C,EAAY,IAAIiE,UAAUqM,EAAiB3N,GAKjD,OAFA1C,eAAeuE,aAAa1G,EAAgBkC,IAErC,CACT,CAMA,2BAAO0R,CAAqB7Y,GAE1B,IAAK4E,eAAeyI,gBAAgB0K,IAAI/X,GACtC,OAGF,MAAMgK,WAACA,EAAU4O,gBAAEA,GAAmBhU,eAAeyI,gBAAgBuK,IAAI5X,GACzE4E,eAAeyI,gBAAgB2K,OAAOhY,GAGtC4E,eAAe2U,sBAAsBvZ,EAAUgK,EAAY4O,EAC7D,EAiBF,SAASY,UAAWC,EAAaC,EAAYC,EAAYC,GACjD,MAAOF,IACPA,EAAa,GAGb,MAAOC,IACPA,EAAaF,EAAYE,WAAaD,GAG1C,MAAMG,EAAQ,IAAI1L,WAAWsL,EAAaC,EAAYC,GAEhDG,EAASD,EAAM,GACfE,EAASF,EAAM,GACfG,EAASH,EAAM,GACfI,EAASJ,EAAM,GAEfxU,GAAUwU,EAAM,IAAM,GAAOA,EAAM,IAAM,GAAOA,EAAM,IAAM,EAAKA,EAAM,MAAQ,EAC/EtP,GAAWsP,EAAM,IAAM,GAAOA,EAAM,IAAM,GAAOA,EAAM,KAAO,EAAKA,EAAM,OAAS,EAElFK,EAAWL,EAAM,IACjBM,EAAaN,EAAM,IAMzB,GAJI,MAAOD,IACPA,EAAiBM,GAGN,MAAXJ,GAA8B,MAAXC,GAA8B,MAAXC,GAA8B,MAAXC,EACzD,MAAM,IAAIxY,MAAM,wDAGpB,GAAIyY,EAAW,GAAKA,EAAW,EAC3B,MAAM,IAAIzY,MAAM,sEAGpB,GAAI0Y,EAAa,EACb,MAAM,IAAI1Y,MAAM,8DAGpB,GAAImY,EAAiB,GAAKA,EAAiB,EACvC,MAAM,IAAInY,MAAM,gEAGpB,MAAM2Y,EAAc/U,EAAQkF,EAASqP,EAC/BS,EAAS,IAAIlM,WAAWiM,GAE9B,IAAIE,EAAgB,GAEpB,MAAM7J,EAAQ,IAAItC,WAAW,KAC7B,IAAIoM,EAAgB,EAEhBC,EAAM,EACNC,EAAQ,EACRC,EAAO,EACPC,EAAQ,IAEZ,MAAMC,EAAejB,EAAa,EAElC,IAAIkB,EAAM,EACNC,EAAgB,EAEpB,KAAOA,EAAgBV,GAAeE,EAAgBX,EAAa,EAAGmB,GAAiBlB,EAAgB,CACnG,GAAIiB,EAAM,EACNA,SACG,GAAIP,EAAgBM,EAAc,CACrC,MAAMG,EAAQlB,EAAMS,KAEpB,GAAc,MAAVS,EACAP,EAAMX,EAAMS,KACZG,EAAQZ,EAAMS,KACdI,EAAOb,EAAMS,UACV,GAAc,MAAVS,EACPP,EAAMX,EAAMS,KACZG,EAAQZ,EAAMS,KACdI,EAAOb,EAAMS,KACbK,EAAQd,EAAMS,UACX,GAAa,IAARS,EAKL,GAA6B,KAAhB,IAARA,GACRP,IAASO,GAAS,EAAK,GAAc,EACrCN,IAAWM,GAAS,EAAK,GAAc,EACvCL,IAAiB,EAARK,GAAsB,EAG/BP,GAAOA,EAAM,KAAO,IACpBC,GAASA,EAAQ,KAAO,IACxBC,GAAQA,EAAO,KAAO,SACnB,GAA6B,MAAhB,IAARK,GAAoC,CAC5C,MAAMC,EAAQnB,EAAMS,KACdW,GAAqB,GAARF,GAAsB,GAKzCP,GAAOA,GAJSS,GAAcD,GAAS,EAAK,IAAc,GAInC,KAAO,IAC9BP,GAASA,EAAQQ,EAAY,KAAO,IACpCP,GAAQA,GALSO,GAAqB,GAARD,GAAsB,GAK1B,KAAO,GACrC,MAAoC,KAAxBD,IACRF,EAAc,GAARE,QAxBNP,EAAM/J,EAAc,EAARsK,GACZN,EAAQhK,EAAc,EAARsK,EAAY,GAC1BL,EAAOjK,EAAc,EAARsK,EAAY,GACzBJ,EAAQlK,EAAc,EAARsK,EAAY,GAwB9BR,GAAwB,EAANC,EAAkB,EAARC,EAAmB,EAAPC,EAAmB,GAARC,GAAc,GAAM,EACvElK,EAAM8J,GAAiBC,EACvB/J,EAAM8J,EAAgB,GAAKE,EAC3BhK,EAAM8J,EAAgB,GAAKG,EAC3BjK,EAAM8J,EAAgB,GAAKI,CAC/B,CAEuB,IAAnBf,GACAS,EAAOS,GAAiBN,EACxBH,EAAOS,EAAgB,GAAKL,EAC5BJ,EAAOS,EAAgB,GAAKJ,EAC5BL,EAAOS,EAAgB,GAAKH,IAE5BN,EAAOS,GAAiBN,EACxBH,EAAOS,EAAgB,GAAKL,EAC5BJ,EAAOS,EAAgB,GAAKJ,EAEpC,CAEA,GAAII,EAAgBV,EAChB,MAAM,IAAI3Y,MAAM,gCAKpB,MAAO,CACH4D,MAAOA,EACPkF,OAAQA,EACR4P,WAAYA,EACZD,SAAUN,EACVpY,KAAM6Y,EAEd,CA0BA,MAAMvW,mBAAmBc,eAMvBhC,sBAAwB,WACxBA,oBAAsB,SACtBA,oBAAsB,MAYtB,4BAAayW,CAAgBrZ,SAAU4Y,iBACrC,GAAuB,oBAAZsC,QACT,MAAM,IAAIzZ,MAAM,2DAGlB,MAAM0Z,GAAKD,QAAQ,MACbjY,KAAOiY,QAAQ,QAEfrX,cAAgBe,eAAexB,mBAC/BgY,YAAcnY,KAAKoY,QAAQxX,cAAe,GAAGC,WAAWwX,iBAAiBtb,WAAW8D,WAAWyX,gBAErG,IACE,MAAMC,YAAcL,GAAGM,aAAaL,YAAa,QAGjDM,KAAKF,YACP,CAAE,MAAOG,GAEP,MADAvT,QAAQC,KAAK,2BAA2B+S,eAClCO,CACR,CACF,CASA,0BAAarC,CAActZ,SAAU+Y,eAAgBH,iBACnD,GAAuB,oBAAZsC,QACT,MAAM,IAAIzZ,MAAM,yDAGlB,MAAM0Z,GAAKD,QAAQ,MACbjY,KAAOiY,QAAQ,QAEfrX,cAAgBe,eAAexB,mBAC/BwY,UAAY3Y,KAAKoY,QAAQxX,cAAe,GAAGC,WAAW+X,eAAe7b,eAAe8D,WAAWyX,gBAErG,IACE,MAAMO,UAAYX,GAAGM,aAAaG,UAAW,QAG7CF,KAAKI,WAGL,MAAMC,IAAMnX,eAAewI,mBAAmBpN,UAC9C,GAAI+b,KAAOA,IAAIjX,WAAY,CAEzB,QAAyB,IAAd0U,UACT,MAAM,IAAI/X,MAAM,oEAGlB,MAAMua,EAAU7N,WAAWH,KAAKE,KAAK6N,IAAIjX,aAAa+C,GAAKA,EAAEuG,WAAW,KAClE6N,EAAUzC,UAAUwC,EAAQE,QAG5BrH,EAAS+D,gBAAgBlV,kBAAhBkV,GACf/D,EAAOxP,MAAQ4W,EAAQ5W,MACvBwP,EAAOtK,OAAS0R,EAAQ1R,OACxB,MAAM1D,EAAMgO,EAAO7N,WAAW,MACxBqO,EAAYxO,EAAIsV,gBAAgBF,EAAQ5W,MAAO4W,EAAQ1R,QAC7D8K,EAAU7T,KAAKqW,IAAIoE,EAAQza,MAC3BqF,EAAIuV,aAAa/G,EAAW,EAAG,GAG/BzQ,eAAe2U,sBAAsBvZ,SAAU6U,EAAQ+D,gBACzD,CACF,CAAE,MAAO+C,GACPvT,QAAQC,KAAK,2BAA2BuT,cAAcD,EAAMU,WAC5DjU,QAAQC,KAAK,kCACf,CACF,EAOoB,oBAAXiU,SACTA,OAAO3e,WAAaA,WACpB2e,OAAOne,eAAiBA,eACxBme,OAAOje,kBAAoBA,kBAC3Bie,OAAO3d,qBAAuBA,qBAC9B2d,OAAOvd,eAAiBA,eACxBud,OAAO3b,eAAiBA,eACxB2b,OAAO/a,YAAcA,YACrB+a,OAAO3Z,WAAaA,WACpB2Z,OAAOlV,eAAiBA,eACxBkV,OAAOzW,iBAAmBA,iBAC1ByW,OAAOrE,aAAeA,aACtBqE,OAAO9C,UAAYA","ignoreList":[]}