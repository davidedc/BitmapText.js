{"version":3,"names":["StatusCode","Object","freeze","SUCCESS","NO_METRICS","PARTIAL_METRICS","NO_ATLAS","PARTIAL_ATLAS","SUCCESS_STATUS","code","createErrorStatus","details","isSuccess","status","isCompleteFailure","isPartialSuccess","getStatusDescription","requiresMinSize","requestedSize","minSize","missingChars","join","missingAtlasChars","FontProperties","constructor","pixelDensity","fontFamily","fontStyle","fontWeight","fontSize","this","_key","_idString","formatNumber","num","str","String","includes","replace","key","idString","fromIDString","parts","split","parseFloat","formatNumericPart","fromKey","integerPart","decimalPart","equals","other","TextProperties","options","isKerningEnabled","textBaseline","textAlign","textColor","withKerning","withColor","forBitmapText","withKerningEnabled","withTextColor","toObject","FontMetrics","data","Error","_kerningTable","kerningTable","_characterMetrics","characterMetrics","_spaceAdvancementOverride","spaceAdvancementOverrideForSmallSizesInPx","mutable","getCharacterMetrics","char","getKerningAdjustment","leftChar","rightChar","hasGlyph","getSpaceAdvancementOverride","getKerningTable","getAvailableCharacters","keys","InterpolatedFontMetrics","baseFontMetrics","targetSize","interpolationFactor","isInterpolatedMetrics","origMetrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","fontBoundingBoxAscent","fontBoundingBoxDescent","width","override","alphabeticBaseline_ab","hangingBaseline_ab","ideographicBaseline_ab","middleBaseline_ab","topBaseline_ab","CharacterSets","static","generateFontSpecificChars","chars","i","push","fromCharCode","cp1252PrintableChars","sort","BitmapText","isInvariantCharacter","FONT_INVARIANT_CHARS","calculateOptimalGridDimensions","characterCount","columns","Math","ceil","sqrt","rows","document","createElement","setFontDirectory","path","ensureFontLoader","fontLoader","getFontDirectory","setCanvasFactory","factory","canvasFactory","coloredGlyphCanvas","coloredGlyphCtx","getCanvasFactory","configure","undefined","fontDirectory","FontLoader","shouldUseMinSize","MIN_RENDERABLE_SIZE","createFontPropsAtMinSize","fontProperties","createInterpolatedFontMetrics","metricsAt8_5","redirectIdStringIfNeeded","silent","fontProps","minSizeProps","console","warn","redirected","originalSize","parametersToIDString","density","styleIdx","weightIdx","size","style","weight","densityStr","densityFormatted","sizeStr","registerMetrics","compactedData","fullIDString","FontLoaderBase","registerAtlas","base64Data","measureText","text","textProperties","length","metrics","fontMetrics","FontMetricsStore","getFontMetrics","invariantFontProps","INVARIANT_FONT_FAMILY","invariantFontMetrics","invariantMinSizeProps","invariantMetricsAt8_5","hasInvariantFont","Set","add","width_CssPx","firstCharIsInvariant","currentFontMetrics","currentFontProps","actualBoundingBoxLeft_CssPx","actualBoundingBoxRight_CssPx","advancement_CssPx","nextChar","isInvariant","max","min","calculateAdvancement_CssPx","drawTextFromAtlas","ctx","x_CssPx","y_CssPx","getContext","forceInvalidAtlas","rendered","missingMetricsChars","atlasData","AtlasDataStore","getAtlasData","atlasValid","isValidAtlas","invariantAtlasData","invariantAtlasValid","currentAtlasData","currentAtlasValid","placeholdersUsed","save","setTransform","firstChar","find","c","characterMetricsForBaseline","baselineOffset_CssPx","calculateBaselineOffsetToBottom","alignmentOffset_CssPx","measureResult","calculateAlignmentOffsetToLeft","position_PhysPx","x","y","DEFAULT_TEXT_COLOR","batchResult","drawColoredTextBatched","forEach","currentChar","hasPositioning","drawCharacter","calculateCharacterAdvancement_PhysPx","statusCode","restore","spaceAdvancementOverrideForSmallSizesInPx_CssPx","kerningCorrection","getKerningCorrection","KERNING_UNIT_DIVISOR","round","fba","fbd","hb","hangingBaseline","ib","ideographicBaseline","textWidth_CssPx","startPosition_PhysPx","visualWidth_CssPx","textWidth_PhysPx","textHeight_PhysPx","actualBoundingBoxLeft_PhysPx","baselineY_PhysPx","height","clearRect","atlasPositioning","getPositioning","atlasImage","image","xInAtlas","yInAtlas","tightWidth","tightHeight","dx","dy","drawImage","globalCompositeOperation","fillStyle","fillRect","drawPlaceholderRectangle","drawCharacterDirect","createColoredGlyph","renderGlyphToMainCanvas","width_PhysPx","height_PhysPx","rectX_PhysPx","rectY_PhysPx","actualColor","AtlasData","isValid","loadFont","redirection","loadFonts","idStrings","redirectedIdStrings","map","loadMetrics","loadAtlases","setAtlasData","deleteAtlas","setFontMetrics","unloadFont","deleteFontMetrics","unloadFonts","id","unloadMetrics","unloadAtlas","unloadAllFonts","clear","unloadAllAtlases","hasFont","hasMetrics","hasAtlas","hasFontMetrics","getLoadedFonts","loaded","getAvailableFonts","getLoadedMetrics","getLoadedAtlases","__resetForTesting","_loadingPromises","_tempAtlasPackages","_pendingAtlases","r","a","MetricsExpander","decodeFromBase64Bytes","base64","bytes","Buffer","from","binary","atob","Uint8Array","charCodeAt","Array","decodeVarInts","integers","byte","value","shift","signed","decompressValueArray","deltas","sorted","expand","minified","characterSet","FONT_SPECIFIC_CHARS","isArray","expandedData","kv","k","b","v","t","g","s","cl","convertIntegersToValues","unflattenBaseline","unflattenTuplets","expandKerningTable","expandCharacterMetrics","debug","kerningValueLookup","leftExpanded","expandLeftSide","rangeExpanded","pairs","entries","expandKerningPairs","expanded","index","rightSideObj","hyphenIndex","indexOf","startChar","substring","endChar","startIndex","endIndex","parseCompactCharString","compactStr","j","tupletIndices","metricsCommonToAllCharacters","valueLookup","tupletLookup","commonLeftIndex","tupletIndex","compressed","indices","emHeightAscent","emHeightDescent","alphabeticBaseline","ab","pd","int","baselineArray","flattened","tuplets","currentTuplet","AtlasPositioning","_tightWidth","_tightHeight","_dx","_dy","_xInAtlas","_yInAtlas","hasAtlasPosition","getTightWidth","getTightHeight","getXInAtlas","getYInAtlas","getDx","getDy","AtlasImage","naturalWidth","naturalHeight","canRender","Image","complete","getImageType","HTMLCanvasElement","OffscreenCanvas","HTMLImageElement","contextType","getDebugInfo","type","availableCharacters","characters","slice","AtlasReconstructionUtils","getImageData","actualImage","canvas","AtlasCellDimensions","getWidth","charMetrics","getHeight","getDimensions","TightAtlasReconstructor","reconstructFromAtlas","imageData","firstMetrics","height_CssPx","cellHeight_PhysPx","gridDims","GRID_COLUMNS","GRID_ROWS","cellWidths_PhysPx","columnMaxWidths_PhysPx","fill","charIndex","cellWidth_PhysPx","col","columnXPositions_PhysPx","tightBounds","cellDebugInfo","row","floor","cellX_PhysPx","cellY_PhysPx","bounds","findTightBounds","packTightAtlas","pixels","stride","getAlpha","bottom_PhysPx","top_PhysPx","found","left_PhysPx","right_PhysPx","left","top","sourceAtlasImage","totalWidth_PhysPx","maxHeight_PhysPx","tightCanvas","xInTightAtlas_PhysPx","positioning","tempCanvas","tempCtx","srcX_PhysPx","srcY_PhysPx","srcWidth_PhysPx","srcHeight_PhysPx","distanceBetweenBottomAndBottomOfCanvas_PhysPx","tightAtlasImage","Map","atlases","get","set","atlas","has","delete","FontManifest","addFontIDs","ids","idsArray","fontIDs","allFontIDs","hasFontID","count","allFontIDsSorted","DEFAULT_FONT_DIRECTORY","getDefaultFontDirectory","bitmapTextClass","_processPendingAtlas","onProgress","isFileProtocol","filesPerFont","totalFiles","loadedFiles","reportProgress","loadPromise","loadMetricsFile","loadAtlasFile","_loadAtlasFromPackage","QOIDecode","arrayBuffer","byteOffset","byteLength","outputChannels","uint8","magic1","magic2","magic3","magic4","channels","colorspace","pixelLength","result","arrayPosition","indexPosition","red","green","blue","alpha","chunksLength","run","pixelPosition","byte1","byte2","greenDiff","require","fs","metricsPath","resolve","METRICS_PREFIX","JS_EXTENSION","metricsCode","readFileSync","eval","error","atlasPath","ATLAS_PREFIX","atlasCode","pkg","qoiData","decoded","buffer","createImageData","putImageData","message","global"],"sources":["/Users/davidedellacasa/code/BitmapText.js/dist/bitmaptext-node.js"],"sourcesContent":["/**\n * BitmapText.js - Runtime Bundle\n *\n * Pixel-perfect bitmap text rendering for HTML5 Canvas\n *\n * ⚠️  DO NOT EDIT - Generated by scripts/build-runtime-bundle.sh\n *\n * This bundle contains the complete BitmapText.js runtime for rendering\n * pre-generated bitmap fonts. It does NOT include font generation tools.\n *\n * Bundle Contents:\n *   - StatusCode (status reporting)\n *   - FontProperties/TextProperties (configuration)\n *   - FontMetrics (font metrics domain object)\n *   - BitmapText (core runtime with CHARACTER_SET)\n *   - MetricsExpander (minified metrics expansion)\n *   - Atlas classes (AtlasPositioning, AtlasImage, AtlasData)\n *   - TightAtlasReconstructor (runtime atlas reconstruction)\n *   - FontLoader (font loading with platform detection)\n *   - Atlas/Metrics stores (data storage)\n *\n * Usage (Browser):\n *   <script src=\"dist/bitmaptext.min.js\"></script>\n *   <script>\n *     const fontProps = new FontProperties(1, \"Arial\", \"normal\", \"normal\", 19);\n *     await BitmapText.loadFont(fontProps.idString);\n *     BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 50, fontProps);\n *   </script>\n *\n * Usage (Node.js):\n *   import { createCanvas } from 'node-canvas';  // or 'skia-canvas'\n *   import './dist/bitmaptext-node.min.js';\n *\n *   BitmapText.configure({\n *     fontDirectory: './font-assets/',\n *     canvasFactory: () => createCanvas()\n *   });\n *\n *   await BitmapText.loadFont(fontProps.idString);\n *   BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 50, fontProps);\n *\n * License: SEE LICENSE IN LICENSE\n */\n\n// ============================================================================\n// StatusCode.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/StatusCode.js\n// ============================================================================\n\n// StatusCode - Core Runtime Constants\n//\n// This is a CORE RUNTIME module designed for minimal bundle size (~0.5KB).\n// It provides status code constants and pre-created status objects for performance optimization.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Used by BitmapText for efficient status reporting\n// - No dependencies, pure constants and helper objects\n//\n// PERFORMANCE OPTIMIZATIONS:\n// - Numeric codes for faster comparisons than strings\n// - Pre-created immutable SUCCESS_STATUS object to avoid allocations\n// - Frozen objects for memory safety and immutability\n\n/**\n * Status codes for BitmapText operations\n * Using numeric values for optimal performance in comparisons\n */\nconst StatusCode = Object.freeze({\n  SUCCESS: 0,           // Everything worked perfectly\n  NO_METRICS: 1,        // No FontMetrics found at all for this font configuration\n  PARTIAL_METRICS: 2,   // Some characters missing metrics data\n  NO_ATLAS: 3,          // No atlas available (will render placeholder rectangles)\n  PARTIAL_ATLAS: 4      // Some characters missing from atlas (partial placeholders)\n});\n\n/**\n * Pre-created immutable success status object for performance\n * Reused for all successful operations to avoid object allocation overhead\n */\nconst SUCCESS_STATUS = Object.freeze({\n  code: StatusCode.SUCCESS\n});\n\n/**\n * Helper function to create error status objects\n * @param {number} code - StatusCode value\n * @param {Object} details - Additional details object\n * @returns {Object} Immutable status object\n */\nfunction createErrorStatus(code, details = {}) {\n  return Object.freeze({\n    code,\n    ...details\n  });\n}\n\n/**\n * Helper function to check if a status indicates success\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates success\n */\nfunction isSuccess(status) {\n  return status?.code === StatusCode.SUCCESS;\n}\n\n/**\n * Helper function to check if a status indicates complete failure\n * (NO_METRICS or PARTIAL_METRICS - cannot render at all)\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates complete failure\n */\nfunction isCompleteFailure(status) {\n  return status && (\n    status.code === StatusCode.NO_METRICS ||\n    status.code === StatusCode.PARTIAL_METRICS\n  );\n}\n\n/**\n * Helper function to check if a status indicates partial success\n * (NO_ATLAS or PARTIAL_ATLAS - can render with placeholders)\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates partial success\n */\nfunction isPartialSuccess(status) {\n  return status && (\n    status.code === StatusCode.NO_ATLAS ||\n    status.code === StatusCode.PARTIAL_ATLAS\n  );\n}\n\n/**\n * Helper function to get human-readable status description\n * @param {Object} status - Status object with code property\n * @returns {string} Human-readable description\n */\nfunction getStatusDescription(status) {\n  if (!status || typeof status.code !== 'number') {\n    return 'Invalid status';\n  }\n\n  switch (status.code) {\n    case StatusCode.SUCCESS:\n      return 'Success';\n    case StatusCode.NO_METRICS:\n      if (status.requiresMinSize) {\n        return `Font size ${status.requestedSize}px requires size ${status.minSize}px metrics for interpolation. Please load size ${status.minSize}px font assets.`;\n      }\n      return 'No font metrics available';\n    case StatusCode.PARTIAL_METRICS:\n      return `Missing metrics for characters: ${status.missingChars ? [...status.missingChars].join('') : 'unknown'}`;\n    case StatusCode.NO_ATLAS:\n      return 'No atlas available (using placeholders)';\n    case StatusCode.PARTIAL_ATLAS:\n      return `Missing atlas data for characters: ${status.missingAtlasChars ? [...status.missingAtlasChars].join('') : 'unknown'} (using placeholders)`;\n    default:\n      return `Unknown status code: ${status.code}`;\n  }\n}\n// ============================================================================\n// FontProperties.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontProperties.js\n// ============================================================================\n\n// FontProperties - Core Runtime Class  \n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It provides essential font configuration management with maximum performance.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontPropertiesFAB for validation and font assets building utilities  \n// - Contains no validation code to minimize runtime overhead\n// - Optimized for performance with pre-computed keys and immutability\n//\n// ARCHITECTURE:\n// - Immutable font configuration object safe to use as Map keys\n// - Pre-computes storage keys and ID strings for optimal lookup performance\n// - Provides factory methods for creating instances from various inputs\n// - Properties in fixed order: pixelDensity, fontFamily, fontStyle, fontWeight, fontSize\n//\n// For validation and font assets building utilities, use FontPropertiesFAB.\nclass FontProperties {\n  constructor(pixelDensity, fontFamily, fontStyle, fontWeight, fontSize) {\n    // Direct assignment, no validation in core for performance\n    this.pixelDensity = pixelDensity || 1;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = fontWeight || 'normal';\n    this.fontSize = fontSize;\n    \n    // Pre-compute storage key (critical for performance optimization)\n    // Used for Map lookups in AtlasDataStore\n    this._key = `${this.pixelDensity}:${this.fontFamily}:${this.fontStyle}:${this.fontWeight}:${this.fontSize}`;\n    \n    // Pre-compute ID string for file naming and manifest keys\n    // Format: density-1-0-Arial-style-normal-weight-normal-size-18-0\n    this._idString = `density-${this.#formatNumber(this.pixelDensity)}-${this.fontFamily}-style-${this.fontStyle}-weight-${this.fontWeight}-size-${this.#formatNumber(this.fontSize)}`;\n    \n    // Freeze for immutability (safe to use as Map keys)\n    Object.freeze(this);\n  }\n  \n  // Format number handling non-integers: 1.5 → \"1-5\", 18.5 → \"18-5\", 18 → \"18-0\"\n  #formatNumber(num) {\n    const str = String(num);\n    return str.includes('.') ? str.replace('.', '-') : `${str}-0`;\n  }\n  \n  // Getter for pre-computed storage key\n  get key() {\n    return this._key;\n  }\n  \n  // Getter for pre-computed ID string\n  get idString() {\n    return this._idString;\n  }\n  \n  \n  // Factory method to create FontProperties from ID string\n  // Parses: density-1-0-Arial-style-normal-weight-normal-size-18-0\n  static fromIDString(idString) {\n    const parts = idString.split('-');\n\n    // Extract and format numeric values (handling decimal parts)\n    const pixelDensity = parseFloat(FontProperties.#formatNumericPart(parts[1], parts[2]));\n    const fontSize = parseFloat(FontProperties.#formatNumericPart(parts[9], parts[10]));\n    const fontFamily = parts[3];\n    const fontStyle = parts[5];\n    const fontWeight = parts[7];\n\n    // Return new FontProperties instance\n    return new FontProperties(pixelDensity, fontFamily, fontStyle, fontWeight, fontSize);\n  }\n\n  // Factory method to create FontProperties from storage key\n  // Parses: \"1:Arial:normal:normal:19\" or \"1.5:Arial:italic:bold:18.5\"\n  static fromKey(key) {\n    const [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize] = key.split(':');\n\n    // Return new FontProperties instance with parsed numeric values\n    return new FontProperties(\n      parseFloat(pixelDensity),\n      fontFamily,\n      fontStyle,\n      fontWeight,\n      parseFloat(fontSize)\n    );\n  }\n\n  // Helper method to format numeric parts (used by fromIDString)\n  static #formatNumericPart(integerPart, decimalPart) {\n    if (!decimalPart || decimalPart === '0') {\n      return integerPart;\n    }\n    return `${integerPart}.${decimalPart}`;\n  }\n  \n  // Equality comparison based on key\n  equals(other) {\n    if (!(other instanceof FontProperties)) return false;\n    return this._key === other._key;\n  }\n}\n// ============================================================================\n// TextProperties.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/TextProperties.js\n// ============================================================================\n\n// TextProperties - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It provides essential text rendering configuration with maximum performance.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Manages text rendering properties: kerning, alignment, baseline, color\n// - Contains no validation code to minimize runtime overhead\n// - Optimized for performance with pre-computed keys and immutability\n//\n// ARCHITECTURE:\n// - Immutable text configuration object safe to use as Map keys\n// - Pre-computes storage keys for optimal lookup performance\n// - Provides factory methods for creating instances from various inputs\n// - Properties: isKerningEnabled, textBaseline, textAlign, textColor\n//\n// This class replaces the global isKerningEnabled variable and consolidates\n// all text rendering properties into a single, immutable configuration object.\nclass TextProperties {\n  constructor(options = {}) {\n    // Extract options with defaults - optimized for BitmapText usage\n    const {\n      isKerningEnabled = true,        // Enable kerning by default for better text rendering\n      textBaseline = 'bottom',        // BitmapText uses 'bottom' baseline by architectural design (HTML5 Canvas default is 'alphabetic')\n      textAlign = 'left',             // HTML5 Canvas default\n      textColor = '#000000'           // Black color default\n    } = options;\n\n    // Direct assignment, no validation in core for performance\n    this.isKerningEnabled = isKerningEnabled;\n    this.textBaseline = textBaseline;\n    this.textAlign = textAlign;\n    this.textColor = textColor;\n\n    // Pre-compute storage key (for potential caching or Map lookups)\n    this._key = `kerning:${this.isKerningEnabled}:baseline:${this.textBaseline}:align:${this.textAlign}:color:${this.textColor}`;\n\n    // Freeze for immutability (safe to use as Map keys)\n    Object.freeze(this);\n  }\n\n  // Getter for pre-computed storage key\n  get key() {\n    return this._key;\n  }\n\n  // Factory method to create TextProperties with specific kerning setting\n  static withKerning(isKerningEnabled, options = {}) {\n    return new TextProperties({\n      ...options,\n      isKerningEnabled\n    });\n  }\n\n  // Factory method to create TextProperties with specific color\n  static withColor(textColor, options = {}) {\n    return new TextProperties({\n      ...options,\n      textColor\n    });\n  }\n\n  // Factory method to create TextProperties for BitmapText (uses 'bottom' baseline)\n  static forBitmapText(options = {}) {\n    return new TextProperties({\n      textBaseline: 'bottom',  // BitmapText uses bottom baseline positioning\n      ...options\n    });\n  }\n\n  // Create a new TextProperties with modified kerning\n  withKerningEnabled(isKerningEnabled) {\n    return new TextProperties({\n      isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor: this.textColor\n    });\n  }\n\n  // Create a new TextProperties with modified color\n  withTextColor(textColor) {\n    return new TextProperties({\n      isKerningEnabled: this.isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor\n    });\n  }\n\n  // Equality comparison based on key\n  equals(other) {\n    if (!(other instanceof TextProperties)) return false;\n    return this._key === other._key;\n  }\n\n  // Return plain object for compatibility/debugging\n  toObject() {\n    return {\n      isKerningEnabled: this.isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor: this.textColor\n    };\n  }\n}\n// ============================================================================\n// FontMetrics.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontMetrics.js\n// ============================================================================\n\n// FontMetrics - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~3-4KB).\n// It encapsulates all metrics data for a single font configuration as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontMetricsFAB for font assets building capabilities\n// - Contains only essential metrics data and accessor methods\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Immutable object representing all metrics for ONE font configuration\n// - Pre-computed lookups for optimal performance during text rendering\n// - Provides clean API without needing fontProperties passed to every method\n// - Follows same immutable pattern as FontProperties\n//\n// SEPARATION RATIONALE:\n// - Encapsulates related metrics data together\n// - Eliminates repeated fontProperties parameter passing\n// - Serves as domain object for font metrics\n// - Enables cleaner, more object-oriented API\n//\n// For font assets building capabilities, use FontMetricsFAB which extends this class.\nclass FontMetrics {\n  constructor(data, options = {}) {\n    // Validate input data structure\n    if (!data || typeof data !== 'object') {\n      throw new Error('FontMetrics constructor requires data object');\n    }\n    \n    // Kerning table: character pairs → adjustment values\n    this._kerningTable = data.kerningTable || {};\n    \n    // Character metrics: character → TextMetrics-compatible object\n    this._characterMetrics = data.characterMetrics || {};\n    \n    // Space advancement override for small font sizes\n    this._spaceAdvancementOverride = data.spaceAdvancementOverrideForSmallSizesInPx || null;\n    \n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this._kerningTable);\n      Object.freeze(this._characterMetrics);\n      Object.freeze(this);\n    }\n  }\n  \n  /**\n   * Get text measurement metrics for a character\n   * @param {string} char - Character (code point) to get metrics for\n   * @returns {Object} TextMetrics-compatible object\n   */\n  getCharacterMetrics(char) {\n    return this._characterMetrics[char];\n  }\n  \n  /**\n   * Get kerning adjustment between two characters\n   * @param {string} leftChar - Left character in pair\n   * @param {string} rightChar - Right character in pair  \n   * @returns {number} Kerning adjustment value (0 if no adjustment)\n   */\n  getKerningAdjustment(leftChar, rightChar) {\n    if (!leftChar || !rightChar) return 0;\n    return this._kerningTable[leftChar]?.[rightChar] || 0;\n  }\n  \n  /**\n   * Check if glyph exists in this font\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if glyph has metrics\n   */\n  hasGlyph(char) {\n    return char in this._characterMetrics;\n  }\n  \n  /**\n   * Get space advancement override for small font sizes\n   * @returns {number|null} Override value in pixels, or null if no override\n   */\n  getSpaceAdvancementOverride() {\n    return this._spaceAdvancementOverride;\n  }\n  \n  /**\n   * Get the complete kerning table (for compatibility/debugging)\n   * @returns {Object} Complete kerning table\n   */\n  getKerningTable() {\n    return this._kerningTable;\n  }\n  \n  /**\n   * Get all available characters in this font\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    return Object.keys(this._characterMetrics);\n  }\n  \n}\n// ============================================================================\n// InterpolatedFontMetrics.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/InterpolatedFontMetrics.js\n// ============================================================================\n\n// InterpolatedFontMetrics - Wrapper for FontMetrics that scales metric values\n//\n// This is a RUNTIME class used by BitmapText to support font sizes < 8.5px.\n//\n// USAGE:\n// - Font sizes < 8.5px interpolate metrics from size 8.5px\n// - All metric values (widths, kerning, baselines) are scaled proportionally\n// - Marker property `isInterpolatedMetrics` enables conditional rounding in BitmapText\n//\n// ARCHITECTURE:\n// - Wraps a FontMetrics instance (typically size 8.5px)\n// - Scales all metric values by interpolationFactor = targetSize / 8.5\n// - Delegates glyph checking and kerning table access to base metrics\n// - Used exclusively for rendering placeholder rectangles (atlases never loaded)\n//\n// DEPENDENCIES:\n// - Requires FontMetrics.js to be loaded first\n// - Used by BitmapText.js for sizes < MIN_RENDERABLE_SIZE (8.5px)\n//\n/**\n * InterpolatedFontMetrics - Wrapper for FontMetrics that scales all values\n *\n * Used for font sizes < 8.5px which interpolate metrics from size 8.5px.\n * All metric values (widths, kerning, baselines) are scaled proportionally.\n *\n * Marker property `isInterpolatedMetrics` enables conditional rounding in\n * calculateAdvancement_CssPx() to preserve linear scaling behavior.\n */\nclass InterpolatedFontMetrics {\n  constructor(baseFontMetrics, targetSize) {\n    this.baseFontMetrics = baseFontMetrics;\n    this.targetSize = targetSize;\n    this.interpolationFactor = targetSize / 8.5;  // MIN_RENDERABLE_SIZE constant value\n\n    // Marker for detection in calculateAdvancement_CssPx()\n    // Enables float positioning instead of integer rounding\n    this.isInterpolatedMetrics = true;\n  }\n\n  // Interpolate character metrics by scaling all values\n  getCharacterMetrics(char) {\n    const origMetrics = this.baseFontMetrics.getCharacterMetrics(char);\n    if (!origMetrics) return null;\n\n    return {\n      actualBoundingBoxLeft: origMetrics.actualBoundingBoxLeft * this.interpolationFactor,\n      actualBoundingBoxRight: origMetrics.actualBoundingBoxRight * this.interpolationFactor,\n      actualBoundingBoxAscent: origMetrics.actualBoundingBoxAscent * this.interpolationFactor,\n      actualBoundingBoxDescent: origMetrics.actualBoundingBoxDescent * this.interpolationFactor,\n      fontBoundingBoxAscent: origMetrics.fontBoundingBoxAscent * this.interpolationFactor,\n      fontBoundingBoxDescent: origMetrics.fontBoundingBoxDescent * this.interpolationFactor,\n      width: origMetrics.width * this.interpolationFactor\n    };\n  }\n\n  // Delegate glyph checking to base metrics\n  hasGlyph(char) {\n    return this.baseFontMetrics.hasGlyph(char);\n  }\n\n  // Interpolate kerning adjustment by scaling\n  getKerningAdjustment(leftChar, rightChar) {\n    const origKerning = this.baseFontMetrics.getKerningAdjustment(leftChar, rightChar);\n    return origKerning * this.interpolationFactor;\n  }\n\n  // Delegate kerning table getter to base metrics\n  getKerningTable() {\n    return this.baseFontMetrics.getKerningTable();\n  }\n\n  // Interpolate space advancement override if present\n  getSpaceAdvancementOverride() {\n    const override = this.baseFontMetrics.getSpaceAdvancementOverride();\n    return override !== null ? override * this.interpolationFactor : null;\n  }\n\n  // Property getters\n  get fontSize() {\n    return this.targetSize;\n  }\n\n  get alphabeticBaseline_ab() {\n    return this.baseFontMetrics.alphabeticBaseline_ab * this.interpolationFactor;\n  }\n\n  get hangingBaseline_ab() {\n    return this.baseFontMetrics.hangingBaseline_ab * this.interpolationFactor;\n  }\n\n  get ideographicBaseline_ab() {\n    return this.baseFontMetrics.ideographicBaseline_ab * this.interpolationFactor;\n  }\n\n  get middleBaseline_ab() {\n    return this.baseFontMetrics.middleBaseline_ab * this.interpolationFactor;\n  }\n\n  get topBaseline_ab() {\n    return this.baseFontMetrics.topBaseline_ab * this.interpolationFactor;\n  }\n}\n\n// ============================================================================\n// CharacterSets.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/CharacterSets.js\n// ============================================================================\n\n/**\n * CharacterSets - Character set configuration for BitmapText.js\n *\n * This class defines the character sets used throughout the BitmapText.js library.\n * It contains both font-specific characters (required in all fonts) and font-invariant\n * characters (auto-redirect to BitmapTextInvariant font).\n *\n * @class CharacterSets\n * @static\n */\nclass CharacterSets {\n  // ============================================\n  // Font-Specific Character Set (204 characters)\n  // ============================================\n\n  /**\n   * Font-specific character set constant (204 characters)\n   * Used by both build-time (MetricsMinifier) and runtime (MetricsExpander)\n   * This is the sorted character set that defines the standard order for all font metrics.\n   * ALL font files must contain exactly these 204 characters in this order.\n   *\n   * @type {string}\n   * @static\n   * @readonly\n   */\n  static FONT_SPECIFIC_CHARS = CharacterSets.#generateFontSpecificChars();\n\n  // ============================================\n  // Font-Invariant Character Configuration\n  // ============================================\n\n  /**\n   * Font-invariant characters that auto-redirect to BitmapTextInvariant font.\n   * These 18 Unicode characters render using monospaced Courier New metrics\n   * regardless of the font specified in FontProperties.\n   *\n   * Characters: ☺☹♠♡♦♣│─├└▶▼▲◀✔✘≠↗\n   *\n   * @type {string}\n   * @static\n   * @readonly\n   */\n  static FONT_INVARIANT_CHARS = '☺☹♠♡♦♣│─├└▶▼▲◀✔✘≠↗';\n\n  /**\n   * Font family name for font-invariant characters.\n   * These characters are internally rendered using Courier New to ensure\n   * consistent monospaced appearance across all fonts.\n   *\n   * @type {string}\n   * @static\n   * @readonly\n   */\n  static INVARIANT_FONT_FAMILY = 'BitmapTextInvariant';\n\n  // ============================================\n  // Private Generator Methods\n  // ============================================\n\n  /**\n   * Generates the font-specific character set (204 characters).\n   * This includes ASCII printable characters, selected CP-1252 characters,\n   * Latin-1 Supplement characters, and the Full Block character.\n   *\n   * Character composition:\n   * - ASCII printable (32-126): 95 characters\n   * - Windows-1252 subset (CP-1252): 14 characters\n   * - Latin-1 Supplement (161-255, excluding soft hyphen 173): 94 characters\n   * - Full Block character (█): 1 character\n   *\n   * Total: 204 characters\n   *\n   * @private\n   * @static\n   * @returns {string} Sorted character set string\n   */\n  static #generateFontSpecificChars() {\n    const chars = [];\n\n    // ASCII printable characters (32-126)\n    // Includes space, numbers, letters, and common symbols\n    for (let i = 32; i <= 126; i++) {\n      chars.push(String.fromCharCode(i));\n    }\n\n    // A selection from Windows-1252 (CP-1252) printable characters.\n    // This is the most standard definition of \"extended ASCII codes\" from 128 to 159\n    // and many of these are common/useful symbols that people \"expect to have\".\n    // However fromCharCode doesn't work on those as that range is not defined\n    // in UTF-8/Unicode (modern web standard, so we want to include (some of) them but we have\n    // to map them to specific Unicode code points, not the byte values themselves.\n    // NOTE: we could likely shave some of these off, as they are not easily printable\n    // in Javascript and some of them are fairly arcane/\n    const cp1252PrintableChars = [\n      8364, // € Euro sign (CP-1252: 128)\n      //  8218, // ‚ Single low-9 quotation mark (CP-1252: 130)\n      //  402,  // ƒ Latin small letter f with hook (CP-1252: 131)\n      //  8222, // „ Double low-9 quotation mark (CP-1252: 132)\n      8230, // … Horizontal ellipsis (CP-1252: 133)\n      //  8224, // † Dagger (CP-1252: 134)\n      //  8225, // ‡ Double dagger (CP-1252: 135)\n      //  710,  // ˆ Modifier letter circumflex accent (CP-1252: 136)\n      8240, // ‰ Per mille sign (CP-1252: 137)\n      //  352,  // Š Latin capital letter S with caron (CP-1252: 138)\n      8249, // ‹ Single left-pointing angle quotation (CP-1252: 139)\n      //  338,  // Œ Latin capital ligature OE (CP-1252: 140)\n      381,  // Ž Latin capital letter Z with caron (CP-1252: 142)\n      //  8216, // ' Left single quotation mark (CP-1252: 145)\n\n      // UNFORTUNATELY SOMETIMES USED INSTEAD OF APOSTROPHE\n      8217, // ' \"\"curly apostrophe\"\" or \"right single quotation mark\" (CP-1252: 146)\n\n      //  8220, // \" Left double quotation mark (CP-1252: 147)\n      //  8221, // \" Right double quotation mark (CP-1252: 148)\n      8226, // • Bullet (CP-1252: 149)\n      //  8211, // – En dash (CP-1252: 150)\n      8212, // — Em dash (CP-1252: 151)\n      //  732,  // ˜ Small tilde (CP-1252: 152)\n      8482, // ™ Trade mark sign (CP-1252: 153)\n      353,  // š Latin small letter s with caron (CP-1252: 154)\n      8250, // › Single right-pointing angle quotation mark (CP-1252: 155)\n      339,  // œ Latin small ligature oe (CP-1252: 156)\n      382,  // ž Latin small letter z with caron (CP-1252: 158)\n      376   // Ÿ Latin capital letter Y with diaeresis (CP-1252: 159)\n    ];\n\n    for (const code of cp1252PrintableChars) {\n      chars.push(String.fromCharCode(code));\n    }\n\n    // Latin-1 Supplement characters (161-255)\n    // These are properly defined in UTF-8/Unicode\n    // Exclude U+00AD (173) - soft hyphen, which has zero width\n    for (let i = 161; i <= 255; i++) {\n      if (i !== 173) { // Skip soft hyphen\n        chars.push(String.fromCharCode(i));\n      }\n    }\n\n    // Add Full Block character (allows us to see the maximum space taken by a glyph)\n    chars.push('█');\n\n    // Sort the character set (this is how it's used throughout the codebase)\n    return chars.sort().join('');\n  }\n}\n\n// ============================================================================\n// BitmapText.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/BitmapText.js\n// ============================================================================\n\n// BitmapText - Static Core Runtime Class\n//\n// Status constants are loaded as global variables by StatusCode.js (loaded before this file)\n// In Node.js bundles, StatusCode.js is concatenated before this file\nif (typeof StatusCode === 'undefined' || typeof SUCCESS_STATUS === 'undefined' || typeof createErrorStatus === 'undefined') {\n  throw new Error('StatusCode.js must be loaded before BitmapText.js');\n}\n//\n// This is a STATIC CORE RUNTIME class designed for minimal bundle size and zero-ceremony usage.\n// It provides essential text rendering capabilities for consuming pre-built bitmap fonts.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - All methods are static - no instantiation needed\n// - Contains no font generation code to keep bundle size minimal\n//\n// ARCHITECTURE:\n// - Facade pattern: Delegates storage to AtlasDataStore/FontMetricsStore, font loading to FontLoader\n// - fontDirectory configuration owned by FontLoader (this class delegates get/set)\n// - Auto-detects environment (browser vs Node.js) for canvas creation\n// - Draws text by looking up glyphs from atlases and positioning them with metrics/kerning\n// - Uses textBaseline='bottom' positioning (y = bottom of text bounding box)\n// - Supports placeholder rectangles when atlases are missing but metrics are available\n//\n// CANVAS FACTORY (Node.js only):\n// - Node.js has no DOM, thus no native Canvas\n// - BitmapText needs Canvas to:\n//   1. Load atlas images from files\n//   2. Scan pixels to find tight bounding boxes for each glyph\n//   3. Create tight atlas from scanned data\n// - Cannot pass class reference: HTMLCanvasElement is NOT constructible\n//   (new HTMLCanvasElement() throws \"Illegal constructor\")\n// - Must pass factory function: () => new Canvas()\n// - Browser: via document.createElement('canvas')\n// - Node.js: Must configure with canvas-mock providing Canvas constructor\n//\n// USAGE:\n// - Zero configuration for browser: Just call BitmapText.drawTextFromAtlas()\n// - Node.js: Optionally set canvas factory: BitmapText.setCanvasFactory(() => new Canvas())\n// - Loading: BitmapText.loadFont(idString) or BitmapText.loadFonts([idStrings])\n// - Query: BitmapText.hasFont(idString), BitmapText.getLoadedFonts()\n//\nclass BitmapText {\n  // ============================================\n  // Static Constants\n  // ============================================\n\n  // Kerning unit divisor (kerning measured in 1/1000 em units)\n  static KERNING_UNIT_DIVISOR = 1000;\n\n  // Minimum renderable font size (sizes < 8.5 use interpolated metrics from 8.5)\n  static MIN_RENDERABLE_SIZE = 8.5;\n\n  // Font asset naming conventions\n  static METRICS_PREFIX = 'metrics-';\n  static ATLAS_PREFIX = 'atlas-';\n  static WEBP_EXTENSION = '.webp';\n  static QOI_EXTENSION = '.qoi';\n  static JS_EXTENSION = '.js';\n\n  // Default text color (matches TextProperties default)\n  static #DEFAULT_TEXT_COLOR = '#000000';\n\n  /**\n   * Fast font-invariant character detection helper\n   * Uses string.includes() for ~1-2ns lookup performance\n   *\n   * @private\n   * @param {string} char - Character to check\n   * @returns {boolean} True if character is font-invariant\n   */\n  static #isInvariantCharacter(char) {\n    return CharacterSets.FONT_INVARIANT_CHARS.includes(char);\n  }\n\n  /**\n   * Calculate optimal grid dimensions for atlas layout\n   * Uses square-ish approach (ceil(sqrt(N))) to minimize max dimension\n   *\n   * For 204 characters: 15 columns × 14 rows (6 empty cells)\n   *\n   * @param {number} characterCount - Number of characters to arrange\n   * @returns {{columns: number, rows: number}} Grid dimensions\n   */\n  static calculateOptimalGridDimensions(characterCount) {\n    if (characterCount <= 0) {\n      throw new Error('BitmapText: Character count must be positive');\n    }\n\n    // Square-ish grid: minimizes max dimension while keeping layout simple\n    const columns = Math.ceil(Math.sqrt(characterCount));\n    const rows = Math.ceil(characterCount / columns);\n\n    return { columns, rows };\n  }\n\n  // ============================================\n  // Static Storage & Configuration\n  // ============================================\n\n  // Font data storage delegated to AtlasDataStore and FontMetricsStore\n  // (no private maps - stores are the single source of truth)\n\n  // Configuration (user overrides, delegates to FontLoader for defaults)\n  // fontDirectory is owned by FontLoader (it's the component that uses it)\n  static #canvasFactory = (typeof document !== 'undefined' ? () => document.createElement('canvas') : null);         // Optional user override\n\n  // Rendering resources (lazy-initialized on first render)\n  static #coloredGlyphCanvas = null;    // Shared scratch canvas for coloring\n  static #coloredGlyphCtx = null;       // 2D context for scratch canvas\n\n  // Font loader (platform-specific, set at runtime)\n  static #fontLoader = null;            // FontLoaderBrowser or FontLoaderNode\n\n  // ============================================\n  // Configuration API (Optional)\n  // ============================================\n\n  /**\n   * Set font directory (overrides default)\n   * Delegates to FontLoader which owns this configuration\n   * @param {string} path - Path to font assets directory\n   */\n  static setFontDirectory(path) {\n    BitmapText.#ensureFontLoader();\n    BitmapText.#fontLoader.setFontDirectory(path);\n  }\n\n  /**\n   * Get font directory (returns override or default)\n   * Delegates to FontLoader which owns this configuration\n   * @returns {string} Font directory path\n   */\n  static getFontDirectory() {\n    BitmapText.#ensureFontLoader();\n    return BitmapText.#fontLoader.getFontDirectory();\n  }\n\n  /**\n   * Override canvas factory (Node.js only, testing, or custom canvas implementations)\n   *\n   * WHY A FACTORY FUNCTION?\n   * HTMLCanvasElement is not constructible in JavaScript - new HTMLCanvasElement()\n   * throws \"Illegal constructor\". Browser uses document.createElement('canvas'),\n   * Node.js requires canvas-mock providing Canvas constructor.\n   *\n   * @param {Function} factory - Function that returns a canvas instance\n   * @example\n   * // Node.js\n   * BitmapText.setCanvasFactory(() => new Canvas());\n   *\n   * // Browser (custom implementation)\n   * BitmapText.setCanvasFactory(() => new OffscreenCanvas(0, 0));\n   */\n  static setCanvasFactory(factory) {\n    BitmapText.#canvasFactory = factory;\n    // Reset canvas to use new factory on next render\n    BitmapText.#coloredGlyphCanvas = null;\n    BitmapText.#coloredGlyphCtx = null;\n  }\n\n  /**\n   * Get canvas factory (with fallback to platform default)\n   *\n   * USAGE PATTERN:\n   * const canvas = BitmapText.getCanvasFactory()();  // Note double invocation\n   *   - First ():  Gets the factory function\n   *   - Second (): Invokes factory to create canvas\n   *\n   * @returns {Function} Canvas factory function\n   */\n  static getCanvasFactory() {\n    return BitmapText.#canvasFactory;\n  }\n\n  /**\n   * Configure multiple options at once\n   * @param {Object} options - Configuration options\n   * @param {string} [options.fontDirectory] - Font assets directory\n   * @param {Function} [options.canvasFactory] - Canvas factory function\n   */\n  static configure(options = {}) {\n    if (options.fontDirectory !== undefined) {\n      BitmapText.setFontDirectory(options.fontDirectory);\n    }\n    if (options.canvasFactory !== undefined) {\n      BitmapText.setCanvasFactory(options.canvasFactory);\n    }\n  }\n\n  /**\n   * Ensure font loader is initialized\n   * @private\n   */\n  static #ensureFontLoader() {\n    if (BitmapText.#fontLoader) {\n      return;\n    }\n\n    // Check if platform-specific FontLoader is available\n    if (typeof FontLoader === 'undefined') {\n      throw new Error(\n        'BitmapText: FontLoader not loaded.\\n' +\n        'Ensure platform-specific FontLoader is included before BitmapText.js:\\n' +\n        '  - Browser: <script src=\"src/platform/FontLoader-browser.js\"></script>\\n' +\n        '  - Node.js: Include src/platform/FontLoader-node.js in bundle'\n      );\n    }\n\n    BitmapText.#fontLoader = FontLoader;\n  }\n\n  /**\n   * Check if font size requires minimum size redirection\n   * @param {number} fontSize - Font size in CSS pixels\n   * @returns {boolean} True if size < 8.5 and should use interpolated metrics\n   * @private\n   */\n  static #shouldUseMinSize(fontSize) {\n    return fontSize < BitmapText.MIN_RENDERABLE_SIZE;\n  }\n\n  /**\n   * Create FontProperties with minimum renderable size (8.5)\n   * @param {FontProperties} fontProperties - Original font properties\n   * @returns {FontProperties} New FontProperties with size 8.5\n   * @private\n   */\n  static #createFontPropsAtMinSize(fontProperties) {\n    return new FontProperties(\n      fontProperties.pixelDensity,\n      fontProperties.fontFamily,\n      fontProperties.fontStyle,\n      fontProperties.fontWeight,\n      BitmapText.MIN_RENDERABLE_SIZE\n    );\n  }\n\n  /**\n   * Create interpolated FontMetrics wrapper for sizes < 8.5\n   * Returns a wrapper object that interpolates all metric values proportionally\n   * @param {FontMetrics} metricsAt8_5 - Font metrics at size 8.5\n   * @param {number} targetSize - Desired font size (< 8.5)\n   * @returns {InterpolatedFontMetrics} Interpolated metrics wrapper with FontMetrics-compatible interface\n   * @private\n   */\n  static #createInterpolatedFontMetrics(metricsAt8_5, targetSize) {\n    return new InterpolatedFontMetrics(metricsAt8_5, targetSize);\n  }\n\n  /**\n   * Redirect idString for sizes < 8.5 to size 8.5\n   * @param {string} idString - Original font ID string\n   * @param {boolean} silent - If true, suppress console warning\n   * @returns {{redirected: boolean, idString: string, originalSize: number}} Redirection result\n   * @private\n   */\n  static #redirectIdStringIfNeeded(idString, silent = false) {\n    const fontProps = FontProperties.fromIDString(idString);\n\n    if (BitmapText.#shouldUseMinSize(fontProps.fontSize)) {\n      const minSizeProps = BitmapText.#createFontPropsAtMinSize(fontProps);\n      if (!silent) {\n        console.warn(\n          `BitmapText: Font size ${fontProps.fontSize}px requested. Redirecting to size ${BitmapText.MIN_RENDERABLE_SIZE}px ` +\n          `(minimum supported size). Sizes < ${BitmapText.MIN_RENDERABLE_SIZE}px render using interpolated placeholder rectangles.`\n        );\n      }\n      return {\n        redirected: true,\n        idString: minSizeProps.idString,\n        originalSize: fontProps.fontSize\n      };\n    }\n\n    return {\n      redirected: false,\n      idString: idString,\n      originalSize: fontProps.fontSize\n    };\n  }\n\n  // ============================================\n  // Registration API (called by asset files)\n  // ============================================\n\n  /**\n   * Convert registration parameters to ID string\n   * Shared helper for registerMetrics and registerAtlas\n   * @private\n   * @param {number} density - Pixel density\n   * @param {string} fontFamily - Font family name\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric)\n   * @param {number} size - Font size\n   * @returns {string} ID string (e.g., \"density-1-0-Arial-style-normal-weight-normal-size-19-0\")\n   */\n  static #parametersToIDString(density, fontFamily, styleIdx, weightIdx, size) {\n    // Decompress style and weight indices\n    const style = styleIdx === 0 ? 'normal' : (styleIdx === 1 ? 'italic' : 'oblique');\n    const weight = weightIdx === 0 ? 'normal' : (weightIdx === 1 ? 'bold' : String(weightIdx));\n\n    // Format density (1 → 1-0, 1.5 → 1-5)\n    const densityStr = String(density);\n    const densityFormatted = densityStr.includes('.') ? densityStr.replace('.', '-') : `${densityStr}-0`;\n\n    // Format size (18 → 18-0, 18.5 → 18-5)\n    const sizeStr = String(size);\n    const sizeFormatted = sizeStr.includes('.') ? sizeStr.replace('.', '-') : `${sizeStr}-0`;\n\n    // Reconstruct full ID\n    return `density-${densityFormatted}-${fontFamily}-style-${style}-weight-${weight}-size-${sizeFormatted}`;\n  }\n\n  /**\n   * Register font metrics from metrics-*.js file\n   * TIER 6c: Multi-parameter format only (no legacy support)\n   *\n   * @param {number} density - Pixel density (e.g., 1 or 1.5)\n   * @param {string} fontFamily - Font family name (e.g., 'Arial')\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric weight)\n   * @param {number} size - Font size (e.g., 18 or 18.5)\n   * @param {Array} compactedData - Tier 6c compacted metrics array\n   */\n  static registerMetrics(density, fontFamily, styleIdx, weightIdx, size, compactedData) {\n    BitmapText.#ensureFontLoader();\n    const fullIDString = BitmapText.#parametersToIDString(density, fontFamily, styleIdx, weightIdx, size);\n    FontLoaderBase.registerMetrics(fullIDString, compactedData, BitmapText);\n  }\n\n  /**\n   * Register atlas from atlas-*.js file (base64 only, positioning reconstructed later)\n   * Delegates to FontLoader which handles platform-specific details\n   * @param {number} density - Pixel density (e.g., 1 or 1.5)\n   * @param {string} fontFamily - Font family name (e.g., 'Arial')\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric weight)\n   * @param {number} size - Font size (e.g., 18 or 18.5)\n   * @param {string} base64Data - Base64-encoded atlas data\n   */\n  static registerAtlas(density, fontFamily, styleIdx, weightIdx, size, base64Data) {\n    BitmapText.#ensureFontLoader();\n    const fullIDString = BitmapText.#parametersToIDString(density, fontFamily, styleIdx, weightIdx, size);\n    FontLoaderBase.registerAtlas(fullIDString, base64Data);\n  }\n\n  // ============================================\n  // Rendering API\n  // ============================================\n\n  /**\n   * Measure text dimensions\n   *\n   * RETURN VALUES: All measurements are in CSS PIXELS\n   * - width, actualBoundingBox* values are CSS pixels\n   * - Measurements are independent of canvas setup or context transforms\n   * - To convert to physical pixels: multiply by fontProperties.pixelDensity\n   *\n   * NOTE: This method does NOT draw anything and is NOT affected by context transforms.\n   * It purely calculates metrics based on font data.\n   *\n   * The metrics object has the same shape and meaning as the TextMetrics object (see\n   * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics ):\n   * - width: sum of character advancements (minus kerning adjustments)\n   * - actualBoundingBoxLeft: actualBoundingBoxLeft of first character\n   * - actualBoundingBoxRight: sum of advancements (excluding last) + last char's actualBoundingBoxRight\n   *\n   * @param {string} text - Text to measure\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {TextProperties} [textProperties] - Text rendering configuration (optional)\n   * @returns {{metrics: {width: number, actualBoundingBoxLeft: number, actualBoundingBoxRight: number, actualBoundingBoxAscent: number, actualBoundingBoxDescent: number, fontBoundingBoxAscent: number, fontBoundingBoxDescent: number}|null, status: {code: number, missingChars?: Set}}}\n   *   All numeric values in metrics are CSS pixels\n   */\n  static measureText(text, fontProperties, textProperties) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n\n    // FAST PATH: Handle empty text (100% success)\n    if (text.length === 0) {\n      return {\n        metrics: {\n          width: 0,\n          actualBoundingBoxLeft: 0,\n          actualBoundingBoxRight: 0,\n          actualBoundingBoxAscent: 0,\n          actualBoundingBoxDescent: 0,\n          fontBoundingBoxAscent: 0,\n          fontBoundingBoxDescent: 0\n        },\n        status: SUCCESS_STATUS\n      };\n    }\n\n    // Check if FontMetrics exists at all\n    let fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n\n    // If metrics not found and size < 8.5, try interpolating from size 8.5\n    if (!fontMetrics && BitmapText.#shouldUseMinSize(fontProperties.fontSize)) {\n      const minSizeProps = BitmapText.#createFontPropsAtMinSize(fontProperties);\n      const metricsAt8_5 = FontMetricsStore.getFontMetrics(minSizeProps);\n\n      if (metricsAt8_5) {\n        // Create interpolated metrics wrapper\n        fontMetrics = BitmapText.#createInterpolatedFontMetrics(metricsAt8_5, fontProperties.fontSize);\n      } else {\n        // Even 8.5 metrics don't exist\n        return {\n          metrics: null,\n          status: createErrorStatus(StatusCode.NO_METRICS, {\n            requiresMinSize: true,\n            requestedSize: fontProperties.fontSize,\n            minSize: BitmapText.MIN_RENDERABLE_SIZE\n          })\n        };\n      }\n    } else if (!fontMetrics) {\n      return {\n        metrics: null,\n        status: createErrorStatus(StatusCode.NO_METRICS)\n      };\n    }\n\n    // PRE-CREATE font-invariant font properties ONCE for potential auto-redirect\n    const invariantFontProps = new FontProperties(\n      fontProperties.pixelDensity,\n      CharacterSets.INVARIANT_FONT_FAMILY,\n      'normal',\n      'normal',\n      fontProperties.fontSize\n    );\n\n    // PRE-FETCH font-invariant font data\n    let invariantFontMetrics = FontMetricsStore.getFontMetrics(invariantFontProps);\n\n    // If font-invariant font not found and size < 8.5, try interpolating from size 8.5\n    if (!invariantFontMetrics && BitmapText.#shouldUseMinSize(fontProperties.fontSize)) {\n      const invariantMinSizeProps = BitmapText.#createFontPropsAtMinSize(invariantFontProps);\n      const invariantMetricsAt8_5 = FontMetricsStore.getFontMetrics(invariantMinSizeProps);\n\n      if (invariantMetricsAt8_5) {\n        // Create interpolated metrics wrapper for font-invariant font\n        invariantFontMetrics = BitmapText.#createInterpolatedFontMetrics(invariantMetricsAt8_5, fontProperties.fontSize);\n      }\n    }\n\n    const hasInvariantFont = invariantFontMetrics !== null;\n\n    // Scan text for missing glyphs (excluding spaces which are handled specially)\n    // Check each character against the appropriate font (base or font-invariant)\n    const missingChars = new Set();\n    for (const char of text) {\n      if (char !== ' ') {\n        // Determine which font should handle this character\n        const isInvariant = hasInvariantFont && BitmapText.#isInvariantCharacter(char);\n        const checkFontMetrics = isInvariant ? invariantFontMetrics : fontMetrics;\n\n        if (!checkFontMetrics.hasGlyph(char)) {\n          missingChars.add(char);\n        }\n      }\n    }\n\n    // If any glyphs missing, can't calculate accurate metrics\n    if (missingChars.size > 0) {\n      return {\n        metrics: null,\n        status: createErrorStatus(StatusCode.PARTIAL_METRICS, {\n          missingChars: missingChars\n        })\n      };\n    }\n\n    // SUCCESS PATH: Calculate metrics normally\n    const chars = [...text];\n    let width_CssPx = 0;\n\n    // Determine font for first character\n    const firstCharIsInvariant = hasInvariantFont && BitmapText.#isInvariantCharacter(chars[0]);\n    let currentFontMetrics = firstCharIsInvariant ? invariantFontMetrics : fontMetrics;\n    let currentFontProps = firstCharIsInvariant ? invariantFontProps : fontProperties;\n\n    let characterMetrics = currentFontMetrics.getCharacterMetrics(chars[0]);\n    const actualBoundingBoxLeft_CssPx = characterMetrics.actualBoundingBoxLeft;\n    let actualBoundingBoxAscent = 0;\n    let actualBoundingBoxDescent = 0;\n    let actualBoundingBoxRight_CssPx;\n    let advancement_CssPx = 0;\n\n    for (let i = 0; i < chars.length; i++) {\n      const char = chars[i];\n      const nextChar = chars[i + 1];\n\n      // FAST CHECK: Is this a font-invariant character? Switch fonts if needed\n      const isInvariant = hasInvariantFont && BitmapText.#isInvariantCharacter(char);\n      if (isInvariant && currentFontProps !== invariantFontProps) {\n        currentFontMetrics = invariantFontMetrics;\n        currentFontProps = invariantFontProps;\n      } else if (!isInvariant && currentFontProps !== fontProperties) {\n        currentFontMetrics = fontMetrics;\n        currentFontProps = fontProperties;\n      }\n\n      characterMetrics = currentFontMetrics.getCharacterMetrics(char);\n\n      actualBoundingBoxAscent = Math.max(actualBoundingBoxAscent, characterMetrics.actualBoundingBoxAscent);\n      actualBoundingBoxDescent = Math.min(actualBoundingBoxDescent, characterMetrics.actualBoundingBoxDescent);\n\n      advancement_CssPx = this.calculateAdvancement_CssPx(currentFontMetrics, currentFontProps, char, nextChar, textProperties, characterMetrics);\n      width_CssPx += advancement_CssPx;\n    }\n\n    actualBoundingBoxRight_CssPx = width_CssPx - advancement_CssPx;\n    actualBoundingBoxRight_CssPx += characterMetrics.actualBoundingBoxRight;\n\n    return {\n      metrics: {\n        width: width_CssPx,\n        actualBoundingBoxLeft: actualBoundingBoxLeft_CssPx,\n        actualBoundingBoxRight: actualBoundingBoxRight_CssPx,\n        actualBoundingBoxAscent,\n        actualBoundingBoxDescent,\n        fontBoundingBoxAscent: characterMetrics.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: characterMetrics.fontBoundingBoxDescent\n      },\n      status: SUCCESS_STATUS\n    };\n  }\n\n  /**\n   * Draw text using pre-rendered glyphs from atlas\n   *\n   * COORDINATE SYSTEM:\n   * - All coordinates are in CSS PIXELS relative to canvas origin (0,0)\n   * - BitmapText IGNORES all context transforms (scale, translate, rotate, etc.)\n   * - Internal conversion: physicalPixels = cssPixels × fontProperties.pixelDensity\n   * - Transform is reset to identity during rendering, then restored\n   *\n   * TRANSFORM BEHAVIOR:\n   * BitmapText will reset the context transform to identity before drawing,\n   * meaning any ctx.scale(), ctx.translate(), ctx.rotate(), etc. are IGNORED.\n   * This ensures pixel-perfect rendering at exact physical pixel positions.\n   *\n   * Example:\n   *   ctx.scale(2, 2);          // User scales context\n   *   ctx.translate(100, 50);    // User translates\n   *   BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 30, fontProps);\n   *   // Text renders at (10, 30) CSS pixels from origin, NOT (120, 80)!\n   *   // Transforms are ignored - coordinates are always absolute\n   *\n   * PIXEL DENSITY:\n   * - Specified via fontProperties.pixelDensity (e.g., window.devicePixelRatio)\n   * - Canvas should be sized: canvas.width = cssWidth × pixelDensity\n   * - Do NOT use ctx.scale(dpr, dpr) - BitmapText handles density internally\n   *\n   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context (transform will be temporarily reset)\n   * @param {string} text - Text to render\n   * @param {number} x_CssPx - X position in CSS pixels (absolute, from canvas origin)\n   * @param {number} y_CssPx - Y position in CSS pixels (absolute, from canvas origin, bottom baseline)\n   * @param {FontProperties} fontProperties - Font configuration (including pixelDensity)\n   * @param {TextProperties} [textProperties] - Text rendering configuration (optional)\n   * @returns {{rendered: boolean, status: {code: number, missingChars?: Set, missingAtlasChars?: Set, placeholdersUsed?: boolean}}}\n   *   Rendering result and status information\n   */\n  static drawTextFromAtlas(ctx, text, x_CssPx, y_CssPx, fontProperties, textProperties = null) {\n    textProperties = textProperties || new TextProperties();\n\n    // Lazy-initialize canvas on first render\n    if (!BitmapText.#coloredGlyphCanvas) {\n      // Explicit factory invocation: get factory, then call it\n      BitmapText.#coloredGlyphCanvas = BitmapText.getCanvasFactory()();\n      BitmapText.#coloredGlyphCtx = BitmapText.#coloredGlyphCanvas.getContext('2d');\n    }\n\n    // Check FontMetrics availability first\n    let fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n    let forceInvalidAtlas = false;\n\n    // For sizes < 8.5, always use interpolated metrics from 8.5 and force placeholder mode\n    if (BitmapText.#shouldUseMinSize(fontProperties.fontSize)) {\n      const minSizeProps = BitmapText.#createFontPropsAtMinSize(fontProperties);\n      const metricsAt8_5 = FontMetricsStore.getFontMetrics(minSizeProps);\n\n      if (!metricsAt8_5) {\n        // Size 8.5 metrics don't exist - can't render\n        return {\n          rendered: false,\n          status: createErrorStatus(StatusCode.NO_METRICS, {\n            requiresMinSize: true,\n            requestedSize: fontProperties.fontSize,\n            minSize: BitmapText.MIN_RENDERABLE_SIZE\n          })\n        };\n      }\n\n      // Create interpolated metrics wrapper and force placeholder mode\n      fontMetrics = BitmapText.#createInterpolatedFontMetrics(metricsAt8_5, fontProperties.fontSize);\n      forceInvalidAtlas = true; // Always use placeholders for sizes < 8.5\n    } else if (!fontMetrics) {\n      // Normal size but metrics not found\n      return {\n        rendered: false,\n        status: createErrorStatus(StatusCode.NO_METRICS)\n      };\n    }\n\n    // PRE-CREATE font-invariant font properties ONCE (not per-character!)\n    // This avoids object allocation in hot rendering loop\n    const invariantFontProps = new FontProperties(\n      fontProperties.pixelDensity,\n      CharacterSets.INVARIANT_FONT_FAMILY,\n      'normal',  // Always normal style for font-invariant characters\n      'normal',  // Always normal weight for font-invariant characters\n      fontProperties.fontSize\n    );\n\n    // PRE-FETCH font-invariant font data ONCE\n    let invariantFontMetrics = FontMetricsStore.getFontMetrics(invariantFontProps);\n\n    // If font-invariant font not found and size < 8.5, try interpolating from size 8.5\n    if (!invariantFontMetrics && BitmapText.#shouldUseMinSize(fontProperties.fontSize)) {\n      const invariantMinSizeProps = BitmapText.#createFontPropsAtMinSize(invariantFontProps);\n      const invariantMetricsAt8_5 = FontMetricsStore.getFontMetrics(invariantMinSizeProps);\n\n      if (invariantMetricsAt8_5) {\n        // Create interpolated metrics wrapper for font-invariant font\n        invariantFontMetrics = BitmapText.#createInterpolatedFontMetrics(invariantMetricsAt8_5, fontProperties.fontSize);\n      }\n    }\n\n    const hasInvariantFont = invariantFontMetrics !== null;\n\n    // Scan for missing metrics (can't render without metrics)\n    // Check each character against the appropriate font (base or font-invariant)\n    const missingMetricsChars = new Set();\n    for (const char of text) {\n      if (char !== ' ') {\n        // Determine which font should handle this character\n        const isInvariant = hasInvariantFont && BitmapText.#isInvariantCharacter(char);\n        const checkFontMetrics = isInvariant ? invariantFontMetrics : fontMetrics;\n\n        if (!checkFontMetrics.hasGlyph(char)) {\n          missingMetricsChars.add(char);\n        }\n      }\n    }\n\n    if (missingMetricsChars.size > 0) {\n      return {\n        rendered: false,\n        status: createErrorStatus(StatusCode.PARTIAL_METRICS, {\n          missingChars: missingMetricsChars\n        })\n      };\n    }\n\n    // Check atlas data availability (force invalid for sizes < 8.5)\n    let atlasData = forceInvalidAtlas ? null : AtlasDataStore.getAtlasData(fontProperties);\n    const atlasValid = forceInvalidAtlas ? false : BitmapText.#isValidAtlas(atlasData);\n\n    const invariantAtlasData = invariantFontMetrics ?\n      AtlasDataStore.getAtlasData(invariantFontProps) : null;\n    const invariantAtlasValid = invariantFontMetrics ?\n      BitmapText.#isValidAtlas(invariantAtlasData) : false;\n\n    // Track current font to minimize redundant lookups\n    let currentFontProps = fontProperties;\n    let currentFontMetrics = fontMetrics;\n    let currentAtlasData = atlasData;\n    let currentAtlasValid = atlasValid;\n\n    // Track which glyphs are missing from atlas (for partial atlas status)\n    const missingAtlasChars = new Set();\n    let placeholdersUsed = false;\n\n    // CRITICAL: Reset transform to identity for pixel-perfect physical rendering\n    // BitmapText ignores ALL context transforms (scale, translate, rotate, etc.)\n    // Coordinates are ALWAYS relative to canvas origin (0,0)\n    // This ensures:\n    // 1. Predictable positioning regardless of context state\n    // 2. Pixel-perfect rendering at physical pixel boundaries\n    // 3. No double-scaling when users apply ctx.scale(dpr, dpr)\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);  // Reset to identity matrix\n\n    // Render text\n    const chars = [...text];\n    const textColor = textProperties.textColor;\n\n    // BASELINE SUPPORT: Convert user's y from their chosen baseline to 'bottom' baseline\n    // Get baseline data from first character (baseline values are identical for all characters in a font)\n    // Use first actual character, or fallback to space character for baseline calculation\n    const firstChar = chars.find(c => fontMetrics.hasGlyph(c)) || chars[0];\n    const characterMetricsForBaseline = fontMetrics.getCharacterMetrics(firstChar);\n    const baselineOffset_CssPx = characterMetricsForBaseline\n      ? BitmapText.#calculateBaselineOffsetToBottom(textProperties.textBaseline, characterMetricsForBaseline)\n      : 0;\n\n    // ALIGNMENT SUPPORT: Convert user's x from their chosen alignment to 'left' alignment\n    // Measure text width to calculate alignment offset (measureText accounts for kerning if enabled)\n    let alignmentOffset_CssPx = 0;\n    if (textProperties.textAlign !== 'left') {\n      const measureResult = BitmapText.measureText(text, fontProperties, textProperties);\n      if (measureResult.status.code === 0 && measureResult.metrics) {\n        // Successfully measured text - calculate alignment offset\n        alignmentOffset_CssPx = BitmapText.#calculateAlignmentOffsetToLeft(\n          textProperties.textAlign,\n          measureResult.metrics.width\n        );\n      } else {\n        // Failed to measure (missing glyphs, etc.) - default to left alignment (offset = 0)\n        // Text will still render but won't be aligned as requested\n        console.warn(`BitmapText: Failed to measure text for alignment '${textProperties.textAlign}', defaulting to left alignment`);\n      }\n    }\n\n    // Apply baseline and alignment offsets, then convert to physical pixels\n    const position_PhysPx = {\n      x: (x_CssPx + alignmentOffset_CssPx) * fontProperties.pixelDensity,\n      y: (y_CssPx + baselineOffset_CssPx) * fontProperties.pixelDensity\n    };\n\n    // OPTIMIZATION: Batch colored text rendering (single composite operation)\n    // Check if we're rendering colored text with a valid atlas\n    const isColoredText = textColor !== BitmapText.#DEFAULT_TEXT_COLOR;\n    if (isColoredText && atlasValid) {\n      // Use optimized batch rendering for colored text\n      // This reduces composite operations from N (per character) to 1 (per text string)\n      const batchResult = BitmapText.#drawColoredTextBatched(\n        ctx, text, chars, position_PhysPx, atlasData, fontMetrics, fontProperties, textProperties\n      );\n\n      // Merge batch results into tracking sets\n      batchResult.missingAtlasChars.forEach(char => missingAtlasChars.add(char));\n      placeholdersUsed = placeholdersUsed || batchResult.placeholdersUsed;\n\n      // Skip character-by-character loop for colored text\n    } else {\n      // Black text or invalid atlas: use character-by-character rendering\n      for (let i = 0; i < chars.length; i++) {\n        const currentChar = chars[i];\n        const nextChar = chars[i + 1];\n\n        // FAST CHECK: Is this a font-invariant character? (string.includes on 18 chars = ~1-2ns)\n        const isInvariant = hasInvariantFont && BitmapText.#isInvariantCharacter(currentChar);\n\n        // Switch font ONLY if needed (avoids redundant assignments)\n        if (isInvariant && currentFontProps !== invariantFontProps) {\n          currentFontProps = invariantFontProps;\n          currentFontMetrics = invariantFontMetrics;\n          currentAtlasData = invariantAtlasData;\n          currentAtlasValid = invariantAtlasValid;\n        } else if (!isInvariant && currentFontProps !== fontProperties) {\n          // Switch back to base font\n          currentFontProps = fontProperties;\n          currentFontMetrics = fontMetrics;\n          currentAtlasData = atlasData;\n          currentAtlasValid = atlasValid;\n        }\n\n        // Check if atlas has a glyph for this character (excluding spaces)\n        if (currentChar !== ' ') {\n          if (!currentAtlasValid || !currentAtlasData.hasPositioning(currentChar)) {\n            missingAtlasChars.add(currentChar);\n            placeholdersUsed = true;\n          }\n        }\n\n        // Draw using appropriate font (either real glyph or placeholder)\n        BitmapText.#drawCharacter(ctx,\n          currentChar,\n          position_PhysPx,\n          currentAtlasData,\n          currentFontMetrics,\n          textColor\n        );\n\n        // Calculate advancement using current font's metrics\n        position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(\n          currentFontMetrics, currentFontProps, currentChar, nextChar, textProperties);\n      }\n    }\n\n    // Determine status code\n    let statusCode;\n    if (!atlasValid) {\n      statusCode = StatusCode.NO_ATLAS;\n    } else if (missingAtlasChars.size > 0) {\n      statusCode = StatusCode.PARTIAL_ATLAS;\n    } else {\n      // Complete success\n      ctx.restore();  // Restore original transform\n      return {\n        rendered: true,\n        status: SUCCESS_STATUS\n      };\n    }\n\n    // Return detailed status for non-success cases\n    ctx.restore();  // Restore original transform\n    return {\n      rendered: true,\n      status: createErrorStatus(statusCode, {\n        missingAtlasChars: missingAtlasChars.size > 0 ? missingAtlasChars : undefined,\n        placeholdersUsed: placeholdersUsed\n      })\n    };\n  }\n\n  // ============================================\n  // Internal Rendering Helpers\n  // ============================================\n  // Get the advancement of the i-th character i.e. needed AFTER the i-th character\n  // so that the i+1-th character is drawn at the right place\n  // This depends on both the advancement specified by the glyph of the i-th character\n  // AND by the kerning correction depending on the pair of the i-th and i+1-th characters\n\n  static calculateAdvancement_CssPx(fontMetrics, fontProperties, char, nextChar, textProperties, characterMetrics = null) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n    if (!characterMetrics) {\n      characterMetrics = fontMetrics.getCharacterMetrics(char);\n    }\n    let x_CssPx = 0;\n\n    // LIMITATION: Only handles standard space (U+0020), not other Unicode space characters\n\n    // Handle space first ------------------------------------------\n    // You could add the space advancement as we got it from the browser\n    // (remember that the space doesn't have the tightCanvasBox)\n    // but since at small sizes we meddle with kerning quite a bit, we want\n    // to also meddle with this to try to make the width of text\n    // similar to what the browser paints normally.\n    // console.log(characterMetrics.width + \" \" + x_CSS_Px);\n    // deal with the size of the \" \" character\n    if (char === \" \") {\n      const spaceAdvancementOverrideForSmallSizesInPx_CssPx = fontMetrics.getSpaceAdvancementOverride();\n      if (spaceAdvancementOverrideForSmallSizesInPx_CssPx !== null) {\n        x_CssPx += spaceAdvancementOverrideForSmallSizesInPx_CssPx;\n      }\n      else {\n        x_CssPx += characterMetrics.width;\n      }\n    }\n    // Non-space characters\n    else {\n      x_CssPx += characterMetrics.width;\n    }\n\n    // Apply kerning correction\n    let kerningCorrection = BitmapText.#getKerningCorrection(fontMetrics, char, nextChar, textProperties);\n\n    // Kerning adjustments are measured in 1/1000 em units (font-size relative).\n    // We convert to pixels by multiplying font size by the kerning correction\n    // and dividing by 1000. This keeps kerning proportional to font size while\n    // maintaining precision in the stored kerning values.\n    x_CssPx -= fontProperties.fontSize * kerningCorrection / BitmapText.KERNING_UNIT_DIVISOR;\n\n    // For interpolated metrics (sizes < 8.5), preserve float precision for linear scaling\n    // For normal metrics (sizes ≥ 8.5), round to integers for crisp pixel-aligned rendering\n    if (fontMetrics.isInterpolatedMetrics) {\n      return x_CssPx;  // Float positioning for placeholder rectangles\n    } else {\n      return Math.round(x_CssPx);  // Integer positioning for crisp atlas glyphs\n    }\n  }\n\n  static #getKerningCorrection(fontMetrics, char, nextChar, textProperties) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n\n    if (textProperties.isKerningEnabled && nextChar) {\n      return fontMetrics.getKerningAdjustment(char, nextChar);\n    }\n\n    return 0;\n  }\n\n  /**\n   * Calculate y-offset to convert from specified textBaseline to 'bottom' baseline\n   *\n   * INTERNAL REFERENCE: BitmapText uses 'bottom' baseline for all dy calculations.\n   * All glyph dy offsets are pre-calculated assuming y is at the bottom of the em square.\n   * This method converts user's chosen baseline to that internal reference.\n   *\n   * COORDINATE SYSTEM: y increases downward (Canvas convention)\n   * All baseline distances are in CSS pixels and relative to alphabetic baseline (ab = 0)\n   *\n   * BASELINE GEOMETRY:\n   * - top: At fontBoundingBoxAscent above alphabetic\n   * - hanging: At hangingBaseline above alphabetic (Tibetan, Devanagari)\n   * - middle: At (fontBoundingBoxAscent - fontBoundingBoxDescent) / 2 above alphabetic\n   * - alphabetic: At 0 (reference point for Latin scripts)\n   * - ideographic: At ideographicBaseline below alphabetic (CJK scripts, negative value)\n   * - bottom: At fontBoundingBoxDescent below alphabetic\n   *\n   * @private\n   * @param {string} textBaseline - User's chosen baseline ('top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom')\n   * @param {Object} characterMetrics - Metrics containing baseline data (fba, fbd, hb, ab, ib)\n   * @returns {number} Offset in CSS pixels to add to y coordinate to reach 'bottom' baseline\n   */\n  static #calculateBaselineOffsetToBottom(textBaseline, characterMetrics) {\n    // Extract baseline measurements from character metrics\n    // These values are captured from browser's TextMetrics during font generation\n    const fba = characterMetrics.fontBoundingBoxAscent;    // Distance from alphabetic to top of em square (positive)\n    const fbd = characterMetrics.fontBoundingBoxDescent;   // Distance from alphabetic to bottom of em square (positive, downward)\n    const hb = characterMetrics.hangingBaseline;           // Distance from alphabetic to hanging baseline (positive, upward)\n    const ib = characterMetrics.ideographicBaseline;       // Distance from alphabetic to ideographic baseline (negative, downward)\n\n    // Convert from user's baseline to bottom baseline\n    // Formulas derived from geometric relationships in em square coordinate system\n    switch (textBaseline) {\n      case 'top':\n        // Top of em square → Bottom of em square\n        // Move down by full em height: ascent + descent\n        return fba + fbd;\n\n      case 'hanging':\n        // Hanging baseline → Bottom of em square\n        // Hanging is hb above alphabetic, bottom is fbd below alphabetic\n        // Total distance: hb (up to alphabetic) + fbd (down to bottom)\n        return hb + fbd;\n\n      case 'middle':\n        // Middle of em square → Bottom of em square\n        // Middle is halfway between top and bottom\n        // Distance from middle to bottom: (ascent + descent) / 2\n        return (fba + fbd) / 2;\n\n      case 'alphabetic':\n        // Alphabetic baseline → Bottom of em square\n        // Alphabetic is fbd above bottom (standard for Latin text)\n        return fbd;\n\n      case 'ideographic':\n        // Ideographic baseline → Bottom of em square\n        // Ideographic is ib pixels relative to alphabetic (negative = below alphabetic)\n        // Distance from ideographic to bottom: fbd + ib\n        // Example: if fbd=4 and ib=-4.0264, offset = 4 + (-4.0264) = -0.0264\n        // This small negative offset places ideographic just above bottom, matching native Canvas\n        return fbd + ib;\n\n      case 'bottom':\n        // Already at bottom baseline - no offset needed\n        return 0;\n\n      default:\n        // Unknown baseline value - warn and default to bottom\n        console.warn(`BitmapText: Unknown textBaseline '${textBaseline}', defaulting to 'bottom'. Valid values: top, hanging, middle, alphabetic, ideographic, bottom`);\n        return 0;\n    }\n  }\n\n  /**\n   * Calculate x-offset to convert from specified textAlign to 'left' alignment\n   *\n   * INTERNAL REFERENCE: BitmapText uses 'left' alignment for internal rendering.\n   * All text rendering starts from the x-coordinate and advances rightward.\n   * This method converts user's chosen alignment to that internal reference.\n   *\n   * COORDINATE SYSTEM: x increases rightward (Canvas convention)\n   * All measurements are in CSS pixels\n   *\n   * ALIGNMENT GEOMETRY:\n   * - left: x marks the start of the text (no offset needed)\n   * - center: x marks the center of the text (offset by -width/2)\n   * - right: x marks the end of the text (offset by -width)\n   *\n   * @private\n   * @param {string} textAlign - User's chosen alignment ('left', 'center', 'right')\n   * @param {number} textWidth_CssPx - Total width of the text in CSS pixels\n   * @returns {number} Offset in CSS pixels to add to x coordinate to reach 'left' alignment\n   */\n  static #calculateAlignmentOffsetToLeft(textAlign, textWidth_CssPx) {\n    // Convert from user's alignment to left alignment (internal reference)\n    switch (textAlign) {\n      case 'left':\n        // Already at left alignment - no offset needed\n        return 0;\n\n      case 'center':\n        // Center alignment → Left alignment\n        // Text is centered at x, need to shift left by half width to get start position\n        return -textWidth_CssPx / 2;\n\n      case 'right':\n        // Right alignment → Left alignment\n        // Text ends at x, need to shift left by full width to get start position\n        return -textWidth_CssPx;\n\n      default:\n        // Unknown alignment value - warn and default to left\n        console.warn(`BitmapText: Unknown textAlign '${textAlign}', defaulting to 'left'. Valid values: left, center, right`);\n        return 0;\n    }\n  }\n\n  /**\n   * Draw colored text using optimized batch rendering\n   *\n   * OPTIMIZATION: Instead of switching composite operations for EACH character:\n   * 1. Measure total text extent ONCE\n   * 2. Draw ALL glyphs to one scratch canvas (in original black form)\n   * 3. Apply color transformation ONCE using composite operation\n   * 4. Copy entire colored text block to main canvas ONCE\n   *\n   * This reduces expensive composite operation switches from N (per character) to 1 (per text string)\n   * Expected performance improvement: 2-5x faster for colored text rendering\n   *\n   * @private\n   * @param {CanvasRenderingContext2D} ctx - Main canvas context\n   * @param {string} text - Full text string to render\n   * @param {Array<string>} chars - Text split into characters\n   * @param {Object} startPosition_PhysPx - Starting position in physical pixels {x, y}\n   * @param {AtlasData} atlasData - Atlas data containing glyphs\n   * @param {FontMetrics} fontMetrics - Font metrics for measurements\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {TextProperties} textProperties - Text rendering configuration\n   * @returns {{missingAtlasChars: Set, placeholdersUsed: boolean}} Status information\n   */\n  static #drawColoredTextBatched(ctx, text, chars, startPosition_PhysPx, atlasData, fontMetrics, fontProperties, textProperties) {\n    const missingAtlasChars = new Set();\n    let placeholdersUsed = false;\n\n    // Step 1: Measure text to determine bounding box for scratch canvas\n    const measureResult = BitmapText.measureText(text, fontProperties, textProperties);\n    if (measureResult.status.code !== 0 || !measureResult.metrics) {\n      // Cannot measure - fallback to character-by-character rendering\n      console.warn('BitmapText: Batch rendering failed (cannot measure text), falling back to per-character rendering');\n      return { missingAtlasChars, placeholdersUsed };\n    }\n\n    const metrics = measureResult.metrics;\n\n    // PRE-CREATE font-invariant font properties ONCE\n    const invariantFontProps = new FontProperties(\n      fontProperties.pixelDensity,\n      CharacterSets.INVARIANT_FONT_FAMILY,\n      'normal',\n      'normal',\n      fontProperties.fontSize\n    );\n\n    // PRE-FETCH font-invariant font data\n    const invariantFontMetrics = FontMetricsStore.getFontMetrics(invariantFontProps);\n    const invariantAtlasData = invariantFontMetrics ?\n      AtlasDataStore.getAtlasData(invariantFontProps) : null;\n    const hasInvariantFont = invariantFontMetrics !== null;\n\n    // Track current font to minimize lookups\n    let currentFontProps = fontProperties;\n    let currentFontMetrics = fontMetrics;\n    let currentAtlasData = atlasData;\n\n    // Calculate scratch canvas dimensions in physical pixels\n    // CRITICAL: Use FONT bounding box (not actual text bounding box)\n    // This ensures we have room for ALL characters in the font, not just those in this text\n    // Example: \"hello\" has small actualBoundingBoxAscent (x-height only)\n    //          but we need room for \"HELLO\" (cap-height) when rendering any text\n    //\n    // CRITICAL: Calculate VISUAL width (actual pixel span) not typographic width (advancement)\n    //\n    // Canvas API Semantics:\n    // - metrics.width = sum of character advancements (includes kerning, represents \"cursor advancement\")\n    // - metrics.actualBoundingBoxLeft = distance from text start to leftmost pixel\n    // - metrics.actualBoundingBoxRight = distance from text start to rightmost pixel\n    // - Visual width = actualBoundingBoxLeft + actualBoundingBoxRight (actual pixels occupied)\n    //\n    // WIDTH DIMENSION ROUNDING: Use Math.ceil on physical pixels for visual width\n    // Canvas width must accommodate all pixels including those at fractional positions.\n    // Math.ceil ensures glyphs drawing at rounded-up positions won't be clipped.\n    // Example: visualWidth=24.4 → Math.ceil(24.4)=25 → canvas [0-24] → glyph at px 24 fits ✓\n    const visualWidth_CssPx = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n    const textWidth_PhysPx = Math.ceil(visualWidth_CssPx * fontProperties.pixelDensity);\n\n    // HEIGHT DIMENSION ROUNDING: MUST match GlyphFAB.js calculation EXACTLY\n    // CRITICAL: GlyphFAB.js (lines 247-252) uses Math.round on CSS pixels, then multiplies by pixelDensity\n    // The dy offsets in atlas were calculated based on THIS EXACT canvas height\n    const fontBoundingBoxHeight_CssPx = Math.round(\n      metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent\n    );\n    const textHeight_PhysPx = fontBoundingBoxHeight_CssPx * fontProperties.pixelDensity;\n\n    // Pre-round position offset values for consistent positioning throughout\n    // CRITICAL: These values are used both for positioning glyphs inside scratch canvas\n    // and for positioning the final scratch canvas copy to main canvas\n    // Using the SAME rounded values prevents 1-pixel misalignment from float rounding discrepancies\n    const actualBoundingBoxLeft_PhysPx = Math.round(metrics.actualBoundingBoxLeft * fontProperties.pixelDensity);\n\n    // CRITICAL: Baseline position must match GlyphFAB.js (GlyphFAB.js:288)\n    // GlyphFAB positions baseline at \"canvas.height / pixelDensity - 1\" in CSS pixels\n    // In physical pixels: baseline_y = canvas.height - pixelDensity\n    // The dy offsets in atlas are calculated relative to THIS baseline position\n    // Missing this offset causes descender clipping (bottom row of j, y, g, p, q cut off)\n    const baselineY_PhysPx = textHeight_PhysPx - fontProperties.pixelDensity;\n\n    // Safety check: ensure dimensions are reasonable\n    if (textWidth_PhysPx <= 0 || textHeight_PhysPx <= 0 || textWidth_PhysPx > 32000 || textHeight_PhysPx > 32000) {\n      console.warn(`BitmapText: Invalid scratch canvas dimensions (${textWidth_PhysPx}x${textHeight_PhysPx}), falling back`);\n      return { missingAtlasChars, placeholdersUsed };\n    }\n\n    // Step 2: Setup scratch canvas sized for entire text block\n    BitmapText.#coloredGlyphCanvas.width = textWidth_PhysPx;\n    BitmapText.#coloredGlyphCanvas.height = textHeight_PhysPx;\n    BitmapText.#coloredGlyphCtx.clearRect(0, 0, textWidth_PhysPx, textHeight_PhysPx);\n\n    // Step 3: Draw ALL glyphs to scratch canvas in their original black form\n    // Position relative to scratch canvas origin (not main canvas)\n    const position_PhysPx = {\n      // Horizontal: Start at actualBoundingBoxLeft to account for glyphs that protrude left (e.g., italic 'f')\n      // CRITICAL: Use pre-rounded value (line 950) for consistency with final copy (line 1017+)\n      x: actualBoundingBoxLeft_PhysPx,\n      // Vertical: Position baseline to match GlyphFAB.js rendering (GlyphFAB.js:288)\n      // Baseline is at \"canvas.height / pixelDensity - 1\" in CSS pixels\n      // which equals \"canvas.height - pixelDensity\" in physical pixels\n      // NOT at canvas bottom, but one pixel-row above it\n      // Glyphs draw upward/downward from here using their dy offsets from atlas\n      // CRITICAL: Must match glyph building baseline or dy offsets will be wrong (descenders clip)\n      y: baselineY_PhysPx\n    };\n\n    for (let i = 0; i < chars.length; i++) {\n      const currentChar = chars[i];\n      const nextChar = chars[i + 1];\n\n      // FAST CHECK: Is this a font-invariant character? (string.includes on 18 chars = ~1-2ns)\n      const isInvariant = hasInvariantFont && BitmapText.#isInvariantCharacter(currentChar);\n\n      // Switch font ONLY if needed (avoids redundant assignments)\n      if (isInvariant && currentFontProps !== invariantFontProps) {\n        currentFontProps = invariantFontProps;\n        currentFontMetrics = invariantFontMetrics;\n        currentAtlasData = invariantAtlasData;\n      } else if (!isInvariant && currentFontProps !== fontProperties) {\n        // Switch back to base font\n        currentFontProps = fontProperties;\n        currentFontMetrics = fontMetrics;\n        currentAtlasData = atlasData;\n      }\n\n      // Track missing characters\n      if (currentChar !== ' ' && !currentAtlasData.hasPositioning(currentChar)) {\n        missingAtlasChars.add(currentChar);\n        placeholdersUsed = true;\n        // Advance position even for missing characters to maintain layout\n        position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(\n          currentFontMetrics, currentFontProps, currentChar, nextChar, textProperties\n        );\n        continue;\n      }\n\n      // Draw glyph to scratch canvas (skip spaces, they have no visual)\n      if (currentChar !== ' ' && currentAtlasData.hasPositioning(currentChar)) {\n        const atlasPositioning = currentAtlasData.atlasPositioning.getPositioning(currentChar);\n        const atlasImage = currentAtlasData.atlasImage.image;\n        const { xInAtlas, yInAtlas, tightWidth, tightHeight, dx, dy } = atlasPositioning;\n\n        // Draw original glyph (black) to scratch canvas at correct position\n        BitmapText.#coloredGlyphCtx.drawImage(\n          atlasImage,\n          xInAtlas, yInAtlas,\n          tightWidth, tightHeight,\n          Math.round(position_PhysPx.x + dx),\n          Math.round(position_PhysPx.y + dy),\n          tightWidth, tightHeight\n        );\n      }\n\n      // Advance position for next character\n      position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(\n        currentFontMetrics, currentFontProps, currentChar, nextChar, textProperties\n      );\n    }\n\n    // Step 4: Apply color transformation ONCE to entire text\n    // This is the key optimization - only ONE composite operation instead of N\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-in';\n    BitmapText.#coloredGlyphCtx.fillStyle = textProperties.textColor;\n    BitmapText.#coloredGlyphCtx.fillRect(0, 0, textWidth_PhysPx, textHeight_PhysPx);\n\n    // Reset composite operation for future use\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-over';\n\n    // Step 5: Copy entire colored text block to main canvas ONCE\n    // POSITIONING GEOMETRY:\n    // - Main canvas: startPosition_PhysPx.y is at the bottom baseline (textBaseline='bottom')\n    // - Scratch canvas: baseline is at y = baselineY_PhysPx (textHeight - pixelDensity, NOT at canvas bottom)\n    // - To align baselines: scratch canvas top = startPosition_PhysPx.y - baselineY_PhysPx\n    // - Horizontal: account for actualBoundingBoxLeft offset (glyphs that protrude left)\n    // CRITICAL: Use baselineY_PhysPx (line 957) not textHeight_PhysPx to account for baseline offset\n    ctx.drawImage(\n      BitmapText.#coloredGlyphCanvas,\n      0, 0,\n      textWidth_PhysPx, textHeight_PhysPx,\n      Math.round(startPosition_PhysPx.x) - actualBoundingBoxLeft_PhysPx,\n      Math.round(startPosition_PhysPx.y) - baselineY_PhysPx,\n      textWidth_PhysPx, textHeight_PhysPx\n    );\n\n    return { missingAtlasChars, placeholdersUsed };\n  }\n\n  // Rendering optimizations:\n  // 1. ✓ IMPLEMENTED: Black text fast path (see #drawCharacterDirect for 2-3x speedup)\n  // 2. ✓ IMPLEMENTED: Batch colored text rendering (single composite operation per text string)\n  // 3. FUTURE: Cache colored glyphs in LRU cache to avoid re-coloring same characters\n  static #drawCharacter(ctx, char, position_PhysPx, atlasData, fontMetrics, textColor) {\n    // If atlasData is missing but metrics exist, draw simplified placeholder rectangle\n    if (!BitmapText.#isValidAtlas(atlasData)) {\n      const characterMetrics = fontMetrics.getCharacterMetrics(char);\n      if (characterMetrics) {\n        BitmapText.#drawPlaceholderRectangle(ctx, char, position_PhysPx, characterMetrics, textColor);\n      }\n      return;\n    }\n\n    // FAST PATH: Black text renders directly from atlas (2-3x faster)\n    // Skips scratch canvas + composite operations when using default color\n    if (textColor === BitmapText.#DEFAULT_TEXT_COLOR) {\n      BitmapText.#drawCharacterDirect(ctx, char, position_PhysPx, atlasData, fontMetrics);\n      return;\n    }\n\n    // NOTE: Colored text now uses batch rendering in drawTextFromAtlas\n    // This method is kept for compatibility/fallback but should rarely be called for colored text\n    // SLOW PATH: Colored text requires double-pass rendering\n    // 1. Copy glyph from atlas to scratch canvas\n    // 2. Apply color using composite operation\n    // 3. Draw colored glyph to main canvas\n    if (!atlasData.hasPositioning(char)) return;\n\n    const atlasPositioning = atlasData.atlasPositioning.getPositioning(char);\n    const atlasImage = atlasData.atlasImage.image;\n    const coloredGlyphCanvas = BitmapText.#createColoredGlyph(atlasImage, atlasPositioning, textColor);\n    BitmapText.#renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position_PhysPx, atlasPositioning);\n  }\n\n  static #createColoredGlyph(atlasImage, atlasPositioning, textColor) {\n    const { xInAtlas, yInAtlas, tightWidth, tightHeight } = atlasPositioning;\n\n    // Setup temporary canvas, same size as the glyph\n    BitmapText.#coloredGlyphCanvas.width = tightWidth;\n    BitmapText.#coloredGlyphCanvas.height = tightHeight;\n    BitmapText.#coloredGlyphCtx.clearRect(0, 0, tightWidth, tightHeight);\n\n    // Draw original glyph\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-over';\n    BitmapText.#coloredGlyphCtx.drawImage(\n      atlasImage,\n      xInAtlas, yInAtlas,\n      tightWidth, tightHeight,\n      0, 0,\n      tightWidth, tightHeight\n    );\n\n    // Apply color\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-in';\n    BitmapText.#coloredGlyphCtx.fillStyle = textColor;\n    BitmapText.#coloredGlyphCtx.fillRect(0, 0, tightWidth, tightHeight);\n\n    return BitmapText.#coloredGlyphCanvas;\n  }\n\n  static #renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position_PhysPx, atlasPositioning) {\n    const { tightWidth, tightHeight, dx, dy } = atlasPositioning;\n\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    // see https://stackoverflow.com/a/6061102\n    ctx.drawImage(\n      coloredGlyphCanvas,\n      0, 0,\n      tightWidth, tightHeight,\n      Math.round(position_PhysPx.x + dx),\n      Math.round(position_PhysPx.y + dy),\n      tightWidth, tightHeight\n    );\n  }\n\n  /**\n   * Fast path: Draw character directly from atlas (black text only)\n   * Skips scratch canvas and color composite operations for 2-3x faster rendering\n   * @private\n   */\n  static #drawCharacterDirect(ctx, char, position_PhysPx, atlasData, fontMetrics) {\n    if (!atlasData.hasPositioning(char)) return;\n\n    const atlasPositioning = atlasData.atlasPositioning.getPositioning(char);\n    const atlasImage = atlasData.atlasImage.image;\n    const { xInAtlas, yInAtlas, tightWidth, tightHeight, dx, dy } = atlasPositioning;\n\n    // Single drawImage operation: atlas → main canvas\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    ctx.drawImage(\n      atlasImage,\n      xInAtlas, yInAtlas,\n      tightWidth, tightHeight,\n      Math.round(position_PhysPx.x + dx),\n      Math.round(position_PhysPx.y + dy),\n      tightWidth, tightHeight\n    );\n  }\n\n  static #drawPlaceholderRectangle(ctx, char, position_PhysPx, characterMetrics, textColor) {\n    if (char === ' ') return;\n\n    if (characterMetrics.actualBoundingBoxLeft === undefined ||\n      characterMetrics.actualBoundingBoxRight === undefined ||\n      characterMetrics.actualBoundingBoxAscent === undefined ||\n      characterMetrics.actualBoundingBoxDescent === undefined) {\n      console.warn(`Missing bounding box metrics for character '${char}'`);\n      return;\n    }\n\n    const pixelDensity = characterMetrics.pixelDensity || 1;\n\n    // Use CHARACTER-SPECIFIC actual bounding box (not font-wide fontBoundingBox)\n    // This makes:\n    // - 'a' shorter than 'A' (x-height vs cap-height)\n    // - 'g' extends below baseline (shows descender)\n    // - '.' very short (near baseline only)\n    // Width: actualBoundingBoxLeft + actualBoundingBoxRight (CSS px) * pixelDensity → physical px\n    // Height: actualBoundingBoxAscent + actualBoundingBoxDescent (CSS px) * pixelDensity → physical px\n    const width_PhysPx = Math.round(\n      characterMetrics.actualBoundingBoxLeft + characterMetrics.actualBoundingBoxRight\n    ) * pixelDensity;\n\n\n    const height_PhysPx = Math.round(\n      characterMetrics.actualBoundingBoxAscent + characterMetrics.actualBoundingBoxDescent\n    ) * pixelDensity;\n\n    // X position: Account for actualBoundingBoxLeft (glyphs may protrude left, e.g., italic 'f')\n    // This matches the dx offset calculation in atlas rendering (AtlasPositioningFAB.js:92)\n    const rectX_PhysPx = position_PhysPx.x\n      - Math.round(characterMetrics.actualBoundingBoxLeft) * pixelDensity;\n\n    // Y position calculation:\n    // - position_PhysPx.y is at em square BOTTOM (textBaseline='bottom')\n    // - Em square bottom is fontBoundingBoxDescent below the alphabetic baseline\n    // - So: alphabetic_baseline_y = position_PhysPx.y - fontBoundingBoxDescent * pixelDensity\n    // - Character top = alphabetic_baseline_y - actualBoundingBoxAscent * pixelDensity\n    // Result: rectY = position_PhysPx.y - fontBoundingBoxDescent * pixelDensity - actualBoundingBoxAscent * pixelDensity\n    const rectY_PhysPx = position_PhysPx.y\n      - characterMetrics.fontBoundingBoxDescent * pixelDensity\n      - characterMetrics.actualBoundingBoxAscent * pixelDensity;\n\n    const actualColor = textColor || 'black';\n\n    // Draw character-specific rectangle\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    ctx.fillStyle = actualColor;\n    ctx.fillRect(\n      Math.round(rectX_PhysPx),\n      Math.round(rectY_PhysPx),\n      Math.round(width_PhysPx),\n      Math.round(height_PhysPx)\n    );\n  }\n\n  static #calculateCharacterAdvancement_PhysPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties) {\n    return this.calculateAdvancement_CssPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties)\n      * fontProperties.pixelDensity;\n  }\n\n  /**\n   * Check if atlas data is valid and ready for rendering\n   * @private\n   * @param {*} atlasData - Potential AtlasData instance\n   * @returns {boolean} True if atlasData is an AtlasData instance and is valid\n   */\n  static #isValidAtlas(atlasData) {\n    if (!(atlasData instanceof AtlasData)) {\n      return false;\n    }\n    return atlasData.isValid();\n  }\n\n  // ============================================\n  // Loading API (Delegates to FontLoader)\n  // ============================================\n\n  /**\n   * Load a single font\n   * @param {string} idString - Font ID string\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @returns {Promise} Resolves when font is loaded\n   */\n  static async loadFont(idString, options = {}) {\n    BitmapText.#ensureFontLoader();\n    // Redirect sizes < 8.5 to size 8.5\n    const redirection = BitmapText.#redirectIdStringIfNeeded(idString);\n    return BitmapText.#fontLoader.loadFont(redirection.idString, options, BitmapText);\n  }\n\n  /**\n   * Load multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {boolean} [options.loadMetrics] - Load metrics (default: true)\n   * @param {boolean} [options.loadAtlases] - Load atlases (default: true)\n   * @returns {Promise} Resolves when all fonts are loaded\n   */\n  static async loadFonts(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    // Redirect sizes < 8.5 to size 8.5 for all idStrings\n    const redirectedIdStrings = idStrings.map(idString => {\n      const redirection = BitmapText.#redirectIdStringIfNeeded(idString);\n      return redirection.idString;\n    });\n    return BitmapText.#fontLoader.loadFonts(redirectedIdStrings, options, BitmapText);\n  }\n\n  /**\n   * Load only metrics for fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetrics(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    // Redirect sizes < 8.5 to size 8.5 for all idStrings\n    const redirectedIdStrings = idStrings.map(idString => {\n      const redirection = BitmapText.#redirectIdStringIfNeeded(idString);\n      return redirection.idString;\n    });\n    return BitmapText.#fontLoader.loadMetrics(redirectedIdStrings, options, BitmapText);\n  }\n\n  /**\n   * Load only atlases for fonts (metrics must be loaded first)\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @returns {Promise} Resolves when atlases are loaded\n   */\n  static async loadAtlases(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    // Redirect sizes < 8.5 to size 8.5 for all idStrings\n    const redirectedIdStrings = idStrings.map(idString => {\n      const redirection = BitmapText.#redirectIdStringIfNeeded(idString);\n      return redirection.idString;\n    });\n    return BitmapText.#fontLoader.loadAtlases(redirectedIdStrings, options, BitmapText);\n  }\n\n  // ============================================\n  // Builder/Testing Tool API\n  // ============================================\n\n  /**\n   * Set atlas data for a font (for builder/testing tools)\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {AtlasData} atlasData - Atlas data to store\n   */\n  static setAtlasData(fontProperties, atlasData) {\n    AtlasDataStore.setAtlasData(fontProperties, atlasData);\n  }\n\n  /**\n   * Get atlas data for a font\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {AtlasData|undefined} Atlas data or undefined if not found\n   */\n  static getAtlasData(fontProperties) {\n    return AtlasDataStore.getAtlasData(fontProperties);\n  }\n\n  /**\n   * Delete atlas data for a font\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if atlas was deleted\n   */\n  static deleteAtlas(fontProperties) {\n    return AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Set font metrics for a font (for builder/testing tools)\n   * Public API - delegates to FontMetricsStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {FontMetrics} fontMetrics - Font metrics to store\n   */\n  static setFontMetrics(fontProperties, fontMetrics) {\n    FontMetricsStore.setFontMetrics(fontProperties, fontMetrics);\n  }\n\n  /**\n   * Get font metrics for a font\n   * Public API - delegates to FontMetricsStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {FontMetrics|undefined} Font metrics or undefined if not found\n   */\n  static getFontMetrics(fontProperties) {\n    return FontMetricsStore.getFontMetrics(fontProperties);\n  }\n\n  /**\n   * Unload both metrics and atlas for a font\n   * @param {string} idString - Font ID string\n   */\n  static unloadFont(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    FontMetricsStore.deleteFontMetrics(fontProperties);\n    AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Unload multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   */\n  static unloadFonts(idStrings) {\n    idStrings.forEach(id => this.unloadFont(id));\n  }\n\n  /**\n   * Unload metrics (cascades to unload atlas)\n   * @param {string} idString - Font ID string\n   */\n  static unloadMetrics(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    FontMetricsStore.deleteFontMetrics(fontProperties);\n    AtlasDataStore.deleteAtlas(fontProperties); // Cascade: no metrics = no atlas\n  }\n\n  /**\n   * Unload atlas only (keeps metrics)\n   * @param {string} idString - Font ID string\n   */\n  static unloadAtlas(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Unload all fonts (both metrics and atlases)\n   */\n  static unloadAllFonts() {\n    FontMetricsStore.clear();\n    AtlasDataStore.clear();\n  }\n\n  /**\n   * Unload all atlases (keep metrics)\n   */\n  static unloadAllAtlases() {\n    AtlasDataStore.clear();\n  }\n\n  // ============================================\n  // Query API\n  // ============================================\n\n  /**\n   * Check if font is fully loaded (both metrics and atlas)\n   * For sizes < 8.5, checks if size 8.5 metrics exist (atlas always false for < 8.5)\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if both metrics and atlas are loaded\n   */\n  static hasFont(idString) {\n    return this.hasMetrics(idString) && this.hasAtlas(idString);\n  }\n\n  /**\n   * Check if metrics are loaded for a font\n   * For sizes < 8.5, checks if size 8.5 metrics exist\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if metrics are loaded\n   */\n  static hasMetrics(idString) {\n    // Redirect sizes < 8.5 to check for 8.5 metrics (silent to avoid log spam)\n    const redirection = BitmapText.#redirectIdStringIfNeeded(idString, true);\n    const fontProperties = FontProperties.fromIDString(redirection.idString);\n    return FontMetricsStore.hasFontMetrics(fontProperties);\n  }\n\n  /**\n   * Check if atlas is loaded for a font\n   * For sizes < 8.5, always returns false (these sizes use placeholder mode)\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if atlas is loaded\n   */\n  static hasAtlas(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n\n    // Sizes < 8.5 never have atlases (always use placeholder mode)\n    if (BitmapText.#shouldUseMinSize(fontProperties.fontSize)) {\n      return false;\n    }\n\n    const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n    return atlasData && BitmapText.#isValidAtlas(atlasData);\n  }\n\n  /**\n   * Get list of fully loaded fonts (both metrics and atlas)\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedFonts() {\n    const loaded = [];\n    for (const key of FontMetricsStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n      if (atlasData && BitmapText.#isValidAtlas(atlasData)) {\n        loaded.push(fontProperties.idString);\n      }\n    }\n    return loaded;\n  }\n\n  /**\n   * Get list of fonts with loaded metrics\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedMetrics() {\n    const loaded = [];\n    for (const key of FontMetricsStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      loaded.push(fontProperties.idString);\n    }\n    return loaded;\n  }\n\n  /**\n   * Get list of fonts with loaded atlases\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedAtlases() {\n    const loaded = [];\n    for (const key of AtlasDataStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n      if (BitmapText.#isValidAtlas(atlasData)) {\n        loaded.push(fontProperties.idString);\n      }\n    }\n    return loaded;\n  }\n\n  // ============================================\n  // Testing Helpers\n  // ============================================\n\n  /**\n   * Reset all state for testing\n   * @private\n   */\n  static __resetForTesting() {\n    FontMetricsStore.clear();\n    AtlasDataStore.clear();\n    // Clear FontLoader state\n    if (FontLoaderBase._loadingPromises) {\n      FontLoaderBase._loadingPromises.clear();\n    }\n    if (FontLoaderBase._tempAtlasPackages) {\n      FontLoaderBase._tempAtlasPackages = {};\n    }\n    if (FontLoaderBase._pendingAtlases) {\n      FontLoaderBase._pendingAtlases.clear();\n    }\n    // Reset FontLoader configuration\n    if (FontLoaderBase.setFontDirectory) {\n      FontLoaderBase.setFontDirectory(null);\n    }\n    BitmapText.#coloredGlyphCanvas = null;\n    BitmapText.#coloredGlyphCtx = null;\n    BitmapText.#canvasFactory = null;\n    BitmapText.#fontLoader = null;\n  }\n\n}\n\n// TIER 6b OPTIMIZATION: Short aliases for registration methods (saves ~15 bytes per file)\nBitmapText.r = BitmapText.registerMetrics;\nBitmapText.a = BitmapText.registerAtlas;\n\n// ============================================================================\n// MetricsExpander.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/builder/MetricsExpander.js\n// ============================================================================\n\n// Static utility class for expanding minified font metrics data (runtime only)\n// Converts compact format back to FontMetrics instances for use by the rendering engine\n// NOTE: Requires BitmapText.js to be loaded first (uses CharacterSets.FONT_SPECIFIC_CHARS)\n\nclass MetricsExpander {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('MetricsExpander cannot be instantiated - use static methods');\n  }\n\n  /**\n   * TIER 6c OPTIMIZATION: Decode base64 string to array of integers\n   * Reverses the base64 byte encoding from MetricsMinifier\n   *\n   * @param {string} base64 - Base64 encoded string\n   * @returns {Array<number>} Array of integers (0-255)\n   */\n  static #decodeFromBase64Bytes(base64) {\n    // In browser: use atob\n    // In Node.js: use Buffer\n    let bytes;\n\n    if (typeof Buffer !== 'undefined') {\n      // Node.js environment\n      bytes = Buffer.from(base64, 'base64');\n    } else {\n      // Browser environment\n      const binary = atob(base64);\n      bytes = new Uint8Array(binary.length);\n      for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n      }\n    }\n\n    return Array.from(bytes);\n  }\n\n  /**\n   * TIER 6c OPTIMIZATION: Decode varint+zigzag+base64 to signed integers\n   * Reverses the VarInt encoding from MetricsMinifier\n   *\n   * @param {string} base64 - Base64 encoded varint bytes\n   * @returns {Array<number>} Array of signed integers\n   */\n  static #decodeVarInts(base64) {\n    const bytes = this.#decodeFromBase64Bytes(base64);\n    const integers = [];\n    let i = 0;\n\n    while (i < bytes.length) {\n      // Decode VarInt: 7 bits per byte, MSB indicates continuation\n      let value = 0;\n      let shift = 0;\n      let byte;\n\n      do {\n        byte = bytes[i++];\n        value |= (byte & 0x7F) << shift;\n        shift += 7;\n      } while (byte & 0x80);\n\n      // Zigzag decoding: convert unsigned back to signed\n      // 0→0, 1→-1, 2→1, 3→-2, 4→2, ...\n      const signed = (value & 1) ? -(value + 1) / 2 : value / 2;\n      integers.push(signed);\n    }\n\n    return integers;\n  }\n\n  /**\n   * TIER 7 OPTIMIZATION: Decompress value lookup array from delta encoding + base64\n   *\n   * Reverses the compression:\n   * 1. Decode base64 → varint → zigzag → deltas\n   * 2. Reconstruct sorted values from deltas\n   * 3. Return as unsorted array (order doesn't matter for lookup)\n   *\n   * @param {string} base64 - Base64 encoded delta-compressed string\n   * @returns {Array<number>} Array of metric value integers\n   */\n  static #decompressValueArray(base64) {\n    // Decode base64 → deltas\n    const deltas = this.#decodeVarInts(base64);\n\n    // Reconstruct sorted values from deltas\n    const sorted = [deltas[0]]; // First value is absolute\n    for (let i = 1; i < deltas.length; i++) {\n      sorted.push(sorted[i - 1] + deltas[i]);\n    }\n\n    // Return as-is (order doesn't matter for value lookup)\n    // The indices in tuplets refer to sorted positions\n    return sorted;\n  }\n\n  /**\n   * Expands minified metrics back to FontMetrics instance for runtime use\n   * TIER 7 FORMAT (backward compatible with Tier 6c)\n   *\n   * @param {Array} minified - Minified metrics array [kv, k, b, v, t, g, s, cl]\n   *   - v can be array (Tier 6c) or base64 string (Tier 7)\n   * @param {Array<string>} [characterSet=CharacterSets.FONT_SPECIFIC_CHARS] - Character set to use for expansion\n   * @returns {FontMetrics} FontMetrics instance with expanded data\n   * @throws {Error} If invalid format detected\n   */\n  static expand(minified, characterSet = CharacterSets.FONT_SPECIFIC_CHARS) {\n    // Check if FontMetrics class is available\n    if (typeof FontMetrics === 'undefined') {\n      throw new Error('FontMetrics class not found. Please ensure FontMetrics.js is loaded before MetricsExpander.js');\n    }\n\n    // Validate Tier 6c format: 8-element array only\n    if (!Array.isArray(minified) || minified.length !== 8) {\n      throw new Error(\n        `Invalid format - expected 8-element array (Tier 6c), got ${typeof minified === 'object' ? 'array' : typeof minified} with ${minified?.length || 0} elements.\\n` +\n        `Please regenerate font assets with the current version.`\n      );\n    }\n\n    // Extract values from Tier 6c/7 array format\n    let [kv, k, b, v, t, g, s, cl] = minified;\n\n    // Check if this is an uncompressed custom character set font\n    // Custom character sets have v as an object (characterMetrics), not an array or string\n    const isCustomCharacterSet = typeof v === 'object' && !Array.isArray(v) && v !== null;\n\n    let expandedData;\n\n    if (isCustomCharacterSet) {\n      // Custom character set: v is already the characterMetrics object\n      console.debug(`🔍 MetricsExpander: Detected uncompressed custom character set font`);\n      expandedData = {\n        kerningTable: k,  // Already in object format\n        characterMetrics: v,  // Already in object format\n        spaceAdvancementOverrideForSmallSizesInPx: s\n      };\n    } else {\n      // Standard 204-character font: use full decompression\n      // Convert integer values back to floats (divide by 10000)\n      kv = this.#convertIntegersToValues(kv);\n\n      // TIER 7: Handle value lookup array - can be array (Tier 6c) or base64 string (Tier 7)\n      if (typeof v === 'string') {\n        // Tier 7: Decompress from delta-encoded base64\n        v = this.#decompressValueArray(v);\n        v = this.#convertIntegersToValues(v);\n      } else if (Array.isArray(v)) {\n        // Tier 6c: Already an array of integers\n        v = this.#convertIntegersToValues(v);\n      } else {\n        throw new Error('Invalid value lookup format - expected array or string');\n      }\n\n      // Unflatten baseline array to object\n      b = this.#unflattenBaseline(b);\n\n      // Decode base64-encoded binary data\n      // t = VarInt+zigzag encoded flattened tuplets\n      // g = byte-encoded tuplet indices\n      t = this.#decodeVarInts(t);\n      g = this.#decodeFromBase64Bytes(g);\n\n      // Unflatten tuplet data from negative-delimiter format\n      t = this.#unflattenTuplets(t);\n\n      expandedData = {\n        kerningTable: this.#expandKerningTable(k, kv, characterSet),\n        characterMetrics: this.#expandCharacterMetrics(g, b, v, t, cl, characterSet),\n        spaceAdvancementOverrideForSmallSizesInPx: s\n      };\n    }\n\n    // Verify pixelDensity was preserved\n    const firstChar = Object.keys(expandedData.characterMetrics)[0];\n    const pixelDensity = expandedData.characterMetrics[firstChar]?.pixelDensity;\n    console.debug(`🔍 MetricsExpander: Restored pixelDensity=${pixelDensity} for ${Object.keys(expandedData.characterMetrics).length} characters`);\n\n    return new FontMetrics(expandedData);\n  }\n\n  /**\n   * Expands kerning table with range notation support\n   * TIER 3 OPTIMIZATION: Two-dimensional expansion (reverse order of compression)\n   * TIER 4 OPTIMIZATION: Value indexing (looks up actual kerning values from indices)\n   *   Pass 1 (left-side):  {\"A-B\":{\"s\":0}} → {\"A\":{\"s\":0},\"B\":{\"s\":0}}\n   *   Pass 2 (right-side): {\"A\":{\"0-1\":0}} → {\"A\":{\"0\":0,\"1\":0}}\n   *   Pass 3 (values):     {\"A\":{\"s\":0}} → {\"A\":{\"s\":20}} (lookup from kerningValueLookup[0])\n   * Always uses CharacterSets.FONT_SPECIFIC_CHARS for range expansion\n   * Later entries override earlier ones, allowing exceptions to ranges\n   * @param {Object} minified - Minified kerning table with indexed values\n   * @param {Array<string>} characterSet - Character set to use for range expansion\n   * @private\n   */\n  static #expandKerningTable(minified, kerningValueLookup, characterSet) {\n    // PASS 1: Expand left side (characters that come before)\n    const leftExpanded = this.#expandLeftSide(minified, characterSet);\n\n    // PASS 2: Expand right side (characters that follow)\n    const rangeExpanded = {};\n    for (const [leftChar, pairs] of Object.entries(leftExpanded)) {\n      rangeExpanded[leftChar] = this.#expandKerningPairs(pairs, characterSet);\n    }\n\n    // PASS 3 (TIER 4): Replace all indices with actual values from lookup table\n    const expanded = {};\n    for (const [leftChar, pairs] of Object.entries(rangeExpanded)) {\n      expanded[leftChar] = {};\n      for (const [rightChar, index] of Object.entries(pairs)) {\n        expanded[leftChar][rightChar] = kerningValueLookup[index];\n      }\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Expands left side of kerning table (characters that come before)\n   * TIER 3 OPTIMIZATION: Two-dimensional expansion pass 1\n   * Handles left-side range notation like \"A-C\":{\"s\":20} → {\"A\":{\"s\":20},\"B\":{\"s\":20},\"C\":{\"s\":20}}\n   * Always uses CharacterSets.FONT_SPECIFIC_CHARS for range expansion\n   * @param {Array<string>} characterSet - Character set to use for range expansion\n   * @returns {Object} Left-expanded kerning table\n   * @private\n   */\n  static #expandLeftSide(minified, characterSet) {\n    const expanded = {};\n\n    // Process entries in order so later entries can override earlier ones\n    for (const [key, rightSideObj] of Object.entries(minified)) {\n      if (key.includes('-') && key.length >= 3) {\n        // Potential range notation (e.g., \"A-Z\" or \"0-9\")\n        const hyphenIndex = key.indexOf('-');\n        const startChar = key.substring(0, hyphenIndex);\n        const endChar = key.substring(hyphenIndex + 1);\n\n        // Check if both start and end are single characters in the character set\n        if (startChar.length === 1 && endChar.length === 1) {\n          const startIndex = characterSet.indexOf(startChar);\n          const endIndex = characterSet.indexOf(endChar);\n\n          if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {\n            // Valid range, expand it\n            for (let i = startIndex; i <= endIndex; i++) {\n              expanded[characterSet[i]] = rightSideObj;\n            }\n            continue;\n          }\n        }\n      }\n\n      // Not a range, or invalid range - treat as literal character\n      expanded[key] = rightSideObj;\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Expands kerning pairs from compact string notation to individual character pairs\n   * TIER 6b OPTIMIZATION: Handles advanced compact notation with non-sequential grouping\n   *\n   * Parses compact strings like \"-,.:;ac-egj-s\" which means:\n   * - Dash at START is literal\n   * - Individual chars: comma, dot, colon, semicolon\n   * - Ranges: a, c-e (c,d,e), g, j-s (j,k,l,m,n,o,p,q,r,s)\n   *\n   * Always uses CharacterSets.FONT_SPECIFIC_CHARS for range expansion\n   * @param {Array<string>} characterSet - Character set to use for range expansion\n   * @returns {Object} Expanded pairs like {\"-\":20,\",\":20,\".\":20,...,\"s\":20}\n   * @private\n   */\n  static #expandKerningPairs(pairs, characterSet) {\n    const expanded = {};\n\n    // Process entries in order so later entries can override earlier ones\n    for (const [key, value] of Object.entries(pairs)) {\n      // Parse the compact string notation\n      const chars = this.#parseCompactCharString(key, characterSet);\n\n      // Assign value to all parsed characters\n      for (const char of chars) {\n        expanded[char] = value;\n      }\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Parses compact character string notation\n   * TIER 6b OPTIMIZATION: Handles dash-at-start and range notation\n   *\n   * Format:\n   * - First char is dash → literal dash character\n   * - \"a-z\" → range from a to z\n   * - \"abc\" → individual characters a, b, c\n   * - \"-,.:;ac-egj-s\" → dash, comma, dot, colon, semicolon, a, c-e range, g, j-s range\n   *\n   * @param {string} compactStr - Compact string like \"-,.:;ac-egj-s\"\n   * @param {Array<string>} characterSet - Character set to use for range expansion\n   * @returns {string[]} Array of individual characters\n   * @private\n   */\n  static #parseCompactCharString(compactStr, characterSet) {\n    const chars = [];\n    let i = 0;\n\n    // Handle dash at start (literal)\n    if (compactStr[0] === '-') {\n      chars.push('-');\n      i = 1;\n    }\n\n    // Parse rest of string\n    while (i < compactStr.length) {\n      const currentChar = compactStr[i];\n\n      // Check if this is the start of a range pattern\n      if (i + 2 < compactStr.length && compactStr[i + 1] === '-') {\n        // Pattern: \"X-Y\" where X and Y are single characters\n        const startChar = currentChar;\n        const endChar = compactStr[i + 2];\n\n        // Verify it's a valid range in the character set\n        const startIndex = characterSet.indexOf(startChar);\n        const endIndex = characterSet.indexOf(endChar);\n\n        if (startIndex !== -1 && endIndex !== -1 && startIndex < endIndex) {\n          // Valid range - expand it\n          for (let j = startIndex; j <= endIndex; j++) {\n            chars.push(characterSet[j]);\n          }\n          i += 3; // Skip X, -, Y\n        } else {\n          // Not a valid range - treat as individual characters\n          chars.push(currentChar);\n          i++;\n        }\n      } else {\n        // Individual character\n        chars.push(currentChar);\n        i++;\n      }\n    }\n\n    return chars;\n  }\n\n  /**\n   * Expands glyph metrics from arrays back to full objects\n   * TIER 2 OPTIMIZATION: Reconstructs from array of arrays using CharacterSets.FONT_SPECIFIC_CHARS\n   * TIER 4 OPTIMIZATION: Looks up actual values from indices using valueLookup table\n   * TIER 5a OPTIMIZATION: Decompresses variable-length tuplets (2/3/4/5 elements)\n   * TIER 5b OPTIMIZATION: Looks up tuplets from tuplet indices\n   * TIER 6b OPTIMIZATION: 2-element tuplets using common left index\n   *\n   * Tuplet decompression (deterministic based on length):\n   *   - Length 2: [w, a] → [w, CL, w, a, CL]  (w===r AND l===CL AND d===CL)\n   *   - Length 3: [w, l, a] → [w, l, w, a, l]  (w===r AND l===d)\n   *   - Length 4: [w, l, a, d] → [w, l, w, a, d]  (w===r only)\n   *   - Length 5: [w, l, r, a, d] (no decompression)\n   *\n   * Reconstructs full TextMetrics-compatible objects from compact arrays\n   * Always uses CharacterSets.FONT_SPECIFIC_CHARS for character order\n   * @param {Array} tupletIndices - Array of tuplet indices (single integers)\n   * @param {Object} metricsCommonToAllCharacters - Common metrics shared across all characters\n   * @param {Array} valueLookup - Value lookup table mapping indices to actual values\n   * @param {Array} tupletLookup - Tuplet lookup table mapping tuplet indices to index arrays\n   * @param {number} [commonLeftIndex] - Common left bounding box index (Tier 6b, optional)\n   * @param {Array<string>} characterSet - Character set to use for expansion\n   * @private\n   */\n  static #expandCharacterMetrics(tupletIndices, metricsCommonToAllCharacters, valueLookup, tupletLookup, commonLeftIndex, characterSet) {\n    const expanded = {};\n\n    // Convert character set to array if it isn't already (though it should be)\n    const chars = Array.isArray(characterSet) ? characterSet : Array.from(characterSet);\n\n    // Reconstruct object by mapping array positions to characters\n    chars.forEach((char, index) => {\n      // TIER 5b: Look up tuplet from tuplet index\n      const tupletIndex = tupletIndices[index];\n      const compressed = tupletLookup[tupletIndex];\n\n      let indices;\n\n      // TIER 5+6b: Decompress tuplet based on length\n      if (compressed.length === 2) {\n        // Case D (TIER 6b): [w, a] → [w, CL, w, a, CL]\n        // All three patterns: w===r AND l===CL AND d===CL\n        if (commonLeftIndex === undefined) {\n          throw new Error(\n            `2-element tuplet found but no common left index provided.\\n` +\n            `Character \"${char}\" at index ${index}: [${compressed.join(',')}]\\n` +\n            `This indicates a corrupted Tier 6b font file. Please regenerate font assets.`\n          );\n        }\n        indices = [\n          compressed[0],    // width\n          commonLeftIndex,  // left = common left\n          compressed[0],    // right = width (pattern 1)\n          compressed[1],    // ascent\n          commonLeftIndex   // descent = common left (pattern 2)\n        ];\n      }\n      else if (compressed.length === 3) {\n        // Case C: [w, l, a] → [w, l, w, a, l]\n        // Both w===r and l===d\n        indices = [\n          compressed[0],  // width\n          compressed[1],  // left\n          compressed[0],  // right = width (pattern 1)\n          compressed[2],  // ascent\n          compressed[1]   // descent = left (pattern 2)\n        ];\n      }\n      else if (compressed.length === 4) {\n        // Case B: [w, l, a, d] → [w, l, w, a, d]\n        // Only w===r\n        indices = [\n          compressed[0],  // width\n          compressed[1],  // left\n          compressed[0],  // right = width (pattern 1)\n          compressed[2],  // ascent\n          compressed[3]   // descent\n        ];\n      }\n      else if (compressed.length === 5) {\n        // Case A: [w, l, r, a, d] - no decompression needed\n        indices = compressed;\n      }\n      else {\n        throw new Error(\n          `Invalid glyph tuplet length for character \"${char}\" at index ${index}.\\n` +\n          `Expected 2, 3, 4, or 5 elements, got ${compressed.length}: [${compressed.join(',')}]\\n` +\n          `This indicates a corrupted font file. Please regenerate font assets.`\n        );\n      }\n\n      // TIER 4: Look up actual values from indices\n      const width = valueLookup[indices[0]];\n      const actualBoundingBoxLeft = valueLookup[indices[1]];\n      const actualBoundingBoxRight = valueLookup[indices[2]];\n      const actualBoundingBoxAscent = valueLookup[indices[3]];\n      const actualBoundingBoxDescent = valueLookup[indices[4]];\n\n      expanded[char] = {\n        // Glyph-specific metrics looked up from value table\n        width,\n        actualBoundingBoxLeft,\n        actualBoundingBoxRight,\n        actualBoundingBoxAscent,\n        actualBoundingBoxDescent,\n\n        // Copy over the metrics common to all characters.\n        // This is a bit of a waste of memory, however this object needs to\n        // look as much as possible like a TextMetrics object, and this\n        // is what it looks like.\n        fontBoundingBoxAscent: metricsCommonToAllCharacters.fba,\n        fontBoundingBoxDescent: metricsCommonToAllCharacters.fbd,\n        emHeightAscent: metricsCommonToAllCharacters.fba,          // Same as fontBoundingBoxAscent\n        emHeightDescent: metricsCommonToAllCharacters.fbd,         // Same as fontBoundingBoxDescent\n        hangingBaseline: metricsCommonToAllCharacters.hb,\n        alphabeticBaseline: metricsCommonToAllCharacters.ab,\n        ideographicBaseline: metricsCommonToAllCharacters.ib,\n        pixelDensity: metricsCommonToAllCharacters.pd              // pixelDensity (CRITICAL for atlas reconstruction)\n      };\n    });\n    return expanded;\n  }\n\n  /**\n   * Converts array of integer values back to floats by dividing by 10000\n   * TIER 6 OPTIMIZATION: Integer to value conversion\n   *\n   * @param {number[]} integers - Array of integer values\n   * @returns {number[]} Array of float values\n   * @private\n   */\n  static #convertIntegersToValues(integers) {\n    return integers.map(int => int / 10000);\n  }\n\n  /**\n   * Unflattens baseline array back to object\n   * TIER 6 OPTIMIZATION: Baseline array → object\n   *\n   * @param {number[]} baselineArray - Array [fba, fbd, hb, ab, ib, pd]\n   * @returns {Object} Baseline object with {fba, fbd, hb, ab, ib, pd}\n   * @private\n   */\n  static #unflattenBaseline(baselineArray) {\n    if (!Array.isArray(baselineArray) || baselineArray.length !== 6) {\n      throw new Error(\n        `Invalid baseline array - expected 6 elements, got ${baselineArray?.length}.\\n` +\n        `This indicates a corrupted font file. Please regenerate font assets.`\n      );\n    }\n\n    // Fixed order: fba, fbd, hb, ab, ib, pd\n    return {\n      fba: baselineArray[0],\n      fbd: baselineArray[1],\n      hb: baselineArray[2],\n      ab: baselineArray[3],\n      ib: baselineArray[4],\n      pd: baselineArray[5]\n    };\n  }\n\n  /**\n   * Unflattens tuplet data from negative delimiter format\n   * TIER 6b OPTIMIZATION: Tuplet array unflattening with negative delimiters\n   *\n   * Parses negative-delimited format and shifts back to 0-based indices.\n   * Negative numbers mark the end of each tuplet.\n   *\n   * Converts: [3,2,-15,1,2,16,-8] → [[2,1,14],[0,1,15,7]]\n   * Each tuplet ends with a negative number (1-based) which becomes last element (0-based)\n   *\n   * @param {number[]} flattened - Flattened array with negative delimiters (1-based indices)\n   * @returns {Array<Array<number>>} Array of tuplet arrays (0-based indices)\n   * @private\n   */\n  static #unflattenTuplets(flattened) {\n    const tuplets = [];\n    let currentTuplet = [];\n\n    for (let i = 0; i < flattened.length; i++) {\n      const value = flattened[i];\n\n      if (value < 0) {\n        // Negative marks end of tuplet\n        // Negate back and subtract 1 to get 0-based index\n        currentTuplet.push((-value) - 1);\n\n        // Validate tuplet length\n        if (currentTuplet.length < 2 || currentTuplet.length > 5) {\n          throw new Error(\n            `Invalid tuplet length ${currentTuplet.length} at position ${i}.\\n` +\n            `Expected 2, 3, 4, or 5. This indicates a corrupted font file.\\n` +\n            `Please regenerate font assets.`\n          );\n        }\n\n        tuplets.push(currentTuplet);\n        currentTuplet = [];\n      } else {\n        // Positive value: subtract 1 to get 0-based index\n        currentTuplet.push(value - 1);\n      }\n    }\n\n    // Check for incomplete tuplet at end\n    if (currentTuplet.length > 0) {\n      throw new Error(\n        `Incomplete tuplet at end of data.\\n` +\n        `Found ${currentTuplet.length} elements without negative delimiter.\\n` +\n        `This indicates a corrupted font file. Please regenerate font assets.`\n      );\n    }\n\n    return tuplets;\n  }\n\n}\n// ============================================================================\n// AtlasPositioning.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasPositioning.js\n// ============================================================================\n\n// AtlasPositioning - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It encapsulates atlas positioning data for a single font configuration as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasPositioningFAB for font assets building capabilities (if needed)\n// - Contains only essential positioning data and accessor methods\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas positioning for ONE font configuration\n// - Pre-computed lookups for optimal performance during glyph rendering\n// - xInAtlas values are reconstructed from tightWidth during deserialization (not serialized)\n// - Reconstruction happens once at load time, not per-character at render time\n// - All positioning data stored in memory for O(1) access during rendering\n// - Provides clean API for accessing glyph positioning within atlas\n// - Follows same immutable pattern as FontProperties and FontMetrics\n//\n// SEPARATION RATIONALE:\n// - Encapsulates related atlas positioning data together\n// - Eliminates repeated parameter passing for positioning lookups\n// - Serves as domain object for atlas positioning\n// - Enables cleaner, more object-oriented API\n//\nclass AtlasPositioning {\n  constructor(data, options = {}) {\n    // Validate input data structure\n    if (!data || typeof data !== 'object') {\n      throw new Error('AtlasPositioning constructor requires data object');\n    }\n\n    // Atlas positioning data for glyph rendering\n    this._tightWidth = data.tightWidth || {};\n    this._tightHeight = data.tightHeight || {};\n    this._dx = data.dx || {};\n    this._dy = data.dy || {};\n    // NOTE: xInAtlas and yInAtlas are reconstructed from tightWidth during deserialization (not serialized to reduce file size)\n    // At build time: populated by AtlasPositioningFAB during atlas packing\n    // At runtime: reconstructed by TightAtlasReconstructor during atlas loading\n    this._xInAtlas = data.xInAtlas || {};\n    this._yInAtlas = data.yInAtlas || {};\n\n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this._tightWidth);\n      Object.freeze(this._tightHeight);\n      Object.freeze(this._dx);\n      Object.freeze(this._dy);\n      Object.freeze(this._xInAtlas);\n      Object.freeze(this._yInAtlas);\n      Object.freeze(this);\n    }\n  }\n\n  /**\n   * Get positioning metrics for glyph rendering from atlas\n   * @param {string} char - Character (code point) to get positioning for\n   * @returns {Object} Object with xInAtlas, yInAtlas, tightWidth, tightHeight, dx, dy\n   */\n  getPositioning(char) {\n    return {\n      xInAtlas: this._xInAtlas[char],\n      yInAtlas: this._yInAtlas[char],\n      tightWidth: this._tightWidth[char],\n      tightHeight: this._tightHeight[char],\n      dx: this._dx[char],\n      dy: this._dy[char]\n    };\n  }\n\n  /**\n   * Check if positioning data exists for a character\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if positioning data exists\n   */\n  hasPositioning(char) {\n    return this._xInAtlas[char] !== undefined &&\n           this._yInAtlas[char] !== undefined &&\n           this._tightWidth[char] !== undefined &&\n           this._tightHeight[char] !== undefined;\n  }\n\n  /**\n   * Check if atlas position (xInAtlas, yInAtlas) exists for a character\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if atlas position exists\n   */\n  hasAtlasPosition(char) {\n    return this._xInAtlas[char] !== undefined &&\n           this._yInAtlas[char] !== undefined;\n  }\n\n  /**\n   * Get all available characters in this atlas positioning\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    return Object.keys(this._xInAtlas);\n  }\n\n  /**\n   * Get tight width for a character\n   * @param {string} char - Character (code point) to get width for\n   * @returns {number|undefined} Tight width or undefined if not found\n   */\n  getTightWidth(char) {\n    return this._tightWidth[char];\n  }\n\n  /**\n   * Get tight height for a character\n   * @param {string} char - Character (code point) to get height for\n   * @returns {number|undefined} Tight height or undefined if not found\n   */\n  getTightHeight(char) {\n    return this._tightHeight[char];\n  }\n\n  /**\n   * Get X position in atlas for a character\n   * @param {string} char - Character (code point) to get X position for\n   * @returns {number|undefined} X position in atlas or undefined if not found\n   */\n  getXInAtlas(char) {\n    return this._xInAtlas[char];\n  }\n\n  /**\n   * Get Y position in atlas for a character\n   * @param {string} char - Character (code point) to get Y position for\n   * @returns {number|undefined} Y position in atlas or undefined if not found\n   */\n  getYInAtlas(char) {\n    return this._yInAtlas[char];\n  }\n\n  /**\n   * Get dx offset for a character\n   * @param {string} char - Character (code point) to get dx for\n   * @returns {number|undefined} dx offset or undefined if not found\n   */\n  getDx(char) {\n    return this._dx[char];\n  }\n\n  /**\n   * Get dy offset for a character\n   * @param {string} char - Character (code point) to get dy for\n   * @returns {number|undefined} dy offset or undefined if not found\n   */\n  getDy(char) {\n    return this._dy[char];\n  }\n\n}\n// ============================================================================\n// AtlasImage.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasImage.js\n// ============================================================================\n\n// AtlasImage - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It encapsulates atlas image data as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasImageFAB for font assets building capabilities\n// - Contains only essential image data and accessor methods\n// - No image generation, validation, or serialization code\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas image for ONE font configuration\n// - Provides clean API for accessing image properties and validation\n// - Follows same immutable pattern as FontProperties, TextProperties, FontMetrics, and AtlasPositioning\n// - Establishes architectural symmetry: AtlasImage + AtlasPositioning = AtlasData\n//\n// SEPARATION RATIONALE:\n// - Encapsulates image-related functionality in dedicated domain object\n// - Eliminates raw Canvas/Image element handling throughout the codebase\n// - Provides consistent interface for image validation and access\n// - Enables cleaner, more object-oriented API design\n//\n// For font assets building capabilities, use AtlasImageFAB which extends this class.\nclass AtlasImage {\n  constructor(image, options = {}) {\n    // Validate input image\n    if (!image) {\n      throw new Error('AtlasImage constructor requires image (Canvas or Image element)');\n    }\n\n    if (typeof image !== 'object' || (image.width === undefined && image.naturalWidth === undefined)) {\n      throw new Error('AtlasImage constructor requires Canvas or Image element with width property');\n    }\n\n    // Store image (Canvas or Image element) - public field (object is frozen)\n    this.image = image;\n\n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this);\n    }\n  }\n\n  /**\n   * Get the width of the atlas image\n   * @returns {number} Width in pixels\n   */\n  get width() {\n    // Handle both Canvas (width) and Image (naturalWidth/width) elements\n    return this.image.naturalWidth || this.image.width || 0;\n  }\n\n  /**\n   * Get the height of the atlas image\n   * @returns {number} Height in pixels\n   */\n  get height() {\n    // Handle both Canvas (height) and Image (naturalHeight/height) elements\n    return this.image.naturalHeight || this.image.height || 0;\n  }\n\n  /**\n   * Check if this atlas image is valid for rendering\n   * @returns {boolean} True if image has valid dimensions\n   */\n  isValid() {\n    return this.image &&\n           typeof this.image === 'object' &&\n           this.width > 0 &&\n           this.height > 0;\n  }\n\n  /**\n   * Check if the image is ready for rendering operations\n   * @returns {boolean} True if image can be used for drawing operations\n   */\n  canRender() {\n    if (!this.isValid()) return false;\n\n    // For Image elements, check if they're loaded\n    if (this.image instanceof Image) {\n      return this.image.complete && this.image.naturalWidth > 0;\n    }\n\n    // Canvas elements are always ready if they have valid dimensions\n    return true;\n  }\n\n  /**\n   * Get the type of the underlying image element\n   * @returns {string} 'canvas' or 'image'\n   */\n  getImageType() {\n    if (this.image instanceof HTMLCanvasElement ||\n        (typeof OffscreenCanvas !== 'undefined' && this.image instanceof OffscreenCanvas)) {\n      return 'canvas';\n    }\n    if (this.image instanceof Image || this.image instanceof HTMLImageElement) {\n      return 'image';\n    }\n    return 'unknown';\n  }\n\n  /**\n   * Get a canvas context for drawing operations (if image is a canvas)\n   * @param {string} contextType - Context type (default: '2d')\n   * @returns {CanvasRenderingContext2D|null} Canvas context or null if not a canvas\n   */\n  getContext(contextType = '2d') {\n    if (this.getImageType() === 'canvas') {\n      return this.image.getContext(contextType);\n    }\n    return null;\n  }\n\n  /**\n   * Check if this atlas image equals another atlas image\n   * @param {AtlasImage} other - Another AtlasImage instance\n   * @returns {boolean} True if they reference the same image\n   */\n  equals(other) {\n    if (!(other instanceof AtlasImage)) return false;\n    return this.image === other.image;\n  }\n\n  /**\n   * Get debug information about this atlas image\n   * @returns {Object} Debug information\n   */\n  getDebugInfo() {\n    return {\n      type: this.getImageType(),\n      width: this.width,\n      height: this.height,\n      isValid: this.isValid(),\n      canRender: this.canRender()\n    };\n  }\n}\n// ============================================================================\n// AtlasData.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasData.js\n// ============================================================================\n\n// AtlasData - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It encapsulates both atlas image and positioning data for a font configuration.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Combines AtlasImage with AtlasPositioning data\n// - Provides unified interface for atlas image and positioning access\n// - Establishes architectural symmetry: AtlasImage + AtlasPositioning = AtlasData\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas image + positioning for ONE font configuration\n// - Stores AtlasImage instance with AtlasPositioning instance\n// - Provides clean API for accessing both image and positioning data\n// - Validates atlas integrity for rendering safety\n//\n// SEPARATION RATIONALE:\n// - Atlas positioning data moved from FontMetrics to be co-located with atlas images\n// - Reduces metrics file sizes (positioning only loaded when atlas is loaded)\n// - Better separation: metrics for measurement, atlas for rendering\n// - Perfect symmetry: both image and positioning are encapsulated in domain objects\n//\nclass AtlasData {\n  constructor(atlasImage, atlasPositioning) {\n    // Validate AtlasImage instance\n    if (!(atlasImage instanceof AtlasImage)) {\n      throw new Error('AtlasData constructor requires AtlasImage instance (not raw Canvas/Image)');\n    }\n\n    // Validate AtlasPositioning instance (optional but recommended)\n    if (atlasPositioning && !(atlasPositioning instanceof AtlasPositioning)) {\n      throw new Error('AtlasData constructor requires AtlasPositioning instance (not raw positioning object)');\n    }\n\n    // Store AtlasImage instance (public field - object is frozen)\n    this.atlasImage = atlasImage;\n\n    // Store AtlasPositioning instance (public field - object is frozen)\n    this.atlasPositioning = atlasPositioning;\n\n    // Freeze for immutability (safe to use as value object)\n    Object.freeze(this);\n  }\n\n  /**\n   * Check if positioning data exists for a character\n   * Null-safe convenience method that delegates to the AtlasPositioning instance.\n   * This demonstrates the delegation pattern: AtlasData wraps AtlasPositioning\n   * and provides a simplified interface for checking character availability.\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if positioning data exists\n   */\n  hasPositioning(char) {\n    if (!this.atlasPositioning) return false;\n\n    // Delegate to AtlasPositioning instance\n    return this.atlasPositioning.hasPositioning(char);\n  }\n\n  /**\n   * Check if this atlas data is valid for rendering\n   * @returns {boolean} True if atlas has valid image and dimensions\n   */\n  isValid() {\n    return this.atlasImage?.isValid();\n  }\n\n  /**\n   * Get all available characters in this atlas\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    if (!this.atlasPositioning) return [];\n\n    // Delegate to AtlasPositioning instance\n    return this.atlasPositioning.getAvailableCharacters();\n  }\n\n  /**\n   * Get the width of the atlas image\n   * @returns {number} Width in pixels\n   */\n  get width() {\n    return this.atlasImage.width;\n  }\n\n  /**\n   * Get the height of the atlas image\n   * @returns {number} Height in pixels\n   */\n  get height() {\n    return this.atlasImage.height;\n  }\n\n  /**\n   * Check if the atlas can be rendered\n   * @returns {boolean} True if atlas is ready for rendering operations\n   */\n  canRender() {\n    return this.atlasImage?.canRender();\n  }\n\n  /**\n   * Check if this atlas data equals another atlas data\n   * @param {AtlasData} other - Another AtlasData instance\n   * @returns {boolean} True if they reference the same image and positioning\n   */\n  equals(other) {\n    if (!(other instanceof AtlasData)) return false;\n    return this.atlasImage.equals(other.atlasImage) &&\n           this.atlasPositioning === other.atlasPositioning;\n  }\n\n  /**\n   * Get debug information about this atlas data\n   * @returns {Object} Debug information\n   */\n  getDebugInfo() {\n    return {\n      atlasImage: this.atlasImage ? this.atlasImage.getDebugInfo() : null,\n      atlasPositioning: this.atlasPositioning ? {\n        availableCharacters: this.atlasPositioning.getAvailableCharacters().length,\n        characters: this.atlasPositioning.getAvailableCharacters().slice(0, 10) // First 10 for brevity\n      } : null,\n      isValid: this.isValid(),\n      canRender: this.canRender()\n    };\n  }\n}\n// ============================================================================\n// AtlasReconstructionUtils.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/builder/AtlasReconstructionUtils.js\n// ============================================================================\n\n// AtlasReconstructionUtils - Shared utility for image data extraction\n// Used by TightAtlasReconstructor for atlas image processing\n//\n// ARCHITECTURAL DESIGN RATIONALE:\n// This utility class provides cross-platform image data extraction that works\n// in both browser and Node.js environments. It handles different image sources\n// (HTMLImageElement, Canvas, AtlasImage wrapper) and creates temporary canvases\n// as needed for pixel data access.\n//\n// By centralizing this logic here, we ensure:\n// - Zero code duplication across different reconstruction contexts\n// - Single source of truth for image data extraction\n// - Consistent cross-platform behavior (browser vs Node.js)\n// - Easy to unit test independently\n\nclass AtlasReconstructionUtils {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('AtlasReconstructionUtils cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Gets ImageData from various image sources\n   * Handles: HTMLImageElement (PNG), Canvas (QOI), AtlasImage wrapper\n   * @param {Image|Canvas|AtlasImage} image - Image source\n   * @returns {ImageData} ImageData object with pixel data\n   * @throws {Error} If image is not a valid source\n   */\n  static getImageData(image) {\n    // Unwrap AtlasImage if needed\n    const actualImage = image?.image ? image.image : image;\n\n    if (!actualImage) {\n      throw new Error('getImageData: Invalid image source (null or undefined)');\n    }\n\n    // If Canvas, directly get image data\n    if (actualImage.getContext) {\n      const ctx = actualImage.getContext('2d');\n      return ctx.getImageData(0, 0, actualImage.width, actualImage.height);\n    }\n\n    // If Image element, draw to temporary canvas first\n    if (actualImage.naturalWidth !== undefined || actualImage.width !== undefined) {\n      // Create canvas using explicit double invocation\n      const canvas = BitmapText.getCanvasFactory()();\n      canvas.width = actualImage.naturalWidth || actualImage.width;\n      canvas.height = actualImage.naturalHeight || actualImage.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(actualImage, 0, 0);\n      return ctx.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    throw new Error('getImageData: Image source is not a Canvas or Image element');\n  }\n}\n\n// ============================================================================\n// AtlasCellDimensions.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/utils/AtlasCellDimensions.js\n// ============================================================================\n\n// AtlasCellDimensions - Utility for calculating atlas cell dimensions\n//\n// Provides centralized formulas for calculating cell dimensions from character metrics.\n// These formulas MUST be consistent across AtlasBuilder and TightAtlasReconstructor.\n//\n// Cell dimensions follow the Atlas format (variable-width cells):\n// - Cell width: actualBoundingBoxLeft + actualBoundingBoxRight (varies per character)\n// - Cell height: fontBoundingBoxAscent + fontBoundingBoxDescent (constant per font)\n\nclass AtlasCellDimensions {\n  // Private constructor - prevent instantiation\n  constructor() {\n    throw new Error('AtlasCellDimensions cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Calculate cell width for a character\n   * CRITICAL: Must match GlyphFAB.js:155-160 which uses Math.round()\n   * @param {Object} charMetrics - Character metrics from FontMetrics\n   * @returns {number} Cell width in pixels (rounded, matching GlyphFAB canvas creation)\n   */\n  static getWidth(charMetrics) {\n    return Math.round(\n      charMetrics.actualBoundingBoxLeft +\n      charMetrics.actualBoundingBoxRight\n    );\n  }\n\n  /**\n   * Calculate cell height for a font\n   * CRITICAL: Must match GlyphFAB.js:170-175 which uses Math.round()\n   * @param {Object} charMetrics - Character metrics (any character from the font)\n   * @returns {number} Cell height in pixels (rounded, constant for entire font)\n   */\n  static getHeight(charMetrics) {\n    return Math.round(\n      charMetrics.fontBoundingBoxAscent +\n      charMetrics.fontBoundingBoxDescent\n    );\n  }\n\n  /**\n   * Calculate both dimensions\n   * @param {Object} charMetrics - Character metrics\n   * @returns {{width: number, height: number}}\n   */\n  static getDimensions(charMetrics) {\n    return {\n      width: this.getWidth(charMetrics),\n      height: this.getHeight(charMetrics)\n    };\n  }\n}\n\n// ============================================================================\n// TightAtlasReconstructor.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/TightAtlasReconstructor.js\n// ============================================================================\n\n// TightAtlasReconstructor - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for reconstructing tight atlases from\n// standard atlases via pixel scanning.\n//\n// DISTRIBUTION ROLE:\n// - Used by font-assets-builder.html and also by the runtime to reconstruct tight\n//   atlases for display and storage\n// - Reconstructs tight atlas + positioning data from atlas image\n//\n// ARCHITECTURE:\n// - Takes atlas image (square-ish grid layout) and FontMetrics\n// - Scans each character cell to find tight bounding box\n// - Repacks into tight atlas (single row)\n// - Calculates positioning data (dx, dy) using EXACT formulas from AtlasPositioningFAB\n//\n// GRID LAYOUT:\n// - Input atlas: Grid dimensions: ceil(sqrt(N)) columns (matches AtlasBuilder)\n// - Characters arranged: row = floor(charIndex / columns), col = charIndex % columns\n// - Output tight atlas: Single row (backward compatible)\n//\n// CRITICAL REQUIREMENTS:\n// - MUST use sorted character order (same as AtlasBuilder)\n// - dx/dy formulas MUST match AtlasPositioningFAB.js:87-88 exactly\n// - MUST handle multi-part glyphs (i, j with dots) correctly\n// - MUST use 4-step optimized tight bounds detection algorithm\n//\nclass TightAtlasReconstructor {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('TightAtlasReconstructor cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Main entry point - reconstructs tight atlas from standard atlas\n   *\n   * PARAMETER ORDER: Standardized to (fontMetrics, data) for API consistency\n   *\n   * @param {FontMetrics} fontMetrics - Font metrics for cell dimensions (CSS pixels) and positioning\n   * @param {Image|Canvas|AtlasImage} atlasImage - Atlas image (variable-width cells, already at physical pixels)\n   * @returns {{atlasImage: AtlasImage, atlasPositioning: AtlasPositioning}}\n   */\n  static reconstructFromAtlas(fontMetrics, atlasImage) {\n    // 1. Get ImageData from atlas for pixel scanning\n    const imageData = AtlasReconstructionUtils.getImageData(atlasImage);\n\n    // 2. Get SORTED character list (CRITICAL for determinism)\n    // Must match the order used in AtlasBuilder\n    const characters = fontMetrics.getAvailableCharacters().sort();\n\n    if (characters.length === 0) {\n      throw new Error('TightAtlasReconstructor: No characters found in FontMetrics');\n    }\n\n    console.debug(`TightAtlasReconstructor: Processing ${characters.length} characters`);\n\n    // 3. Calculate cell dimensions from font metrics\n    // Cell height is constant across all characters in this font\n    // Character metrics contain CSS pixel values, but we need to infer physical pixel dimensions\n    // from the actual atlas image by detecting pixelDensity from the ratio\n    const firstChar = characters[0];\n    const firstMetrics = fontMetrics.getCharacterMetrics(firstChar);\n\n    // Infer pixelDensity from first character's metrics vs atlas dimensions\n    // This works because: physical_pixels = CSS_pixels * pixelDensity\n    const height_CssPx = AtlasCellDimensions.getHeight(firstMetrics);\n    const pixelDensity = firstMetrics.pixelDensity || 1; // Use pixelDensity from metrics if available\n    const cellHeight_PhysPx = Math.round(height_CssPx * pixelDensity);\n\n    console.debug(`🔍 TightAtlasReconstructor: pixelDensity=${pixelDensity}, height_CssPx=${height_CssPx}, cellHeight_PhysPx=${cellHeight_PhysPx}`);\n\n    // 4. Calculate optimal grid dimensions based on character count (must match AtlasBuilder)\n    const gridDims = BitmapText.calculateOptimalGridDimensions(characters.length);\n    const GRID_COLUMNS = gridDims.columns;\n    const GRID_ROWS = gridDims.rows;\n\n    // 5. Calculate grid layout (matching AtlasBuilder)\n    // First pass: Calculate cell widths and column max widths\n    const cellWidths_PhysPx = [];\n    const columnMaxWidths_PhysPx = new Array(GRID_COLUMNS).fill(0);\n\n    for (let charIndex = 0; charIndex < characters.length; charIndex++) {\n      const char = characters[charIndex];\n      const charMetrics = fontMetrics.getCharacterMetrics(char);\n\n      // Cell width is variable per character (scale CSS pixels to physical pixels)\n      const width_CssPx = AtlasCellDimensions.getWidth(charMetrics);\n      const cellWidth_PhysPx = Math.round(width_CssPx * pixelDensity);\n\n      cellWidths_PhysPx[charIndex] = cellWidth_PhysPx;\n\n      // Track maximum width for this column\n      const col = charIndex % GRID_COLUMNS;\n      columnMaxWidths_PhysPx[col] = Math.max(columnMaxWidths_PhysPx[col], cellWidth_PhysPx);\n    }\n\n    // Calculate column X positions (cumulative sum of max widths)\n    const columnXPositions_PhysPx = [0];\n    for (let col = 0; col < GRID_COLUMNS - 1; col++) {\n      columnXPositions_PhysPx.push(columnXPositions_PhysPx[col] + columnMaxWidths_PhysPx[col]);\n    }\n\n    // 6. Scan each cell to find tight bounds within the atlas cell (grid layout)\n    const tightBounds = {};\n    const cellDebugInfo = []; // Track first 5 chars for debugging\n\n    for (let charIndex = 0; charIndex < characters.length; charIndex++) {\n      const char = characters[charIndex];\n      const cellWidth_PhysPx = cellWidths_PhysPx[charIndex];\n\n      // Calculate grid position\n      const col = charIndex % GRID_COLUMNS;\n      const row = Math.floor(charIndex / GRID_COLUMNS);\n\n      const cellX_PhysPx = columnXPositions_PhysPx[col];\n      const cellY_PhysPx = row * cellHeight_PhysPx;\n\n      // Debug first few characters\n      if (cellDebugInfo.length < 5) {\n        cellDebugInfo.push(`${char}:w=${cellWidth_PhysPx},r=${row},c=${col},x=${cellX_PhysPx},y=${cellY_PhysPx}`);\n      }\n\n      // Find tight bounds within this cell using 4-step optimized algorithm\n      const bounds = this.findTightBounds(\n        imageData,\n        cellX_PhysPx,\n        cellY_PhysPx,\n        cellWidth_PhysPx,\n        cellHeight_PhysPx\n      );\n\n      if (bounds) {\n        tightBounds[char] = bounds;\n      }\n    }\n\n    console.debug(`🔍 Cell dimensions (first 5): ${cellDebugInfo.join(', ')} [Grid: ${GRID_COLUMNS}×${GRID_ROWS}]`);\n\n    // 7. Repack into tight atlas with positioning data\n    return this.packTightAtlas(\n      fontMetrics,\n      tightBounds,\n      characters,\n      atlasImage,\n      pixelDensity,\n      cellHeight_PhysPx,\n      cellWidths_PhysPx,\n      columnXPositions_PhysPx,\n      GRID_COLUMNS\n    );\n  }\n\n  /**\n   * Find tight bounds within a cell using 4-step optimized algorithm\n   * This scans for the minimal bounding box of non-transparent pixels\n   *\n   * @param {ImageData} imageData - Image data from original atlas\n   * @param {number} cellX_PhysPx - X position of cell in atlas (physical pixels)\n   * @param {number} cellY_PhysPx - Y position of cell in atlas (physical pixels, always 0)\n   * @param {number} cellWidth_PhysPx - Width of this character's cell (physical pixels)\n   * @param {number} cellHeight_PhysPx - Height of cell (physical pixels, constant for font)\n   * @returns {{left, top, width, height} | null} - Tight bounds relative to cell origin, or null if empty\n   */\n  static findTightBounds(imageData, cellX_PhysPx, cellY_PhysPx, cellWidth_PhysPx, cellHeight_PhysPx) {\n    const pixels = imageData.data;\n    const atlasWidth_PhysPx = imageData.width;\n\n    // Helper to get alpha value at position\n    // Optimized: pre-calculate stride and use bit shift for x*4\n    const stride = atlasWidth_PhysPx * 4;\n    const getAlpha = (x, y) => pixels[y * stride + (x << 2) + 3];\n\n    // STEP 1: Find bottom edge (scan UP from bottom) - early exit\n    // This finds the bottommost row with any non-transparent pixel\n    let bottom_PhysPx = -1;\n    for (let y = cellY_PhysPx + cellHeight_PhysPx - 1; y >= cellY_PhysPx && bottom_PhysPx === -1; y--) {\n      for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx && bottom_PhysPx === -1; x++) {\n        if (getAlpha(x, y) > 0) {\n          bottom_PhysPx = y;\n        }\n      }\n    }\n\n    // Empty cell (no visible pixels)\n    if (bottom_PhysPx === -1) return null;\n\n    // STEP 2: Find top edge (scan DOWN, only to bottom) - early exit\n    // This finds the topmost row with any non-transparent pixel\n    let top_PhysPx = cellY_PhysPx;\n    for (let y = cellY_PhysPx; y <= bottom_PhysPx; y++) {\n      let found = false;\n      for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx; x++) {\n        if (getAlpha(x, y) > 0) {\n          top_PhysPx = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // STEP 3: Find left edge (scan columns, only vertical range found above) - early exit\n    // This finds the leftmost column with any non-transparent pixel\n    let left_PhysPx = cellX_PhysPx;\n    for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx; x++) {\n      let found = false;\n      for (let y = top_PhysPx; y <= bottom_PhysPx; y++) {\n        if (getAlpha(x, y) > 0) {\n          left_PhysPx = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // STEP 4: Find right edge (scan right→left, only vertical range) - early exit\n    // This finds the rightmost column with any non-transparent pixel\n    let right_PhysPx = cellX_PhysPx + cellWidth_PhysPx - 1;\n    for (let x = cellX_PhysPx + cellWidth_PhysPx - 1; x >= cellX_PhysPx; x--) {\n      let found = false;\n      for (let y = top_PhysPx; y <= bottom_PhysPx; y++) {\n        if (getAlpha(x, y) > 0) {\n          right_PhysPx = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // Return bounds relative to cell origin (not absolute atlas coordinates)\n    return {\n      left: left_PhysPx - cellX_PhysPx,        // Relative to cell left edge (physical pixels)\n      top: top_PhysPx - cellY_PhysPx,          // Relative to cell top edge (physical pixels)\n      width: right_PhysPx - left_PhysPx + 1,   // Inclusive width (physical pixels)\n      height: bottom_PhysPx - top_PhysPx + 1   // Inclusive height (physical pixels)\n    };\n  }\n\n  /**\n   * Pack tight glyphs and calculate positioning data\n   *\n   * PARAMETER ORDER: Standardized to (fontMetrics, data, options) for API consistency\n   *\n   * @param {FontMetrics} fontMetrics - Font metrics for positioning calculations\n   * @param {Object} tightBounds - Map of char → {left, top, width, height} within cells\n   * @param {Array<string>} characters - Sorted array of characters\n   * @param {Image|Canvas} sourceAtlasImage - Source Atlas image for extraction\n   * @param {number} pixelDensity - Pixel density multiplier for positioning calculations\n   * @param {number} cellHeight_PhysPx - Cell height in physical pixels (for distanceBetweenBottomAndBottomOfCanvas calculation)\n   * @param {Array<number>} cellWidths_PhysPx - Width of each character cell in physical pixels\n   * @param {Array<number>} columnXPositions_PhysPx - X position of each column in grid\n   * @param {number} GRID_COLUMNS - Number of columns in grid layout (for calculating row/col from charIndex)\n   * @returns {{atlasImage: AtlasImage, atlasPositioning: AtlasPositioning}}\n   */\n  static packTightAtlas(fontMetrics, tightBounds, characters, sourceAtlasImage, pixelDensity, cellHeight_PhysPx, cellWidths_PhysPx, columnXPositions_PhysPx, GRID_COLUMNS) {\n    // Calculate tight atlas dimensions (all in physical pixels)\n    let totalWidth_PhysPx = 0;\n    let maxHeight_PhysPx = 0;\n\n    for (const char of characters) {\n      if (tightBounds[char]) {\n        totalWidth_PhysPx += tightBounds[char].width;\n        maxHeight_PhysPx = Math.max(maxHeight_PhysPx, tightBounds[char].height);\n      }\n    }\n\n    // Create tight atlas canvas (explicit double invocation: get factory, call factory)\n    const tightCanvas = BitmapText.getCanvasFactory()();\n    tightCanvas.width = totalWidth_PhysPx;\n    tightCanvas.height = maxHeight_PhysPx;\n    const ctx = tightCanvas.getContext('2d');\n\n    // Initialize positioning data structure\n    let xInTightAtlas_PhysPx = 0;\n    const positioning = {\n      tightWidth: {},\n      tightHeight: {},\n      dx: {},\n      dy: {},\n      xInAtlas: {},\n      yInAtlas: {}\n    };\n\n    // Extract and pack each tight glyph\n    for (let charIndex = 0; charIndex < characters.length; charIndex++) {\n      const char = characters[charIndex];\n      const charMetrics = fontMetrics.getCharacterMetrics(char);\n\n      // Calculate grid position for source atlas\n      const col = charIndex % GRID_COLUMNS;\n      const row = Math.floor(charIndex / GRID_COLUMNS);\n\n      const cellX_PhysPx = columnXPositions_PhysPx[col];\n      const cellY_PhysPx = row * cellHeight_PhysPx;\n      const cellWidth_PhysPx = cellWidths_PhysPx[charIndex];\n\n      const bounds = tightBounds[char];\n      if (!bounds) {\n        // No visible pixels, skip to next character\n        continue;\n      }\n\n      // Extract tight glyph from original atlas\n      const tempCanvas = BitmapText.getCanvasFactory()();\n      tempCanvas.width = bounds.width;\n      tempCanvas.height = bounds.height;\n      const tempCtx = tempCanvas.getContext('2d');\n\n      // Copy tight region from atlas to temp canvas (using grid position)\n      const srcX_PhysPx = Math.floor(cellX_PhysPx + bounds.left);\n      const srcY_PhysPx = Math.floor(cellY_PhysPx + bounds.top);\n      const srcWidth_PhysPx = Math.floor(bounds.width);\n      const srcHeight_PhysPx = Math.floor(bounds.height);\n\n      tempCtx.drawImage(\n        sourceAtlasImage,\n        srcX_PhysPx, srcY_PhysPx,      // Source position in atlas (physical pixels)\n        srcWidth_PhysPx, srcHeight_PhysPx,  // Source dimensions (physical pixels)\n        0, 0,                           // Dest position in temp canvas\n        srcWidth_PhysPx, srcHeight_PhysPx   // Dest dimensions (physical pixels)\n      );\n\n      // Draw to tight atlas at sequential position\n      ctx.drawImage(tempCanvas, xInTightAtlas_PhysPx, 0);\n\n      // ═══════════════════════════════════════════════════════════════════════\n      // POSITIONING CALCULATION\n      // ═══════════════════════════════════════════════════════════════════════\n      //\n      // We need to calculate dx/dy offsets for rendering the tight glyph.\n      // These formulas MUST match AtlasPositioningFAB.js:91-92 exactly.\n      //\n      // Coordinate System Overview:\n      //\n      //   Atlas Cell (variable-width):        Tight Bounds:\n      //   ┌──────────────────────────┐\n      //   │ actualBoundingBox        │        ┌──────────┐\n      //   │ ┌──────────────────┐     │        │  ████    │  ← Minimal box\n      //   │ │                  │     │   →    │  ████    │     around pixels\n      //   │ │    ████          │     │        └──────────┘\n      //   │ │    ████          │     │\n      //   │ └──────────────────┘     │        dx = horizontal offset to align\n      //   │ fontBoundingBox          │        dy = vertical offset from baseline\n      //   └──────────────────────────┘\n      //     ↑                          ↑\n      //     cellX_PhysPx             cellX_PhysPx + cellWidth_PhysPx\n      //\n      // dx: Horizontal offset from rendering position to tight glyph position\n      //     Components:\n      //     - actualBoundingBoxLeft: Distance from text baseline to left edge of actual glyph\n      //     - bounds.left: Left edge of tight bounds within cell\n      //     Formula: -actualBoundingBoxLeft * pixelDensity + bounds.left\n      //\n      // dy: Vertical offset from baseline to top of tight glyph\n      //     Components:\n      //     - bounds.height: Height of tight glyph\n      //     - distanceBetweenBottomAndBottomOfCanvas: Gap below glyph (accounts for descenders)\n      //     - pixelDensity: Scale factor for high-DPI displays\n      //     Formula: -bounds.height - distanceBetweenBottomAndBottomOfCanvas + pixelDensity\n      //\n      //     The distanceBetweenBottomAndBottomOfCanvas accounts for descenders (like 'g', 'y')\n      //     and ensures proper vertical alignment relative to the text baseline.\n      //\n      // Note: pixelDensity is passed as a parameter (charMetrics only contains CSS pixel measurements)\n\n      // Calculate distance from bottom of tight bounds to bottom of character canvas\n      // This is used in the dy calculation\n      // Note: bounds.top + bounds.height - 1 gives the Y coordinate of the bottom pixel (like bottomRightCorner.y)\n      const distanceBetweenBottomAndBottomOfCanvas_PhysPx =\n        cellHeight_PhysPx - (bounds.top + bounds.height - 1) - 1;\n\n      // Store positioning data (all in physical pixels)\n      positioning.tightWidth[char] = bounds.width;    // Physical pixels\n      positioning.tightHeight[char] = bounds.height;  // Physical pixels\n      positioning.xInAtlas[char] = xInTightAtlas_PhysPx;  // Physical pixels\n      positioning.yInAtlas[char] = 0;  // Tight atlas is single row\n\n      // EXACT dx formula from AtlasPositioningFAB.js:91 (physical pixels)\n      positioning.dx[char] =\n        - Math.round(charMetrics.actualBoundingBoxLeft) * pixelDensity\n        + bounds.left;\n\n      // EXACT dy formula from AtlasPositioningFAB.js:92 (physical pixels)\n      positioning.dy[char] =\n        - bounds.height\n        - distanceBetweenBottomAndBottomOfCanvas_PhysPx\n        + 1 * pixelDensity;\n\n      xInTightAtlas_PhysPx += bounds.width;\n    }\n\n    // Create domain objects\n    const tightAtlasImage = new AtlasImage(tightCanvas);\n    const atlasPositioning = new AtlasPositioning(positioning);\n\n    console.debug(`TightAtlasReconstructor: Packed ${Object.keys(positioning.xInAtlas).length} glyphs into ${totalWidth_PhysPx}×${maxHeight_PhysPx} atlas`);\n\n    return { atlasImage: tightAtlasImage, atlasPositioning };\n  }\n}\n\n// ============================================================================\n// AtlasDataStore.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasDataStore.js\n// ============================================================================\n\n// AtlasDataStore - Core Runtime Static Class\n//\n// This is a CORE RUNTIME static class designed for minimal bundle size (~2-3KB).\n// It provides essential atlas data storage and retrieval for text rendering.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasDataStoreFAB for font assets building and generation\n// - Contains only atlas data structures and accessors needed at runtime\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Static class with private storage for AtlasData objects\n// - Uses Map-based storage for O(1) atlas lookups by font properties\n// - Provides the minimal atlas interface needed by BitmapText for glyph rendering\n// - Optimized for fast atlas access during text drawing\n// - Separate from FontMetricsStore to enable independent loading strategies\n//\n// SEPARATION RATIONALE:\n// - Atlas data contains both large binary images and positioning data loaded from atlas-*.js files\n// - Can be lazy-loaded on demand to optimize memory usage\n// - Independent of font metrics which are small and loaded upfront\n// - Aligns with file structure: atlas-*.js vs metrics-*.js\n//\n// For font assets building and generation capabilities, use AtlasDataStoreFAB.\nclass AtlasDataStore {\n  // Private static storage\n  // Keys are FontProperties.key strings for O(1) lookup\n  static #atlases = new Map(); // fontProperties.key → AtlasData\n\n  static getAtlasData(fontProperties) {\n    return AtlasDataStore.#atlases.get(fontProperties.key);\n  }\n\n  static setAtlasData(fontProperties, atlasData) {\n    // Only accept AtlasData instances\n    if (!(atlasData instanceof AtlasData)) {\n      throw new Error('AtlasDataStore.setAtlasData requires AtlasData instance (not raw images)');\n    }\n    AtlasDataStore.#atlases.set(fontProperties.key, atlasData);\n  }\n\n  // Helper method to check if an atlas is valid for rendering\n  static isValidAtlas(atlas) {\n    // Only work with AtlasData instances\n    if (!(atlas instanceof AtlasData)) {\n      return false;\n    }\n    return atlas.isValid();\n  }\n\n  // Get all available font properties keys\n  static getAvailableFonts() {\n    return Array.from(AtlasDataStore.#atlases.keys());\n  }\n\n  // Check if atlas exists for font properties\n  static hasAtlas(fontProperties) {\n    return AtlasDataStore.#atlases.has(fontProperties.key);\n  }\n\n  // Remove atlas for font properties\n  static deleteAtlas(fontProperties) {\n    return AtlasDataStore.#atlases.delete(fontProperties.key);\n  }\n\n  // Clear all atlases\n  static clear() {\n    AtlasDataStore.#atlases.clear();\n  }\n\n  // Get count of stored atlases\n  static size() {\n    return AtlasDataStore.#atlases.size;\n  }\n}\n\n// ============================================================================\n// FontMetricsStore.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontMetricsStore.js\n// ============================================================================\n\n// FontMetricsStore - Core Runtime Static Class\n//\n// This is a CORE RUNTIME static class designed for minimal bundle size (~2-3KB).\n// It provides essential font metrics storage and retrieval as a repository of FontMetrics instances.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontMetricsStoreFAB for font assets building and generation\n// - Contains only FontMetrics instance storage and retrieval\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Static class with private storage for FontMetrics instances\n// - Stores FontMetrics instances for fast O(1) lookup by font properties\n// - Simple repository pattern with get/set/has operations\n// - FontMetrics instances encapsulate all metrics data and behavior\n// - Separate from AtlasDataStore to enable independent loading strategies\n//\n// SEPARATION RATIONALE:\n// - Font metrics are small data loaded from metrics-*.js files\n// - Can be loaded upfront for immediate text measurement capabilities\n// - Independent of atlas images which are larger and can be lazy-loaded\n// - FontMetrics instances provide clean API without fontProperties parameter passing\n//\n// For font assets building and generation capabilities, use FontMetricsStoreFAB.\nclass FontMetricsStore {\n  // Private static storage\n  // Keys are FontProperties.key strings for O(1) FontMetrics instance lookup\n  static #fontMetrics = new Map(); // fontProperties.key → FontMetrics instance\n\n  /**\n   * Get FontMetrics instance for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {FontMetrics|undefined} FontMetrics instance or undefined if not found\n   */\n  static getFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.get(fontProperties.key);\n  }\n\n  /**\n   * Set FontMetrics instance for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {FontMetrics} fontMetrics - FontMetrics instance to store\n   */\n  static setFontMetrics(fontProperties, fontMetrics) {\n    FontMetricsStore.#fontMetrics.set(fontProperties.key, fontMetrics);\n  }\n\n  /**\n   * Check if FontMetrics exists for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if FontMetrics instance exists\n   */\n  static hasFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.has(fontProperties.key);\n  }\n\n  /**\n   * Remove FontMetrics for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if FontMetrics was removed\n   */\n  static deleteFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.delete(fontProperties.key);\n  }\n\n  /**\n   * Get all available font configurations\n   * @returns {string[]} Array of fontProperties.key strings\n   */\n  static getAvailableFonts() {\n    return Array.from(FontMetricsStore.#fontMetrics.keys());\n  }\n\n  /**\n   * Clear all stored FontMetrics instances\n   */\n  static clear() {\n    FontMetricsStore.#fontMetrics.clear();\n  }\n\n  /**\n   * Get count of stored FontMetrics instances\n   * @returns {number} Number of stored font configurations\n   */\n  static size() {\n    return FontMetricsStore.#fontMetrics.size;\n  }\n}\n\n// ============================================================================\n// FontManifest.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontManifest.js\n// ============================================================================\n\n// FontManifest - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It provides centralized font registry management for test and development environments.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Manages available font IDs without polluting global namespace\n// - Provides clean API for font registry operations\n// - Designed for use in test-renderer and development tools\n//\n// ARCHITECTURE:\n// - Static-only class for singleton behavior\n// - Modern private fields for encapsulation\n// - Returns copies of arrays to prevent external modification\n// - Simple, focused API for font ID management\n//\n// This class replaces the global bitmapTextManifest variable and provides\n// better encapsulation and a cleaner API for managing font registrations.\nclass FontManifest {\n  // Private static field to store font IDs\n  static #fontIDs = [];\n\n  // Add one or more font IDs to the registry\n  // Accepts either a single string ID or an array of IDs\n  static addFontIDs(ids) {\n    // Handle both single ID and array inputs\n    const idsArray = Array.isArray(ids) ? ids : [ids];\n\n    // Add IDs, avoiding duplicates\n    for (const id of idsArray) {\n      if (typeof id === 'string' && !this.#fontIDs.includes(id)) {\n        this.#fontIDs.push(id);\n      }\n    }\n  }\n\n  // Get all registered font IDs\n  // Returns a shallow copy to prevent external modification\n  static allFontIDs() {\n    return [...this.#fontIDs];\n  }\n\n  // Check if a specific font ID is registered\n  static hasFontID(id) {\n    return this.#fontIDs.includes(id);\n  }\n\n  // Get the count of registered font IDs\n  static count() {\n    return this.#fontIDs.length;\n  }\n\n  // Clear all registered font IDs\n  // Useful for testing and resetting state\n  static clear() {\n    this.#fontIDs.length = 0;\n  }\n\n  // Get font IDs as a sorted array\n  // Useful for consistent iteration order\n  static allFontIDsSorted() {\n    return [...this.#fontIDs].sort();\n  }\n}\n// ============================================================================\n// FontLoaderBase.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontLoaderBase.js\n// ============================================================================\n\n// FontLoaderBase - Abstract Static Base Class for Font Loading\n//\n// This abstract static class provides the core font loading infrastructure\n// for BitmapText. It defines the public API and shared logic for font loading,\n// while platform-specific implementations (browser, Node.js) extend this class.\n//\n// DISTRIBUTION ROLE:\n// - Used by both browser and Node.js distributions\n// - Defines abstract methods implemented by platform-specific loaders\n// - Contains shared loading orchestration and atlas reconstruction logic\n//\n// ARCHITECTURE:\n// - Abstract static class (not instantiated)\n// - Extended by FontLoaderBrowser and FontLoaderNode\n// - Owns fontDirectory configuration (#fontDirectory private field)\n// - Works with BitmapText's internal stores (#fontMetrics, #atlasData)\n// - Uses Template Method Pattern for platform-specific operations\n// - BitmapText delegates fontDirectory get/set to FontLoader (this class owns what it uses)\n//\n// LOADING FLOW:\n// 1. loadFonts() orchestrates loading of multiple fonts\n// 2. loadMetricsFile() loads metrics (platform-specific)\n// 3. loadAtlasFile() loads atlas image (platform-specific)\n// 4. loadAtlasFromPackage() reconstructs atlas from image (shared)\n// 5. processPendingAtlas() handles async atlas/metrics loading (shared)\n\nclass FontLoaderBase {\n  // ============================================\n  // Shared Static Storage\n  // ============================================\n\n  // Temporary storage for atlas packages before reconstruction\n  static _tempAtlasPackages = {};\n\n  // Pending atlases waiting for metrics\n  static _pendingAtlases = new Map();\n\n  // Loading promises to prevent duplicate loads\n  static _loadingPromises = new Map();\n\n  // ============================================\n  // Configuration\n  // ============================================\n\n  /**\n   * Default font directory for all platforms\n   * @constant {string}\n   */\n  static DEFAULT_FONT_DIRECTORY = './font-assets/';\n\n  /**\n   * User-configured font directory override (null = use default)\n   * @private\n   */\n  static #fontDirectory = null;\n\n  /**\n   * Set font directory (overrides default)\n   * @param {string} path - Path to font assets directory\n   */\n  static setFontDirectory(path) {\n    FontLoaderBase.#fontDirectory = path;\n  }\n\n  /**\n   * Get font directory (returns override or default)\n   * @returns {string} Font directory path\n   */\n  static getFontDirectory() {\n    return FontLoaderBase.#fontDirectory ?? FontLoaderBase.DEFAULT_FONT_DIRECTORY;\n  }\n\n  /**\n   * Get default font directory (shared across all platforms)\n   * @deprecated Use getFontDirectory() instead\n   * @returns {string} Font directory path\n   */\n  static getDefaultFontDirectory() {\n    return FontLoaderBase.DEFAULT_FONT_DIRECTORY;\n  }\n\n  // ============================================\n  // Registration API (called by asset files)\n  // ============================================\n\n  /**\n   * Register font metrics from metrics-*.js file\n   * Called by self-registering metrics files\n   * @param {string} idString - Font ID string\n   * @param {Object} compactedData - Compacted metrics data\n   * @param {Object} bitmapTextClass - BitmapText class reference (for backward compatibility)\n   */\n  static registerMetrics(idString, compactedData, bitmapTextClass) {\n    if (typeof idString !== 'string') {\n      console.warn('FontLoader.registerMetrics: Invalid idString - must be string');\n      return;\n    }\n\n    if (typeof MetricsExpander === 'undefined') {\n      console.warn('FontLoader.registerMetrics: MetricsExpander not available');\n      return;\n    }\n\n    if (typeof FontProperties === 'undefined') {\n      console.warn('FontLoader.registerMetrics: FontProperties not available');\n      return;\n    }\n\n    const fontProperties = FontProperties.fromIDString(idString);\n\n    // Determine character set based on font family\n    // If it's the font-invariant font, use the font-invariant character set\n    // Otherwise, pass undefined to let MetricsExpander default to standard set\n    let characterSet;\n    if (fontProperties.fontFamily === CharacterSets.INVARIANT_FONT_FAMILY) {\n      characterSet = Array.from(CharacterSets.FONT_INVARIANT_CHARS);\n    }\n\n    const fontMetrics = MetricsExpander.expand(compactedData, characterSet);\n\n    // Store metrics directly in FontMetricsStore\n    FontMetricsStore.setFontMetrics(fontProperties, fontMetrics);\n\n    // Process any pending atlases that were waiting for these metrics\n    FontLoaderBase._processPendingAtlas(idString);\n  }\n\n  /**\n   * Register atlas from atlas-*.js file (base64 only, positioning reconstructed later)\n   * Called by self-registering atlas files\n   * @param {string} idString - Font ID string\n   * @param {string} base64Data - Base64-encoded atlas data\n   */\n  static registerAtlas(idString, base64Data) {\n    if (typeof idString !== 'string' || typeof base64Data !== 'string') {\n      console.warn('FontLoader.registerAtlas: Invalid arguments - idString and base64Data must be strings');\n      return;\n    }\n\n    FontLoaderBase._tempAtlasPackages[idString] = { base64Data };\n  }\n\n  // ============================================\n  // Public Loading API\n  // ============================================\n\n  /**\n   * Load a single font\n   * @param {string} idString - Font ID string\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when font is loaded\n   */\n  static async loadFont(idString, options, bitmapTextClass) {\n    return this.loadFonts([idString], options, bitmapTextClass);\n  }\n\n  /**\n   * Load multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {boolean} [options.loadMetrics] - Load metrics (default: true)\n   * @param {boolean} [options.loadAtlases] - Load atlases (default: true)\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when all fonts are loaded\n   */\n  static async loadFonts(idStrings, options = {}, bitmapTextClass) {\n    const {\n      onProgress = null,\n      isFileProtocol = false,\n      loadMetrics = true,\n      loadAtlases = true\n    } = options;\n\n    const filesPerFont = (loadMetrics ? 1 : 0) + (loadAtlases ? 1 : 0);\n    const totalFiles = idStrings.length * filesPerFont;\n    let loadedFiles = 0;\n\n    const reportProgress = () => {\n      if (onProgress) onProgress(loadedFiles, totalFiles);\n    };\n\n    for (const idString of idStrings) {\n      // Check if already loading\n      if (FontLoaderBase._loadingPromises.has(idString)) {\n        await FontLoaderBase._loadingPromises.get(idString);\n        continue;\n      }\n\n      const loadPromise = (async () => {\n        try {\n          if (loadMetrics) {\n            await this.loadMetricsFile(idString, bitmapTextClass);\n            loadedFiles++;\n            reportProgress();\n          }\n\n          if (loadAtlases) {\n            await this.loadAtlasFile(idString, isFileProtocol, bitmapTextClass);\n            loadedFiles++;\n            reportProgress();\n          }\n        } finally {\n          FontLoaderBase._loadingPromises.delete(idString);\n        }\n      })();\n\n      FontLoaderBase._loadingPromises.set(idString, loadPromise);\n      await loadPromise;\n    }\n  }\n\n  /**\n   * Load only metrics for fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetrics(idStrings, options, bitmapTextClass) {\n    return this.loadFonts(idStrings, { ...options, loadAtlases: false }, bitmapTextClass);\n  }\n\n  /**\n   * Load only atlases for fonts (metrics must be loaded first)\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlases are loaded\n   */\n  static async loadAtlases(idStrings, options, bitmapTextClass) {\n    return this.loadFonts(idStrings, { ...options, loadMetrics: false }, bitmapTextClass);\n  }\n\n  // ============================================\n  // Platform-Specific Loading (Abstract Methods)\n  // ============================================\n\n  /**\n   * Load metrics file for a font\n   * @abstract Must be implemented by derived classes\n   * @param {string} idString - Font ID string\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetricsFile(idString, bitmapTextClass) {\n    throw new Error('FontLoaderBase.loadMetricsFile() must be implemented by derived class');\n  }\n\n  /**\n   * Load atlas file for a font\n   * @abstract Must be implemented by derived classes\n   * @param {string} idString - Font ID string\n   * @param {boolean} isFileProtocol - Whether using file:// protocol\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlas is loaded\n   */\n  static async loadAtlasFile(idString, isFileProtocol, bitmapTextClass) {\n    throw new Error('FontLoaderBase.loadAtlasFile() must be implemented by derived class');\n  }\n\n  // ============================================\n  // Shared Atlas Reconstruction Logic\n  // ============================================\n\n  /**\n   * Load atlas from package (image + metrics) and reconstruct positioning\n   * @param {string} idString - Font ID string\n   * @param {HTMLImageElement|HTMLCanvasElement} atlasImage - Atlas source image\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {boolean} True if atlas was reconstructed, false if pending metrics\n   */\n  static _loadAtlasFromPackage(idString, atlasImage, bitmapTextClass) {\n    const fontProperties = FontProperties.fromIDString(idString);\n\n    // Clean up temporary package storage\n    delete FontLoaderBase._tempAtlasPackages[idString];\n\n    // Get font metrics (required for reconstruction)\n    const fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n\n    if (!fontMetrics) {\n      // Store atlas for later reconstruction when metrics become available\n      FontLoaderBase._pendingAtlases.set(idString, { atlasImage, bitmapTextClass });\n      return false;\n    }\n\n    // Check if TightAtlasReconstructor is available\n    if (typeof TightAtlasReconstructor === 'undefined') {\n      throw new Error(`FontLoader: TightAtlasReconstructor required for font loading - not available for ${idString}`);\n    }\n\n    // Reconstruct tight atlas + positioning from Atlas image\n    const { atlasImage: tightAtlasImage, atlasPositioning } =\n      TightAtlasReconstructor.reconstructFromAtlas(fontMetrics, atlasImage);\n\n    // Create AtlasData instance\n    const atlasData = new AtlasData(tightAtlasImage, atlasPositioning);\n\n    // Store directly in AtlasDataStore\n    AtlasDataStore.setAtlasData(fontProperties, atlasData);\n\n    return true;\n  }\n\n  /**\n   * Process pending atlas that was waiting for metrics\n   * @param {string} idString - Font ID string\n   */\n  static _processPendingAtlas(idString) {\n    // Check if there's a pending atlas waiting for these metrics\n    if (!FontLoaderBase._pendingAtlases.has(idString)) {\n      return;\n    }\n\n    const { atlasImage, bitmapTextClass } = FontLoaderBase._pendingAtlases.get(idString);\n    FontLoaderBase._pendingAtlases.delete(idString);\n\n    // Try to load the atlas now that metrics are available\n    FontLoaderBase._loadAtlasFromPackage(idString, atlasImage, bitmapTextClass);\n  }\n}\n\n// ============================================================================\n// QOIDecode.js - Source: /Users/davidedellacasa/code/BitmapText.js/lib/QOIDecode.js\n// ============================================================================\n\n/**\n * Decode a QOI file given as an ArrayBuffer.\n *\n * @param {ArrayBuffer} arrayBuffer ArrayBuffer containing the QOI file.\n * @param {int|null} [byteOffset] Offset to the start of the QOI file in arrayBuffer\n * @param {int|null} [byteLength] Length of the QOI file in bytes\n * @param {int|null} [outputChannels] Number of channels to include in the decoded array\n *\n * @returns {{channels: number, data: Uint8Array, colorspace: number, width: number, error: boolean, height: number}}\n */\nfunction QOIDecode (arrayBuffer, byteOffset, byteLength, outputChannels) {\n    if (typeof byteOffset === 'undefined' || byteOffset === null) {\n        byteOffset = 0;\n    }\n\n    if (typeof byteLength === 'undefined' || byteLength === null) {\n        byteLength = arrayBuffer.byteLength - byteOffset;\n    }\n\n    const uint8 = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n\n    const magic1 = uint8[0];\n    const magic2 = uint8[1];\n    const magic3 = uint8[2];\n    const magic4 = uint8[3];\n\n    const width = ((uint8[4] << 24) | (uint8[5] << 16) | (uint8[6] << 8) | uint8[7]) >>> 0;\n    const height = ((uint8[8] << 24) | (uint8[9] << 16) | (uint8[10] << 8) | uint8[11]) >>> 0;\n\n    const channels = uint8[12];\n    const colorspace = uint8[13];\n\n    if (typeof outputChannels === 'undefined' || outputChannels === null) {\n        outputChannels = channels;\n    }\n\n    if (magic1 !== 0x71 || magic2 !== 0x6F || magic3 !== 0x69 || magic4 !== 0x66) {\n        throw new Error('QOI.decode: The signature of the QOI file is invalid');\n    }\n\n    if (channels < 3 || channels > 4) {\n        throw new Error('QOI.decode: The number of channels declared in the file is invalid');\n    }\n\n    if (colorspace > 1) {\n        throw new Error('QOI.decode: The colorspace declared in the file is invalid');\n    }\n\n    if (outputChannels < 3 || outputChannels > 4) {\n        throw new Error('QOI.decode: The number of channels for the output is invalid');\n    }\n\n    const pixelLength = width * height * outputChannels;\n    const result = new Uint8Array(pixelLength);\n\n    let arrayPosition = 14;\n\n    const index = new Uint8Array(64 * 4);\n    let indexPosition = 0;\n\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    let alpha = 255;\n\n    const chunksLength = byteLength - 8;\n\n    let run = 0;\n    let pixelPosition = 0;\n\n    for (; pixelPosition < pixelLength && arrayPosition < byteLength - 4; pixelPosition += outputChannels) {\n        if (run > 0) {\n            run--;\n        } else if (arrayPosition < chunksLength) {\n            const byte1 = uint8[arrayPosition++];\n\n            if (byte1 === 0b11111110) { // QOI_OP_RGB\n                red = uint8[arrayPosition++];\n                green = uint8[arrayPosition++];\n                blue = uint8[arrayPosition++];\n            } else if (byte1 === 0b11111111) { // QOI_OP_RGBA\n                red = uint8[arrayPosition++];\n                green = uint8[arrayPosition++];\n                blue = uint8[arrayPosition++];\n                alpha = uint8[arrayPosition++];\n            } else if ((byte1 & 0b11000000) === 0b00000000) { // QOI_OP_INDEX\n                red = index[byte1 * 4];\n                green = index[byte1 * 4 + 1];\n                blue = index[byte1 * 4 + 2];\n                alpha = index[byte1 * 4 + 3];\n            } else if ((byte1 & 0b11000000) === 0b01000000) { // QOI_OP_DIFF\n                red += ((byte1 >> 4) & 0b00000011) - 2;\n                green += ((byte1 >> 2) & 0b00000011) - 2;\n                blue += (byte1 & 0b00000011) - 2;\n\n                // handle wraparound\n                red = (red + 256) % 256;\n                green = (green + 256) % 256;\n                blue = (blue + 256) % 256;\n            } else if ((byte1 & 0b11000000) === 0b10000000) { // QOI_OP_LUMA\n                const byte2 = uint8[arrayPosition++];\n                const greenDiff = (byte1 & 0b00111111) - 32;\n                const redDiff = greenDiff + ((byte2 >> 4) & 0b00001111) - 8;\n                const blueDiff = greenDiff + (byte2 & 0b00001111) - 8;\n\n                // handle wraparound\n                red = (red + redDiff + 256) % 256;\n                green = (green + greenDiff + 256) % 256;\n                blue = (blue + blueDiff + 256) % 256;\n            } else if ((byte1 & 0b11000000) === 0b11000000) { // QOI_OP_RUN\n                run = byte1 & 0b00111111;\n            }\n\n            indexPosition = ((red * 3 + green * 5 + blue * 7 + alpha * 11) % 64) * 4;\n            index[indexPosition] = red;\n            index[indexPosition + 1] = green;\n            index[indexPosition + 2] = blue;\n            index[indexPosition + 3] = alpha;\n        }\n\n        if (outputChannels === 4) { // RGBA\n            result[pixelPosition] = red;\n            result[pixelPosition + 1] = green;\n            result[pixelPosition + 2] = blue;\n            result[pixelPosition + 3] = alpha;\n        } else { // RGB\n            result[pixelPosition] = red;\n            result[pixelPosition + 1] = green;\n            result[pixelPosition + 2] = blue;\n        }\n    }\n\n    if (pixelPosition < pixelLength) {\n        throw new Error('QOI.decode: Incomplete image');\n    }\n\n    // checking the 00000001 padding is not required, as per specs\n\n    return {\n        width: width,\n        height: height,\n        colorspace: colorspace,\n        channels: outputChannels,\n        data: result\n    };\n}\n// ============================================================================\n// FontLoader-node.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/platform/FontLoader-node.js\n// ============================================================================\n\n// FontLoader - Node.js-Specific Font Loader\n//\n// This static class extends FontLoaderBase to provide Node.js-specific\n// font loading implementation using Node.js APIs (fs, path, require).\n//\n// DISTRIBUTION ROLE:\n// - Only included in Node.js distributions\n// - Excluded from browser bundles via build scripts\n// - Uses Node.js-specific APIs (fs, path, eval)\n//\n// ARCHITECTURE:\n// - Static class extending FontLoaderBase\n// - Implements abstract methods for Node.js environment\n// - Uses fs.readFileSync for metrics and atlas loading\n// - Uses eval() to execute metrics registration code\n// - Uses QOIDecode for atlas decompression\n//\n// LOADING STRATEGIES:\n// - Metrics: fs.readFileSync + eval()\n// - Atlas: fs.readFileSync QOI file + QOIDecode + canvas creation\n\nclass FontLoader extends FontLoaderBase {\n\n  // ============================================\n  // File Name Constants (from BitmapText)\n  // ============================================\n\n  static METRICS_PREFIX = 'metrics-';\n  static ATLAS_PREFIX = 'atlas-';\n  static JS_EXTENSION = '.js';\n\n  // ============================================\n  // Node.js-Specific Loading Implementation\n  // ============================================\n\n  /**\n   * Load metrics file via fs.readFileSync + eval\n   * @param {string} idString - Font ID string\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetricsFile(idString, bitmapTextClass) {\n    if (typeof require === 'undefined') {\n      throw new Error('FontLoader.loadMetricsFile requires Node.js environment');\n    }\n\n    const fs = require('fs');\n    const path = require('path');\n\n    const fontDirectory = FontLoaderBase.getFontDirectory();\n    const metricsPath = path.resolve(fontDirectory, `${FontLoader.METRICS_PREFIX}${idString}${FontLoader.JS_EXTENSION}`);\n\n    try {\n      const metricsCode = fs.readFileSync(metricsPath, 'utf8');\n      // Execute with BitmapText in scope\n      // The metrics file will call BitmapText.registerMetrics()\n      eval(metricsCode);\n    } catch (error) {\n      console.warn(`Metrics file not found: ${metricsPath}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Load atlas file via fs.readFileSync + QOIDecode\n   * @param {string} idString - Font ID string\n   * @param {boolean} isFileProtocol - Not used in Node.js\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlas is loaded\n   */\n  static async loadAtlasFile(idString, isFileProtocol, bitmapTextClass) {\n    if (typeof require === 'undefined') {\n      throw new Error('FontLoader.loadAtlasFile requires Node.js environment');\n    }\n\n    const fs = require('fs');\n    const path = require('path');\n\n    const fontDirectory = FontLoaderBase.getFontDirectory();\n    const atlasPath = path.resolve(fontDirectory, `${FontLoader.ATLAS_PREFIX}${idString}-qoi${FontLoader.JS_EXTENSION}`);\n\n    try {\n      const atlasCode = fs.readFileSync(atlasPath, 'utf8');\n      // Execute with BitmapText in scope to call registerAtlas\n      // The atlas file will call BitmapText.registerAtlas()\n      eval(atlasCode);\n\n      // Now reconstruct the atlas\n      const pkg = FontLoaderBase._tempAtlasPackages[idString];\n      if (pkg && pkg.base64Data) {\n        // Decode QOI\n        if (typeof QOIDecode === 'undefined') {\n          throw new Error('FontLoader: QOIDecode not available - required for atlas loading');\n        }\n\n        const qoiData = Uint8Array.from(atob(pkg.base64Data), c => c.charCodeAt(0));\n        const decoded = QOIDecode(qoiData.buffer);\n\n        // Create canvas and draw (explicit double invocation: get factory, call factory)\n        const canvas = bitmapTextClass.getCanvasFactory()();\n        canvas.width = decoded.width;\n        canvas.height = decoded.height;\n        const ctx = canvas.getContext('2d');\n        const imageData = ctx.createImageData(decoded.width, decoded.height);\n        imageData.data.set(decoded.data);\n        ctx.putImageData(imageData, 0, 0);\n\n        // Reconstruct atlas\n        FontLoaderBase._loadAtlasFromPackage(idString, canvas, bitmapTextClass);\n      }\n    } catch (error) {\n      console.warn(`Atlas loading error for ${atlasPath}: ${error.message}`);\n      console.warn('Will use placeholder rectangles');\n    }\n  }\n}\n\n// ============================================================================\n// GLOBAL EXPORTS (Node.js)\n// ============================================================================\n// Expose classes globally for Node.js require() usage\nif (typeof global !== 'undefined') {\n  global.StatusCode = StatusCode;\n  global.SUCCESS_STATUS = SUCCESS_STATUS;\n  global.createErrorStatus = createErrorStatus;\n  global.getStatusDescription = getStatusDescription;\n  global.FontProperties = FontProperties;\n  global.TextProperties = TextProperties;\n  global.FontMetrics = FontMetrics;\n  global.BitmapText = BitmapText;\n  global.AtlasDataStore = AtlasDataStore;\n  global.FontMetricsStore = FontMetricsStore;\n  global.FontManifest = FontManifest;\n  global.QOIDecode = QOIDecode;\n}\n"],"mappings":"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","ignoreList":[]}