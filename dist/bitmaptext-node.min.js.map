{"version":3,"names":["StatusCode","Object","freeze","SUCCESS","NO_METRICS","PARTIAL_METRICS","NO_ATLAS","PARTIAL_ATLAS","SUCCESS_STATUS","code","createErrorStatus","details","isSuccess","status","isCompleteFailure","isPartialSuccess","getStatusDescription","requiresMinSize","requestedSize","minSize","missingChars","join","missingAtlasChars","FontProperties","constructor","pixelDensity","fontFamily","fontStyle","fontWeight","fontSize","this","_key","_idString","formatNumber","num","str","String","includes","replace","key","idString","fromIDString","parts","split","parseFloat","formatNumericPart","fromKey","integerPart","decimalPart","equals","other","TextProperties","options","isKerningEnabled","textBaseline","textAlign","textColor","withKerning","withColor","forBitmapText","withKerningEnabled","withTextColor","toObject","FontMetrics","data","Error","_kerningTable","kerningTable","_characterMetrics","characterMetrics","_spaceAdvancementOverride","spaceAdvancementOverrideForSmallSizesInPx","mutable","getCharacterMetrics","char","getKerningAdjustment","leftChar","rightChar","hasGlyph","getSpaceAdvancementOverride","getKerningTable","getAvailableCharacters","keys","InterpolatedFontMetrics","baseFontMetrics","targetSize","interpolationFactor","isInterpolatedMetrics","origMetrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","fontBoundingBoxAscent","fontBoundingBoxDescent","width","override","alphabeticBaseline_ab","hangingBaseline_ab","ideographicBaseline_ab","middleBaseline_ab","topBaseline_ab","BitmapText","static","generateCharacterSet","document","createElement","setFontDirectory","path","ensureFontLoader","fontLoader","getFontDirectory","setCanvasFactory","factory","canvasFactory","coloredGlyphCanvas","coloredGlyphCtx","getCanvasFactory","configure","undefined","fontDirectory","FontLoader","shouldUseMinSize","MIN_RENDERABLE_SIZE","createFontPropsAtMinSize","fontProperties","createInterpolatedFontMetrics","metricsAt8_5","redirectIdStringIfNeeded","silent","fontProps","minSizeProps","console","warn","redirected","originalSize","parametersToIDString","density","styleIdx","weightIdx","size","style","weight","densityStr","densityFormatted","sizeStr","registerMetrics","compactedData","fullIDString","FontLoaderBase","registerAtlas","base64Data","measureText","text","textProperties","length","metrics","fontMetrics","FontMetricsStore","getFontMetrics","Set","add","chars","width_CssPx","actualBoundingBoxLeft_CssPx","actualBoundingBoxRight_CssPx","advancement_CssPx","i","nextChar","Math","max","min","calculateAdvancement_CssPx","drawTextFromAtlas","ctx","x_CssPx","y_CssPx","getContext","forceInvalidAtlas","rendered","missingMetricsChars","atlasData","AtlasDataStore","getAtlasData","atlasValid","isValidAtlas","placeholdersUsed","save","setTransform","firstChar","find","c","characterMetricsForBaseline","baselineOffset_CssPx","calculateBaselineOffsetToBottom","alignmentOffset_CssPx","measureResult","calculateAlignmentOffsetToLeft","position_PhysPx","x","y","DEFAULT_TEXT_COLOR","batchResult","drawColoredTextBatched","forEach","currentChar","hasPositioning","drawCharacter","calculateCharacterAdvancement_PhysPx","statusCode","restore","spaceAdvancementOverrideForSmallSizesInPx_CssPx","kerningCorrection","getKerningCorrection","KERNING_UNIT_DIVISOR","round","fba","fbd","hb","hangingBaseline","ib","ideographicBaseline","textWidth_CssPx","startPosition_PhysPx","visualWidth_CssPx","textWidth_PhysPx","ceil","textHeight_PhysPx","actualBoundingBoxLeft_PhysPx","baselineY_PhysPx","height","clearRect","atlasPositioning","getPositioning","atlasImage","image","xInAtlas","tightWidth","tightHeight","dx","dy","drawImage","globalCompositeOperation","fillStyle","fillRect","drawPlaceholderRectangle","drawCharacterDirect","createColoredGlyph","renderGlyphToMainCanvas","width_PhysPx","height_PhysPx","rectX_PhysPx","rectY_PhysPx","actualColor","AtlasData","isValid","loadFont","redirection","loadFonts","idStrings","redirectedIdStrings","map","loadMetrics","loadAtlases","setAtlasData","deleteAtlas","setFontMetrics","unloadFont","deleteFontMetrics","unloadFonts","id","unloadMetrics","unloadAtlas","unloadAllFonts","clear","unloadAllAtlases","hasFont","hasMetrics","hasAtlas","hasFontMetrics","getLoadedFonts","loaded","getAvailableFonts","push","getLoadedMetrics","getLoadedAtlases","__resetForTesting","_loadingPromises","_tempAtlasPackages","_pendingAtlases","fromCharCode","cp1252PrintableChars","sort","r","a","MetricsExpander","decodeFromBase64Bytes","base64","bytes","Buffer","from","binary","atob","Uint8Array","charCodeAt","Array","decodeVarInts","integers","byte","value","shift","signed","decompressValueArray","deltas","sorted","expand","minified","isArray","kv","k","b","v","t","g","s","cl","convertIntegersToValues","unflattenBaseline","unflattenTuplets","expandedData","expandKerningTable","expandCharacterMetrics","debug","kerningValueLookup","leftExpanded","expandLeftSide","rangeExpanded","pairs","entries","expandKerningPairs","expanded","index","rightSideObj","hyphenIndex","indexOf","startChar","substring","endChar","startIndex","CHARACTER_SET","endIndex","parseCompactCharString","compactStr","j","tupletIndices","metricsCommonToAllCharacters","valueLookup","tupletLookup","commonLeftIndex","tupletIndex","compressed","indices","emHeightAscent","emHeightDescent","alphabeticBaseline","ab","pd","int","baselineArray","flattened","tuplets","currentTuplet","AtlasPositioning","_tightWidth","_tightHeight","_dx","_dy","_xInAtlas","hasAtlasPosition","getTightWidth","getTightHeight","getXInAtlas","getDx","getDy","getHash","pos","hash","toString","padStart","AtlasImage","naturalWidth","naturalHeight","canRender","Image","complete","getImageType","HTMLCanvasElement","OffscreenCanvas","HTMLImageElement","contextType","getDebugInfo","type","availableCharacters","characters","slice","AtlasReconstructionUtils","getImageData","actualImage","canvas","AtlasCellDimensions","getWidth","charMetrics","getHeight","getDimensions","TightAtlasReconstructor","reconstructFromAtlas","imageData","firstMetrics","height_CssPx","cellHeight_PhysPx","cellX_PhysPx","tightBounds","cellDebugInfo","cellWidth_PhysPx","bounds","findTightBounds","packTightAtlas","cellY_PhysPx","pixels","stride","getAlpha","bottom_PhysPx","top_PhysPx","found","left_PhysPx","right_PhysPx","left","top","sourceAtlasImage","totalWidth_PhysPx","maxHeight_PhysPx","tightCanvas","xInTightAtlas_PhysPx","positioning","tempCanvas","tempCtx","srcX_PhysPx","floor","srcY_PhysPx","srcWidth_PhysPx","srcHeight_PhysPx","distanceBetweenBottomAndBottomOfCanvas_PhysPx","tightAtlasImage","Map","atlases","get","set","atlas","has","delete","FontManifest","addFontIDs","ids","idsArray","fontIDs","allFontIDs","hasFontID","count","allFontIDsSorted","DEFAULT_FONT_DIRECTORY","getDefaultFontDirectory","bitmapTextClass","_processPendingAtlas","onProgress","isFileProtocol","filesPerFont","totalFiles","loadedFiles","reportProgress","loadPromise","loadMetricsFile","loadAtlasFile","_loadAtlasFromPackage","QOIDecode","arrayBuffer","byteOffset","byteLength","outputChannels","uint8","magic1","magic2","magic3","magic4","channels","colorspace","pixelLength","result","arrayPosition","indexPosition","red","green","blue","alpha","chunksLength","run","pixelPosition","byte1","byte2","greenDiff","require","fs","metricsPath","resolve","METRICS_PREFIX","JS_EXTENSION","metricsCode","readFileSync","eval","error","atlasPath","ATLAS_PREFIX","atlasCode","pkg","qoiData","decoded","buffer","createImageData","putImageData","message","global"],"sources":["/Users/davidedellacasa/code/BitmapText.js/dist/bitmaptext-node.js"],"sourcesContent":["/**\n * BitmapText.js - Runtime Bundle\n *\n * Pixel-perfect bitmap text rendering for HTML5 Canvas\n *\n * ⚠️  DO NOT EDIT - Generated by scripts/build-runtime-bundle.sh\n *\n * This bundle contains the complete BitmapText.js runtime for rendering\n * pre-generated bitmap fonts. It does NOT include font generation tools.\n *\n * Bundle Contents:\n *   - StatusCode (status reporting)\n *   - FontProperties/TextProperties (configuration)\n *   - FontMetrics (font metrics domain object)\n *   - BitmapText (core runtime with CHARACTER_SET)\n *   - MetricsExpander (minified metrics expansion)\n *   - Atlas classes (AtlasPositioning, AtlasImage, AtlasData)\n *   - TightAtlasReconstructor (runtime atlas reconstruction)\n *   - FontLoader (font loading with platform detection)\n *   - Atlas/Metrics stores (data storage)\n *\n * Usage (Browser):\n *   <script src=\"dist/bitmaptext.min.js\"></script>\n *   <script>\n *     const fontProps = new FontProperties(1, \"Arial\", \"normal\", \"normal\", 19);\n *     await BitmapText.loadFont(fontProps.idString);\n *     BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 50, fontProps);\n *   </script>\n *\n * Usage (Node.js):\n *   import { createCanvas } from 'node-canvas';  // or 'skia-canvas'\n *   import './dist/bitmaptext-node.min.js';\n *\n *   BitmapText.configure({\n *     fontDirectory: './font-assets/',\n *     canvasFactory: () => createCanvas()\n *   });\n *\n *   await BitmapText.loadFont(fontProps.idString);\n *   BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 50, fontProps);\n *\n * License: SEE LICENSE IN LICENSE\n */\n\n// ============================================================================\n// StatusCode.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/StatusCode.js\n// ============================================================================\n\n// StatusCode - Core Runtime Constants\n//\n// This is a CORE RUNTIME module designed for minimal bundle size (~0.5KB).\n// It provides status code constants and pre-created status objects for performance optimization.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Used by BitmapText for efficient status reporting\n// - No dependencies, pure constants and helper objects\n//\n// PERFORMANCE OPTIMIZATIONS:\n// - Numeric codes for faster comparisons than strings\n// - Pre-created immutable SUCCESS_STATUS object to avoid allocations\n// - Frozen objects for memory safety and immutability\n\n/**\n * Status codes for BitmapText operations\n * Using numeric values for optimal performance in comparisons\n */\nconst StatusCode = Object.freeze({\n  SUCCESS: 0,           // Everything worked perfectly\n  NO_METRICS: 1,        // No FontMetrics found at all for this font configuration\n  PARTIAL_METRICS: 2,   // Some characters missing metrics data\n  NO_ATLAS: 3,          // No atlas available (will render placeholder rectangles)\n  PARTIAL_ATLAS: 4      // Some characters missing from atlas (partial placeholders)\n});\n\n/**\n * Pre-created immutable success status object for performance\n * Reused for all successful operations to avoid object allocation overhead\n */\nconst SUCCESS_STATUS = Object.freeze({\n  code: StatusCode.SUCCESS\n});\n\n/**\n * Helper function to create error status objects\n * @param {number} code - StatusCode value\n * @param {Object} details - Additional details object\n * @returns {Object} Immutable status object\n */\nfunction createErrorStatus(code, details = {}) {\n  return Object.freeze({\n    code,\n    ...details\n  });\n}\n\n/**\n * Helper function to check if a status indicates success\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates success\n */\nfunction isSuccess(status) {\n  return status?.code === StatusCode.SUCCESS;\n}\n\n/**\n * Helper function to check if a status indicates complete failure\n * (NO_METRICS or PARTIAL_METRICS - cannot render at all)\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates complete failure\n */\nfunction isCompleteFailure(status) {\n  return status && (\n    status.code === StatusCode.NO_METRICS ||\n    status.code === StatusCode.PARTIAL_METRICS\n  );\n}\n\n/**\n * Helper function to check if a status indicates partial success\n * (NO_ATLAS or PARTIAL_ATLAS - can render with placeholders)\n * @param {Object} status - Status object with code property\n * @returns {boolean} True if status indicates partial success\n */\nfunction isPartialSuccess(status) {\n  return status && (\n    status.code === StatusCode.NO_ATLAS ||\n    status.code === StatusCode.PARTIAL_ATLAS\n  );\n}\n\n/**\n * Helper function to get human-readable status description\n * @param {Object} status - Status object with code property\n * @returns {string} Human-readable description\n */\nfunction getStatusDescription(status) {\n  if (!status || typeof status.code !== 'number') {\n    return 'Invalid status';\n  }\n\n  switch (status.code) {\n    case StatusCode.SUCCESS:\n      return 'Success';\n    case StatusCode.NO_METRICS:\n      if (status.requiresMinSize) {\n        return `Font size ${status.requestedSize}px requires size ${status.minSize}px metrics for interpolation. Please load size ${status.minSize}px font assets.`;\n      }\n      return 'No font metrics available';\n    case StatusCode.PARTIAL_METRICS:\n      return `Missing metrics for characters: ${status.missingChars ? [...status.missingChars].join('') : 'unknown'}`;\n    case StatusCode.NO_ATLAS:\n      return 'No atlas available (using placeholders)';\n    case StatusCode.PARTIAL_ATLAS:\n      return `Missing atlas data for characters: ${status.missingAtlasChars ? [...status.missingAtlasChars].join('') : 'unknown'} (using placeholders)`;\n    default:\n      return `Unknown status code: ${status.code}`;\n  }\n}\n// ============================================================================\n// FontProperties.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontProperties.js\n// ============================================================================\n\n// FontProperties - Core Runtime Class  \n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It provides essential font configuration management with maximum performance.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontPropertiesFAB for validation and font assets building utilities  \n// - Contains no validation code to minimize runtime overhead\n// - Optimized for performance with pre-computed keys and immutability\n//\n// ARCHITECTURE:\n// - Immutable font configuration object safe to use as Map keys\n// - Pre-computes storage keys and ID strings for optimal lookup performance\n// - Provides factory methods for creating instances from various inputs\n// - Properties in fixed order: pixelDensity, fontFamily, fontStyle, fontWeight, fontSize\n//\n// For validation and font assets building utilities, use FontPropertiesFAB.\nclass FontProperties {\n  constructor(pixelDensity, fontFamily, fontStyle, fontWeight, fontSize) {\n    // Direct assignment, no validation in core for performance\n    this.pixelDensity = pixelDensity || 1;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = fontWeight || 'normal';\n    this.fontSize = fontSize;\n    \n    // Pre-compute storage key (critical for performance optimization)\n    // Used for Map lookups in AtlasDataStore\n    this._key = `${this.pixelDensity}:${this.fontFamily}:${this.fontStyle}:${this.fontWeight}:${this.fontSize}`;\n    \n    // Pre-compute ID string for file naming and manifest keys\n    // Format: density-1-0-Arial-style-normal-weight-normal-size-18-0\n    this._idString = `density-${this.#formatNumber(this.pixelDensity)}-${this.fontFamily}-style-${this.fontStyle}-weight-${this.fontWeight}-size-${this.#formatNumber(this.fontSize)}`;\n    \n    // Freeze for immutability (safe to use as Map keys)\n    Object.freeze(this);\n  }\n  \n  // Format number handling non-integers: 1.5 → \"1-5\", 18.5 → \"18-5\", 18 → \"18-0\"\n  #formatNumber(num) {\n    const str = String(num);\n    return str.includes('.') ? str.replace('.', '-') : `${str}-0`;\n  }\n  \n  // Getter for pre-computed storage key\n  get key() {\n    return this._key;\n  }\n  \n  // Getter for pre-computed ID string\n  get idString() {\n    return this._idString;\n  }\n  \n  \n  // Factory method to create FontProperties from ID string\n  // Parses: density-1-0-Arial-style-normal-weight-normal-size-18-0\n  static fromIDString(idString) {\n    const parts = idString.split('-');\n\n    // Extract and format numeric values (handling decimal parts)\n    const pixelDensity = parseFloat(FontProperties.#formatNumericPart(parts[1], parts[2]));\n    const fontSize = parseFloat(FontProperties.#formatNumericPart(parts[9], parts[10]));\n    const fontFamily = parts[3];\n    const fontStyle = parts[5];\n    const fontWeight = parts[7];\n\n    // Return new FontProperties instance\n    return new FontProperties(pixelDensity, fontFamily, fontStyle, fontWeight, fontSize);\n  }\n\n  // Factory method to create FontProperties from storage key\n  // Parses: \"1:Arial:normal:normal:19\" or \"1.5:Arial:italic:bold:18.5\"\n  static fromKey(key) {\n    const [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize] = key.split(':');\n\n    // Return new FontProperties instance with parsed numeric values\n    return new FontProperties(\n      parseFloat(pixelDensity),\n      fontFamily,\n      fontStyle,\n      fontWeight,\n      parseFloat(fontSize)\n    );\n  }\n\n  // Helper method to format numeric parts (used by fromIDString)\n  static #formatNumericPart(integerPart, decimalPart) {\n    if (!decimalPart || decimalPart === '0') {\n      return integerPart;\n    }\n    return `${integerPart}.${decimalPart}`;\n  }\n  \n  // Equality comparison based on key\n  equals(other) {\n    if (!(other instanceof FontProperties)) return false;\n    return this._key === other._key;\n  }\n}\n// ============================================================================\n// TextProperties.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/TextProperties.js\n// ============================================================================\n\n// TextProperties - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It provides essential text rendering configuration with maximum performance.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Manages text rendering properties: kerning, alignment, baseline, color\n// - Contains no validation code to minimize runtime overhead\n// - Optimized for performance with pre-computed keys and immutability\n//\n// ARCHITECTURE:\n// - Immutable text configuration object safe to use as Map keys\n// - Pre-computes storage keys for optimal lookup performance\n// - Provides factory methods for creating instances from various inputs\n// - Properties: isKerningEnabled, textBaseline, textAlign, textColor\n//\n// This class replaces the global isKerningEnabled variable and consolidates\n// all text rendering properties into a single, immutable configuration object.\nclass TextProperties {\n  constructor(options = {}) {\n    // Extract options with defaults - optimized for BitmapText usage\n    const {\n      isKerningEnabled = true,        // Enable kerning by default for better text rendering\n      textBaseline = 'bottom',        // BitmapText uses 'bottom' baseline by architectural design (HTML5 Canvas default is 'alphabetic')\n      textAlign = 'left',             // HTML5 Canvas default\n      textColor = '#000000'           // Black color default\n    } = options;\n\n    // Direct assignment, no validation in core for performance\n    this.isKerningEnabled = isKerningEnabled;\n    this.textBaseline = textBaseline;\n    this.textAlign = textAlign;\n    this.textColor = textColor;\n\n    // Pre-compute storage key (for potential caching or Map lookups)\n    this._key = `kerning:${this.isKerningEnabled}:baseline:${this.textBaseline}:align:${this.textAlign}:color:${this.textColor}`;\n\n    // Freeze for immutability (safe to use as Map keys)\n    Object.freeze(this);\n  }\n\n  // Getter for pre-computed storage key\n  get key() {\n    return this._key;\n  }\n\n  // Factory method to create TextProperties with specific kerning setting\n  static withKerning(isKerningEnabled, options = {}) {\n    return new TextProperties({\n      ...options,\n      isKerningEnabled\n    });\n  }\n\n  // Factory method to create TextProperties with specific color\n  static withColor(textColor, options = {}) {\n    return new TextProperties({\n      ...options,\n      textColor\n    });\n  }\n\n  // Factory method to create TextProperties for BitmapText (uses 'bottom' baseline)\n  static forBitmapText(options = {}) {\n    return new TextProperties({\n      textBaseline: 'bottom',  // BitmapText uses bottom baseline positioning\n      ...options\n    });\n  }\n\n  // Create a new TextProperties with modified kerning\n  withKerningEnabled(isKerningEnabled) {\n    return new TextProperties({\n      isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor: this.textColor\n    });\n  }\n\n  // Create a new TextProperties with modified color\n  withTextColor(textColor) {\n    return new TextProperties({\n      isKerningEnabled: this.isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor\n    });\n  }\n\n  // Equality comparison based on key\n  equals(other) {\n    if (!(other instanceof TextProperties)) return false;\n    return this._key === other._key;\n  }\n\n  // Return plain object for compatibility/debugging\n  toObject() {\n    return {\n      isKerningEnabled: this.isKerningEnabled,\n      textBaseline: this.textBaseline,\n      textAlign: this.textAlign,\n      textColor: this.textColor\n    };\n  }\n}\n// ============================================================================\n// FontMetrics.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontMetrics.js\n// ============================================================================\n\n// FontMetrics - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~3-4KB).\n// It encapsulates all metrics data for a single font configuration as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontMetricsFAB for font assets building capabilities\n// - Contains only essential metrics data and accessor methods\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Immutable object representing all metrics for ONE font configuration\n// - Pre-computed lookups for optimal performance during text rendering\n// - Provides clean API without needing fontProperties passed to every method\n// - Follows same immutable pattern as FontProperties\n//\n// SEPARATION RATIONALE:\n// - Encapsulates related metrics data together\n// - Eliminates repeated fontProperties parameter passing\n// - Serves as domain object for font metrics\n// - Enables cleaner, more object-oriented API\n//\n// For font assets building capabilities, use FontMetricsFAB which extends this class.\nclass FontMetrics {\n  constructor(data, options = {}) {\n    // Validate input data structure\n    if (!data || typeof data !== 'object') {\n      throw new Error('FontMetrics constructor requires data object');\n    }\n    \n    // Kerning table: character pairs → adjustment values\n    this._kerningTable = data.kerningTable || {};\n    \n    // Character metrics: character → TextMetrics-compatible object\n    this._characterMetrics = data.characterMetrics || {};\n    \n    // Space advancement override for small font sizes\n    this._spaceAdvancementOverride = data.spaceAdvancementOverrideForSmallSizesInPx || null;\n    \n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this._kerningTable);\n      Object.freeze(this._characterMetrics);\n      Object.freeze(this);\n    }\n  }\n  \n  /**\n   * Get text measurement metrics for a character\n   * @param {string} char - Character (code point) to get metrics for\n   * @returns {Object} TextMetrics-compatible object\n   */\n  getCharacterMetrics(char) {\n    return this._characterMetrics[char];\n  }\n  \n  /**\n   * Get kerning adjustment between two characters\n   * @param {string} leftChar - Left character in pair\n   * @param {string} rightChar - Right character in pair  \n   * @returns {number} Kerning adjustment value (0 if no adjustment)\n   */\n  getKerningAdjustment(leftChar, rightChar) {\n    if (!leftChar || !rightChar) return 0;\n    return this._kerningTable[leftChar]?.[rightChar] || 0;\n  }\n  \n  /**\n   * Check if glyph exists in this font\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if glyph has metrics\n   */\n  hasGlyph(char) {\n    return char in this._characterMetrics;\n  }\n  \n  /**\n   * Get space advancement override for small font sizes\n   * @returns {number|null} Override value in pixels, or null if no override\n   */\n  getSpaceAdvancementOverride() {\n    return this._spaceAdvancementOverride;\n  }\n  \n  /**\n   * Get the complete kerning table (for compatibility/debugging)\n   * @returns {Object} Complete kerning table\n   */\n  getKerningTable() {\n    return this._kerningTable;\n  }\n  \n  /**\n   * Get all available characters in this font\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    return Object.keys(this._characterMetrics);\n  }\n  \n}\n// ============================================================================\n// InterpolatedFontMetrics.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/InterpolatedFontMetrics.js\n// ============================================================================\n\n// InterpolatedFontMetrics - Wrapper for FontMetrics that scales metric values\n//\n// This is a RUNTIME class used by BitmapText to support font sizes < 8.5px.\n//\n// USAGE:\n// - Font sizes < 8.5px interpolate metrics from size 8.5px\n// - All metric values (widths, kerning, baselines) are scaled proportionally\n// - Marker property `isInterpolatedMetrics` enables conditional rounding in BitmapText\n//\n// ARCHITECTURE:\n// - Wraps a FontMetrics instance (typically size 8.5px)\n// - Scales all metric values by interpolationFactor = targetSize / 8.5\n// - Delegates glyph checking and kerning table access to base metrics\n// - Used exclusively for rendering placeholder rectangles (atlases never loaded)\n//\n// DEPENDENCIES:\n// - Requires FontMetrics.js to be loaded first\n// - Used by BitmapText.js for sizes < MIN_RENDERABLE_SIZE (8.5px)\n//\n/**\n * InterpolatedFontMetrics - Wrapper for FontMetrics that scales all values\n *\n * Used for font sizes < 8.5px which interpolate metrics from size 8.5px.\n * All metric values (widths, kerning, baselines) are scaled proportionally.\n *\n * Marker property `isInterpolatedMetrics` enables conditional rounding in\n * calculateAdvancement_CssPx() to preserve linear scaling behavior.\n */\nclass InterpolatedFontMetrics {\n  constructor(baseFontMetrics, targetSize) {\n    this.baseFontMetrics = baseFontMetrics;\n    this.targetSize = targetSize;\n    this.interpolationFactor = targetSize / 8.5;  // MIN_RENDERABLE_SIZE constant value\n\n    // Marker for detection in calculateAdvancement_CssPx()\n    // Enables float positioning instead of integer rounding\n    this.isInterpolatedMetrics = true;\n  }\n\n  // Interpolate character metrics by scaling all values\n  getCharacterMetrics(char) {\n    const origMetrics = this.baseFontMetrics.getCharacterMetrics(char);\n    if (!origMetrics) return null;\n\n    return {\n      actualBoundingBoxLeft: origMetrics.actualBoundingBoxLeft * this.interpolationFactor,\n      actualBoundingBoxRight: origMetrics.actualBoundingBoxRight * this.interpolationFactor,\n      actualBoundingBoxAscent: origMetrics.actualBoundingBoxAscent * this.interpolationFactor,\n      actualBoundingBoxDescent: origMetrics.actualBoundingBoxDescent * this.interpolationFactor,\n      fontBoundingBoxAscent: origMetrics.fontBoundingBoxAscent * this.interpolationFactor,\n      fontBoundingBoxDescent: origMetrics.fontBoundingBoxDescent * this.interpolationFactor,\n      width: origMetrics.width * this.interpolationFactor\n    };\n  }\n\n  // Delegate glyph checking to base metrics\n  hasGlyph(char) {\n    return this.baseFontMetrics.hasGlyph(char);\n  }\n\n  // Interpolate kerning adjustment by scaling\n  getKerningAdjustment(leftChar, rightChar) {\n    const origKerning = this.baseFontMetrics.getKerningAdjustment(leftChar, rightChar);\n    return origKerning * this.interpolationFactor;\n  }\n\n  // Delegate kerning table getter to base metrics\n  getKerningTable() {\n    return this.baseFontMetrics.getKerningTable();\n  }\n\n  // Interpolate space advancement override if present\n  getSpaceAdvancementOverride() {\n    const override = this.baseFontMetrics.getSpaceAdvancementOverride();\n    return override !== null ? override * this.interpolationFactor : null;\n  }\n\n  // Property getters\n  get fontSize() {\n    return this.targetSize;\n  }\n\n  get alphabeticBaseline_ab() {\n    return this.baseFontMetrics.alphabeticBaseline_ab * this.interpolationFactor;\n  }\n\n  get hangingBaseline_ab() {\n    return this.baseFontMetrics.hangingBaseline_ab * this.interpolationFactor;\n  }\n\n  get ideographicBaseline_ab() {\n    return this.baseFontMetrics.ideographicBaseline_ab * this.interpolationFactor;\n  }\n\n  get middleBaseline_ab() {\n    return this.baseFontMetrics.middleBaseline_ab * this.interpolationFactor;\n  }\n\n  get topBaseline_ab() {\n    return this.baseFontMetrics.topBaseline_ab * this.interpolationFactor;\n  }\n}\n\n// ============================================================================\n// BitmapText.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/BitmapText.js\n// ============================================================================\n\n// BitmapText - Static Core Runtime Class\n//\n// Status constants are loaded as global variables by StatusCode.js (loaded before this file)\n// In Node.js bundles, StatusCode.js is concatenated before this file\nif (typeof StatusCode === 'undefined' || typeof SUCCESS_STATUS === 'undefined' || typeof createErrorStatus === 'undefined') {\n  throw new Error('StatusCode.js must be loaded before BitmapText.js');\n}\n//\n// This is a STATIC CORE RUNTIME class designed for minimal bundle size and zero-ceremony usage.\n// It provides essential text rendering capabilities for consuming pre-built bitmap fonts.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - All methods are static - no instantiation needed\n// - Contains no font generation code to keep bundle size minimal\n//\n// ARCHITECTURE:\n// - Facade pattern: Delegates storage to AtlasDataStore/FontMetricsStore, font loading to FontLoader\n// - fontDirectory configuration owned by FontLoader (this class delegates get/set)\n// - Auto-detects environment (browser vs Node.js) for canvas creation\n// - Draws text by looking up glyphs from atlases and positioning them with metrics/kerning\n// - Uses textBaseline='bottom' positioning (y = bottom of text bounding box)\n// - Supports placeholder rectangles when atlases are missing but metrics are available\n//\n// CANVAS FACTORY (Node.js only):\n// - Node.js has no DOM, thus no native Canvas\n// - BitmapText needs Canvas to:\n//   1. Load atlas images from files\n//   2. Scan pixels to find tight bounding boxes for each glyph\n//   3. Create tight atlas from scanned data\n// - Cannot pass class reference: HTMLCanvasElement is NOT constructible\n//   (new HTMLCanvasElement() throws \"Illegal constructor\")\n// - Must pass factory function: () => new Canvas()\n// - Browser: via document.createElement('canvas')\n// - Node.js: Must configure with canvas-mock providing Canvas constructor\n//\n// USAGE:\n// - Zero configuration for browser: Just call BitmapText.drawTextFromAtlas()\n// - Node.js: Optionally set canvas factory: BitmapText.setCanvasFactory(() => new Canvas())\n// - Loading: BitmapText.loadFont(idString) or BitmapText.loadFonts([idStrings])\n// - Query: BitmapText.hasFont(idString), BitmapText.getLoadedFonts()\n//\nclass BitmapText {\n  // ============================================\n  // Static Constants\n  // ============================================\n\n  // Kerning unit divisor (kerning measured in 1/1000 em units)\n  static KERNING_UNIT_DIVISOR = 1000;\n\n  // Minimum renderable font size (sizes < 8.5 use interpolated metrics from 8.5)\n  static MIN_RENDERABLE_SIZE = 8.5;\n\n  // Font asset naming conventions\n  static METRICS_PREFIX = 'metrics-';\n  static ATLAS_PREFIX = 'atlas-';\n  static WEBP_EXTENSION = '.webp';\n  static QOI_EXTENSION = '.qoi';\n  static JS_EXTENSION = '.js';\n\n  // Default text color (matches TextProperties default)\n  static #DEFAULT_TEXT_COLOR = '#000000';\n\n  // Character set constant (204 characters)\n  // Used by both build-time (MetricsMinifier) and runtime (MetricsExpander)\n  // This is the sorted character set that defines the standard order for all font metrics.\n  // ALL font files must contain exactly these 204 characters in this order.\n  static CHARACTER_SET = BitmapText.#generateCharacterSet();\n\n  // ============================================\n  // Static Storage & Configuration\n  // ============================================\n\n  // Font data storage delegated to AtlasDataStore and FontMetricsStore\n  // (no private maps - stores are the single source of truth)\n\n  // Configuration (user overrides, delegates to FontLoader for defaults)\n  // fontDirectory is owned by FontLoader (it's the component that uses it)\n  static #canvasFactory = (typeof document !== 'undefined' ? () => document.createElement('canvas') : null);         // Optional user override\n\n  // Rendering resources (lazy-initialized on first render)\n  static #coloredGlyphCanvas = null;    // Shared scratch canvas for coloring\n  static #coloredGlyphCtx = null;       // 2D context for scratch canvas\n\n  // Font loader (platform-specific, set at runtime)\n  static #fontLoader = null;            // FontLoaderBrowser or FontLoaderNode\n\n  // ============================================\n  // Configuration API (Optional)\n  // ============================================\n\n  /**\n   * Set font directory (overrides default)\n   * Delegates to FontLoader which owns this configuration\n   * @param {string} path - Path to font assets directory\n   */\n  static setFontDirectory(path) {\n    BitmapText.#ensureFontLoader();\n    BitmapText.#fontLoader.setFontDirectory(path);\n  }\n\n  /**\n   * Get font directory (returns override or default)\n   * Delegates to FontLoader which owns this configuration\n   * @returns {string} Font directory path\n   */\n  static getFontDirectory() {\n    BitmapText.#ensureFontLoader();\n    return BitmapText.#fontLoader.getFontDirectory();\n  }\n\n  /**\n   * Override canvas factory (Node.js only, testing, or custom canvas implementations)\n   *\n   * WHY A FACTORY FUNCTION?\n   * HTMLCanvasElement is not constructible in JavaScript - new HTMLCanvasElement()\n   * throws \"Illegal constructor\". Browser uses document.createElement('canvas'),\n   * Node.js requires canvas-mock providing Canvas constructor.\n   *\n   * @param {Function} factory - Function that returns a canvas instance\n   * @example\n   * // Node.js\n   * BitmapText.setCanvasFactory(() => new Canvas());\n   *\n   * // Browser (custom implementation)\n   * BitmapText.setCanvasFactory(() => new OffscreenCanvas(0, 0));\n   */\n  static setCanvasFactory(factory) {\n    BitmapText.#canvasFactory = factory;\n    // Reset canvas to use new factory on next render\n    BitmapText.#coloredGlyphCanvas = null;\n    BitmapText.#coloredGlyphCtx = null;\n  }\n\n  /**\n   * Get canvas factory (with fallback to platform default)\n   *\n   * USAGE PATTERN:\n   * const canvas = BitmapText.getCanvasFactory()();  // Note double invocation\n   *   - First ():  Gets the factory function\n   *   - Second (): Invokes factory to create canvas\n   *\n   * @returns {Function} Canvas factory function\n   */\n  static getCanvasFactory() {\n    return BitmapText.#canvasFactory;\n  }\n\n  /**\n   * Configure multiple options at once\n   * @param {Object} options - Configuration options\n   * @param {string} [options.fontDirectory] - Font assets directory\n   * @param {Function} [options.canvasFactory] - Canvas factory function\n   */\n  static configure(options = {}) {\n    if (options.fontDirectory !== undefined) {\n      BitmapText.setFontDirectory(options.fontDirectory);\n    }\n    if (options.canvasFactory !== undefined) {\n      BitmapText.setCanvasFactory(options.canvasFactory);\n    }\n  }\n\n  /**\n   * Ensure font loader is initialized\n   * @private\n   */\n  static #ensureFontLoader() {\n    if (BitmapText.#fontLoader) {\n      return;\n    }\n\n    // Check if platform-specific FontLoader is available\n    if (typeof FontLoader === 'undefined') {\n      throw new Error(\n        'BitmapText: FontLoader not loaded.\\n' +\n        'Ensure platform-specific FontLoader is included before BitmapText.js:\\n' +\n        '  - Browser: <script src=\"src/platform/FontLoader-browser.js\"></script>\\n' +\n        '  - Node.js: Include src/platform/FontLoader-node.js in bundle'\n      );\n    }\n\n    BitmapText.#fontLoader = FontLoader;\n  }\n\n  /**\n   * Check if font size requires minimum size redirection\n   * @param {number} fontSize - Font size in CSS pixels\n   * @returns {boolean} True if size < 8.5 and should use interpolated metrics\n   * @private\n   */\n  static #shouldUseMinSize(fontSize) {\n    return fontSize < BitmapText.MIN_RENDERABLE_SIZE;\n  }\n\n  /**\n   * Create FontProperties with minimum renderable size (8.5)\n   * @param {FontProperties} fontProperties - Original font properties\n   * @returns {FontProperties} New FontProperties with size 8.5\n   * @private\n   */\n  static #createFontPropsAtMinSize(fontProperties) {\n    return new FontProperties(\n      fontProperties.pixelDensity,\n      fontProperties.fontFamily,\n      fontProperties.fontStyle,\n      fontProperties.fontWeight,\n      BitmapText.MIN_RENDERABLE_SIZE\n    );\n  }\n\n  /**\n   * Create interpolated FontMetrics wrapper for sizes < 8.5\n   * Returns a wrapper object that interpolates all metric values proportionally\n   * @param {FontMetrics} metricsAt8_5 - Font metrics at size 8.5\n   * @param {number} targetSize - Desired font size (< 8.5)\n   * @returns {InterpolatedFontMetrics} Interpolated metrics wrapper with FontMetrics-compatible interface\n   * @private\n   */\n  static #createInterpolatedFontMetrics(metricsAt8_5, targetSize) {\n    return new InterpolatedFontMetrics(metricsAt8_5, targetSize);\n  }\n\n  /**\n   * Redirect idString for sizes < 8.5 to size 8.5\n   * @param {string} idString - Original font ID string\n   * @param {boolean} silent - If true, suppress console warning\n   * @returns {{redirected: boolean, idString: string, originalSize: number}} Redirection result\n   * @private\n   */\n  static #redirectIdStringIfNeeded(idString, silent = false) {\n    const fontProps = FontProperties.fromIDString(idString);\n\n    if (BitmapText.#shouldUseMinSize(fontProps.fontSize)) {\n      const minSizeProps = BitmapText.#createFontPropsAtMinSize(fontProps);\n      if (!silent) {\n        console.warn(\n          `BitmapText: Font size ${fontProps.fontSize}px requested. Redirecting to size ${BitmapText.MIN_RENDERABLE_SIZE}px ` +\n          `(minimum supported size). Sizes < ${BitmapText.MIN_RENDERABLE_SIZE}px render using interpolated placeholder rectangles.`\n        );\n      }\n      return {\n        redirected: true,\n        idString: minSizeProps.idString,\n        originalSize: fontProps.fontSize\n      };\n    }\n\n    return {\n      redirected: false,\n      idString: idString,\n      originalSize: fontProps.fontSize\n    };\n  }\n\n  // ============================================\n  // Registration API (called by asset files)\n  // ============================================\n\n  /**\n   * Convert registration parameters to ID string\n   * Shared helper for registerMetrics and registerAtlas\n   * @private\n   * @param {number} density - Pixel density\n   * @param {string} fontFamily - Font family name\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric)\n   * @param {number} size - Font size\n   * @returns {string} ID string (e.g., \"density-1-0-Arial-style-normal-weight-normal-size-19-0\")\n   */\n  static #parametersToIDString(density, fontFamily, styleIdx, weightIdx, size) {\n    // Decompress style and weight indices\n    const style = styleIdx === 0 ? 'normal' : (styleIdx === 1 ? 'italic' : 'oblique');\n    const weight = weightIdx === 0 ? 'normal' : (weightIdx === 1 ? 'bold' : String(weightIdx));\n\n    // Format density (1 → 1-0, 1.5 → 1-5)\n    const densityStr = String(density);\n    const densityFormatted = densityStr.includes('.') ? densityStr.replace('.', '-') : `${densityStr}-0`;\n\n    // Format size (18 → 18-0, 18.5 → 18-5)\n    const sizeStr = String(size);\n    const sizeFormatted = sizeStr.includes('.') ? sizeStr.replace('.', '-') : `${sizeStr}-0`;\n\n    // Reconstruct full ID\n    return `density-${densityFormatted}-${fontFamily}-style-${style}-weight-${weight}-size-${sizeFormatted}`;\n  }\n\n  /**\n   * Register font metrics from metrics-*.js file\n   * TIER 6c: Multi-parameter format only (no legacy support)\n   *\n   * @param {number} density - Pixel density (e.g., 1 or 1.5)\n   * @param {string} fontFamily - Font family name (e.g., 'Arial')\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric weight)\n   * @param {number} size - Font size (e.g., 18 or 18.5)\n   * @param {Array} compactedData - Tier 6c compacted metrics array\n   */\n  static registerMetrics(density, fontFamily, styleIdx, weightIdx, size, compactedData) {\n    BitmapText.#ensureFontLoader();\n    const fullIDString = BitmapText.#parametersToIDString(density, fontFamily, styleIdx, weightIdx, size);\n    FontLoaderBase.registerMetrics(fullIDString, compactedData, BitmapText);\n  }\n\n  /**\n   * Register atlas from atlas-*.js file (base64 only, positioning reconstructed later)\n   * Delegates to FontLoader which handles platform-specific details\n   * @param {number} density - Pixel density (e.g., 1 or 1.5)\n   * @param {string} fontFamily - Font family name (e.g., 'Arial')\n   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)\n   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric weight)\n   * @param {number} size - Font size (e.g., 18 or 18.5)\n   * @param {string} base64Data - Base64-encoded atlas data\n   */\n  static registerAtlas(density, fontFamily, styleIdx, weightIdx, size, base64Data) {\n    BitmapText.#ensureFontLoader();\n    const fullIDString = BitmapText.#parametersToIDString(density, fontFamily, styleIdx, weightIdx, size);\n    FontLoaderBase.registerAtlas(fullIDString, base64Data);\n  }\n\n  // ============================================\n  // Rendering API\n  // ============================================\n\n  /**\n   * Measure text dimensions\n   *\n   * RETURN VALUES: All measurements are in CSS PIXELS\n   * - width, actualBoundingBox* values are CSS pixels\n   * - Measurements are independent of canvas setup or context transforms\n   * - To convert to physical pixels: multiply by fontProperties.pixelDensity\n   *\n   * NOTE: This method does NOT draw anything and is NOT affected by context transforms.\n   * It purely calculates metrics based on font data.\n   *\n   * The metrics object has the same shape and meaning as the TextMetrics object (see\n   * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics ):\n   * - width: sum of character advancements (minus kerning adjustments)\n   * - actualBoundingBoxLeft: actualBoundingBoxLeft of first character\n   * - actualBoundingBoxRight: sum of advancements (excluding last) + last char's actualBoundingBoxRight\n   *\n   * @param {string} text - Text to measure\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {TextProperties} [textProperties] - Text rendering configuration (optional)\n   * @returns {{metrics: {width: number, actualBoundingBoxLeft: number, actualBoundingBoxRight: number, actualBoundingBoxAscent: number, actualBoundingBoxDescent: number, fontBoundingBoxAscent: number, fontBoundingBoxDescent: number}|null, status: {code: number, missingChars?: Set}}}\n   *   All numeric values in metrics are CSS pixels\n   */\n  static measureText(text, fontProperties, textProperties) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n\n    // FAST PATH: Handle empty text (100% success)\n    if (text.length === 0) {\n      return {\n        metrics: {\n          width: 0,\n          actualBoundingBoxLeft: 0,\n          actualBoundingBoxRight: 0,\n          actualBoundingBoxAscent: 0,\n          actualBoundingBoxDescent: 0,\n          fontBoundingBoxAscent: 0,\n          fontBoundingBoxDescent: 0\n        },\n        status: SUCCESS_STATUS\n      };\n    }\n\n    // Check if FontMetrics exists at all\n    let fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n\n    // If metrics not found and size < 8.5, try interpolating from size 8.5\n    if (!fontMetrics && BitmapText.#shouldUseMinSize(fontProperties.fontSize)) {\n      const minSizeProps = BitmapText.#createFontPropsAtMinSize(fontProperties);\n      const metricsAt8_5 = FontMetricsStore.getFontMetrics(minSizeProps);\n\n      if (metricsAt8_5) {\n        // Create interpolated metrics wrapper\n        fontMetrics = BitmapText.#createInterpolatedFontMetrics(metricsAt8_5, fontProperties.fontSize);\n      } else {\n        // Even 8.5 metrics don't exist\n        return {\n          metrics: null,\n          status: createErrorStatus(StatusCode.NO_METRICS, {\n            requiresMinSize: true,\n            requestedSize: fontProperties.fontSize,\n            minSize: BitmapText.MIN_RENDERABLE_SIZE\n          })\n        };\n      }\n    } else if (!fontMetrics) {\n      return {\n        metrics: null,\n        status: createErrorStatus(StatusCode.NO_METRICS)\n      };\n    }\n\n    // Scan text for missing glyphs (excluding spaces which are handled specially)\n    const missingChars = new Set();\n    for (const char of text) {\n      if (char !== ' ' && !fontMetrics.hasGlyph(char)) {\n        missingChars.add(char);\n      }\n    }\n\n    // If any glyphs missing, can't calculate accurate metrics\n    if (missingChars.size > 0) {\n      return {\n        metrics: null,\n        status: createErrorStatus(StatusCode.PARTIAL_METRICS, {\n          missingChars: missingChars\n        })\n      };\n    }\n\n    // SUCCESS PATH: Calculate metrics normally\n    const chars = [...text];\n    let width_CssPx = 0;\n    let characterMetrics = fontMetrics.getCharacterMetrics(chars[0]);\n    const actualBoundingBoxLeft_CssPx = characterMetrics.actualBoundingBoxLeft;\n    let actualBoundingBoxAscent = 0;\n    let actualBoundingBoxDescent = 0;\n    let actualBoundingBoxRight_CssPx;\n    let advancement_CssPx = 0;\n\n    for (let i = 0; i < chars.length; i++) {\n      const char = chars[i];\n      const nextChar = chars[i + 1];\n\n      characterMetrics = fontMetrics.getCharacterMetrics(char);\n\n      actualBoundingBoxAscent = Math.max(actualBoundingBoxAscent, characterMetrics.actualBoundingBoxAscent);\n      actualBoundingBoxDescent = Math.min(actualBoundingBoxDescent, characterMetrics.actualBoundingBoxDescent);\n\n      advancement_CssPx = this.calculateAdvancement_CssPx(fontMetrics, fontProperties, char, nextChar, textProperties, characterMetrics);\n      width_CssPx += advancement_CssPx;\n    }\n\n    actualBoundingBoxRight_CssPx = width_CssPx - advancement_CssPx;\n    actualBoundingBoxRight_CssPx += characterMetrics.actualBoundingBoxRight;\n\n    return {\n      metrics: {\n        width: width_CssPx,\n        actualBoundingBoxLeft: actualBoundingBoxLeft_CssPx,\n        actualBoundingBoxRight: actualBoundingBoxRight_CssPx,\n        actualBoundingBoxAscent,\n        actualBoundingBoxDescent,\n        fontBoundingBoxAscent: characterMetrics.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: characterMetrics.fontBoundingBoxDescent\n      },\n      status: SUCCESS_STATUS\n    };\n  }\n\n  /**\n   * Draw text using pre-rendered glyphs from atlas\n   *\n   * COORDINATE SYSTEM:\n   * - All coordinates are in CSS PIXELS relative to canvas origin (0,0)\n   * - BitmapText IGNORES all context transforms (scale, translate, rotate, etc.)\n   * - Internal conversion: physicalPixels = cssPixels × fontProperties.pixelDensity\n   * - Transform is reset to identity during rendering, then restored\n   *\n   * TRANSFORM BEHAVIOR:\n   * BitmapText will reset the context transform to identity before drawing,\n   * meaning any ctx.scale(), ctx.translate(), ctx.rotate(), etc. are IGNORED.\n   * This ensures pixel-perfect rendering at exact physical pixel positions.\n   *\n   * Example:\n   *   ctx.scale(2, 2);          // User scales context\n   *   ctx.translate(100, 50);    // User translates\n   *   BitmapText.drawTextFromAtlas(ctx, \"Hello\", 10, 30, fontProps);\n   *   // Text renders at (10, 30) CSS pixels from origin, NOT (120, 80)!\n   *   // Transforms are ignored - coordinates are always absolute\n   *\n   * PIXEL DENSITY:\n   * - Specified via fontProperties.pixelDensity (e.g., window.devicePixelRatio)\n   * - Canvas should be sized: canvas.width = cssWidth × pixelDensity\n   * - Do NOT use ctx.scale(dpr, dpr) - BitmapText handles density internally\n   *\n   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context (transform will be temporarily reset)\n   * @param {string} text - Text to render\n   * @param {number} x_CssPx - X position in CSS pixels (absolute, from canvas origin)\n   * @param {number} y_CssPx - Y position in CSS pixels (absolute, from canvas origin, bottom baseline)\n   * @param {FontProperties} fontProperties - Font configuration (including pixelDensity)\n   * @param {TextProperties} [textProperties] - Text rendering configuration (optional)\n   * @returns {{rendered: boolean, status: {code: number, missingChars?: Set, missingAtlasChars?: Set, placeholdersUsed?: boolean}}}\n   *   Rendering result and status information\n   */\n  static drawTextFromAtlas(ctx, text, x_CssPx, y_CssPx, fontProperties, textProperties = null) {\n    textProperties = textProperties || new TextProperties();\n\n    // Lazy-initialize canvas on first render\n    if (!BitmapText.#coloredGlyphCanvas) {\n      // Explicit factory invocation: get factory, then call it\n      BitmapText.#coloredGlyphCanvas = BitmapText.getCanvasFactory()();\n      BitmapText.#coloredGlyphCtx = BitmapText.#coloredGlyphCanvas.getContext('2d');\n    }\n\n    // Check FontMetrics availability first\n    let fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n    let forceInvalidAtlas = false;\n\n    // For sizes < 8.5, always use interpolated metrics from 8.5 and force placeholder mode\n    if (BitmapText.#shouldUseMinSize(fontProperties.fontSize)) {\n      const minSizeProps = BitmapText.#createFontPropsAtMinSize(fontProperties);\n      const metricsAt8_5 = FontMetricsStore.getFontMetrics(minSizeProps);\n\n      if (!metricsAt8_5) {\n        // Size 8.5 metrics don't exist - can't render\n        return {\n          rendered: false,\n          status: createErrorStatus(StatusCode.NO_METRICS, {\n            requiresMinSize: true,\n            requestedSize: fontProperties.fontSize,\n            minSize: BitmapText.MIN_RENDERABLE_SIZE\n          })\n        };\n      }\n\n      // Create interpolated metrics wrapper and force placeholder mode\n      fontMetrics = BitmapText.#createInterpolatedFontMetrics(metricsAt8_5, fontProperties.fontSize);\n      forceInvalidAtlas = true; // Always use placeholders for sizes < 8.5\n    } else if (!fontMetrics) {\n      // Normal size but metrics not found\n      return {\n        rendered: false,\n        status: createErrorStatus(StatusCode.NO_METRICS)\n      };\n    }\n\n    // Scan for missing metrics (can't render without metrics)\n    const missingMetricsChars = new Set();\n    for (const char of text) {\n      if (char !== ' ' && !fontMetrics.hasGlyph(char)) {\n        missingMetricsChars.add(char);\n      }\n    }\n\n    if (missingMetricsChars.size > 0) {\n      return {\n        rendered: false,\n        status: createErrorStatus(StatusCode.PARTIAL_METRICS, {\n          missingChars: missingMetricsChars\n        })\n      };\n    }\n\n    // Check atlas data availability (force invalid for sizes < 8.5)\n    let atlasData = forceInvalidAtlas ? null : AtlasDataStore.getAtlasData(fontProperties);\n    const atlasValid = forceInvalidAtlas ? false : BitmapText.#isValidAtlas(atlasData);\n\n    // Track which glyphs are missing from atlas (for partial atlas status)\n    const missingAtlasChars = new Set();\n    let placeholdersUsed = false;\n\n    // CRITICAL: Reset transform to identity for pixel-perfect physical rendering\n    // BitmapText ignores ALL context transforms (scale, translate, rotate, etc.)\n    // Coordinates are ALWAYS relative to canvas origin (0,0)\n    // This ensures:\n    // 1. Predictable positioning regardless of context state\n    // 2. Pixel-perfect rendering at physical pixel boundaries\n    // 3. No double-scaling when users apply ctx.scale(dpr, dpr)\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);  // Reset to identity matrix\n\n    // Render text\n    const chars = [...text];\n    const textColor = textProperties.textColor;\n\n    // BASELINE SUPPORT: Convert user's y from their chosen baseline to 'bottom' baseline\n    // Get baseline data from first character (baseline values are identical for all characters in a font)\n    // Use first actual character, or fallback to space character for baseline calculation\n    const firstChar = chars.find(c => fontMetrics.hasGlyph(c)) || chars[0];\n    const characterMetricsForBaseline = fontMetrics.getCharacterMetrics(firstChar);\n    const baselineOffset_CssPx = characterMetricsForBaseline\n      ? BitmapText.#calculateBaselineOffsetToBottom(textProperties.textBaseline, characterMetricsForBaseline)\n      : 0;\n\n    // ALIGNMENT SUPPORT: Convert user's x from their chosen alignment to 'left' alignment\n    // Measure text width to calculate alignment offset (measureText accounts for kerning if enabled)\n    let alignmentOffset_CssPx = 0;\n    if (textProperties.textAlign !== 'left') {\n      const measureResult = BitmapText.measureText(text, fontProperties, textProperties);\n      if (measureResult.status.code === 0 && measureResult.metrics) {\n        // Successfully measured text - calculate alignment offset\n        alignmentOffset_CssPx = BitmapText.#calculateAlignmentOffsetToLeft(\n          textProperties.textAlign,\n          measureResult.metrics.width\n        );\n      } else {\n        // Failed to measure (missing glyphs, etc.) - default to left alignment (offset = 0)\n        // Text will still render but won't be aligned as requested\n        console.warn(`BitmapText: Failed to measure text for alignment '${textProperties.textAlign}', defaulting to left alignment`);\n      }\n    }\n\n    // Apply baseline and alignment offsets, then convert to physical pixels\n    const position_PhysPx = {\n      x: (x_CssPx + alignmentOffset_CssPx) * fontProperties.pixelDensity,\n      y: (y_CssPx + baselineOffset_CssPx) * fontProperties.pixelDensity\n    };\n\n    // OPTIMIZATION: Batch colored text rendering (single composite operation)\n    // Check if we're rendering colored text with a valid atlas\n    const isColoredText = textColor !== BitmapText.#DEFAULT_TEXT_COLOR;\n    if (isColoredText && atlasValid) {\n      // Use optimized batch rendering for colored text\n      // This reduces composite operations from N (per character) to 1 (per text string)\n      const batchResult = BitmapText.#drawColoredTextBatched(\n        ctx, text, chars, position_PhysPx, atlasData, fontMetrics, fontProperties, textProperties\n      );\n\n      // Merge batch results into tracking sets\n      batchResult.missingAtlasChars.forEach(char => missingAtlasChars.add(char));\n      placeholdersUsed = placeholdersUsed || batchResult.placeholdersUsed;\n\n      // Skip character-by-character loop for colored text\n    } else {\n      // Black text or invalid atlas: use character-by-character rendering\n      for (let i = 0; i < chars.length; i++) {\n        const currentChar = chars[i];\n        const nextChar = chars[i + 1];\n\n        // Check if atlas has a glyph for this character (excluding spaces)\n        if (currentChar !== ' ') {\n          if (!atlasValid || !atlasData.hasPositioning(currentChar)) {\n            missingAtlasChars.add(currentChar);\n            placeholdersUsed = true;\n          }\n        }\n\n        // Draw (either real glyph or placeholder)\n        BitmapText.#drawCharacter(ctx,\n          currentChar,\n          position_PhysPx,\n          atlasData,\n          fontMetrics,\n          textColor\n        );\n\n        position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties);\n      }\n    }\n\n    // Determine status code\n    let statusCode;\n    if (!atlasValid) {\n      statusCode = StatusCode.NO_ATLAS;\n    } else if (missingAtlasChars.size > 0) {\n      statusCode = StatusCode.PARTIAL_ATLAS;\n    } else {\n      // Complete success\n      ctx.restore();  // Restore original transform\n      return {\n        rendered: true,\n        status: SUCCESS_STATUS\n      };\n    }\n\n    // Return detailed status for non-success cases\n    ctx.restore();  // Restore original transform\n    return {\n      rendered: true,\n      status: createErrorStatus(statusCode, {\n        missingAtlasChars: missingAtlasChars.size > 0 ? missingAtlasChars : undefined,\n        placeholdersUsed: placeholdersUsed\n      })\n    };\n  }\n\n  // ============================================\n  // Internal Rendering Helpers\n  // ============================================\n  // Get the advancement of the i-th character i.e. needed AFTER the i-th character\n  // so that the i+1-th character is drawn at the right place\n  // This depends on both the advancement specified by the glyph of the i-th character\n  // AND by the kerning correction depending on the pair of the i-th and i+1-th characters\n\n  static calculateAdvancement_CssPx(fontMetrics, fontProperties, char, nextChar, textProperties, characterMetrics = null) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n    if (!characterMetrics) {\n      characterMetrics = fontMetrics.getCharacterMetrics(char);\n    }\n    let x_CssPx = 0;\n\n    // LIMITATION: Only handles standard space (U+0020), not other Unicode space characters\n\n    // Handle space first ------------------------------------------\n    // You could add the space advancement as we got it from the browser\n    // (remember that the space doesn't have the tightCanvasBox)\n    // but since at small sizes we meddle with kerning quite a bit, we want\n    // to also meddle with this to try to make the width of text\n    // similar to what the browser paints normally.\n    // console.log(characterMetrics.width + \" \" + x_CSS_Px);\n    // deal with the size of the \" \" character\n    if (char === \" \") {\n      const spaceAdvancementOverrideForSmallSizesInPx_CssPx = fontMetrics.getSpaceAdvancementOverride();\n      if (spaceAdvancementOverrideForSmallSizesInPx_CssPx !== null) {\n        x_CssPx += spaceAdvancementOverrideForSmallSizesInPx_CssPx;\n      }\n      else {\n        x_CssPx += characterMetrics.width;\n      }\n    }\n    // Non-space characters\n    else {\n      x_CssPx += characterMetrics.width;\n    }\n\n    // Apply kerning correction\n    let kerningCorrection = BitmapText.#getKerningCorrection(fontMetrics, char, nextChar, textProperties);\n\n    // Kerning adjustments are measured in 1/1000 em units (font-size relative).\n    // We convert to pixels by multiplying font size by the kerning correction\n    // and dividing by 1000. This keeps kerning proportional to font size while\n    // maintaining precision in the stored kerning values.\n    x_CssPx -= fontProperties.fontSize * kerningCorrection / BitmapText.KERNING_UNIT_DIVISOR;\n\n    // For interpolated metrics (sizes < 8.5), preserve float precision for linear scaling\n    // For normal metrics (sizes ≥ 8.5), round to integers for crisp pixel-aligned rendering\n    if (fontMetrics.isInterpolatedMetrics) {\n      return x_CssPx;  // Float positioning for placeholder rectangles\n    } else {\n      return Math.round(x_CssPx);  // Integer positioning for crisp atlas glyphs\n    }\n  }\n\n  static #getKerningCorrection(fontMetrics, char, nextChar, textProperties) {\n    if (!textProperties) {\n      textProperties = new TextProperties();\n    }\n\n    if (textProperties.isKerningEnabled && nextChar) {\n      return fontMetrics.getKerningAdjustment(char, nextChar);\n    }\n\n    return 0;\n  }\n\n  /**\n   * Calculate y-offset to convert from specified textBaseline to 'bottom' baseline\n   *\n   * INTERNAL REFERENCE: BitmapText uses 'bottom' baseline for all dy calculations.\n   * All glyph dy offsets are pre-calculated assuming y is at the bottom of the em square.\n   * This method converts user's chosen baseline to that internal reference.\n   *\n   * COORDINATE SYSTEM: y increases downward (Canvas convention)\n   * All baseline distances are in CSS pixels and relative to alphabetic baseline (ab = 0)\n   *\n   * BASELINE GEOMETRY:\n   * - top: At fontBoundingBoxAscent above alphabetic\n   * - hanging: At hangingBaseline above alphabetic (Tibetan, Devanagari)\n   * - middle: At (fontBoundingBoxAscent - fontBoundingBoxDescent) / 2 above alphabetic\n   * - alphabetic: At 0 (reference point for Latin scripts)\n   * - ideographic: At ideographicBaseline below alphabetic (CJK scripts, negative value)\n   * - bottom: At fontBoundingBoxDescent below alphabetic\n   *\n   * @private\n   * @param {string} textBaseline - User's chosen baseline ('top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom')\n   * @param {Object} characterMetrics - Metrics containing baseline data (fba, fbd, hb, ab, ib)\n   * @returns {number} Offset in CSS pixels to add to y coordinate to reach 'bottom' baseline\n   */\n  static #calculateBaselineOffsetToBottom(textBaseline, characterMetrics) {\n    // Extract baseline measurements from character metrics\n    // These values are captured from browser's TextMetrics during font generation\n    const fba = characterMetrics.fontBoundingBoxAscent;    // Distance from alphabetic to top of em square (positive)\n    const fbd = characterMetrics.fontBoundingBoxDescent;   // Distance from alphabetic to bottom of em square (positive, downward)\n    const hb = characterMetrics.hangingBaseline;           // Distance from alphabetic to hanging baseline (positive, upward)\n    const ib = characterMetrics.ideographicBaseline;       // Distance from alphabetic to ideographic baseline (negative, downward)\n\n    // Convert from user's baseline to bottom baseline\n    // Formulas derived from geometric relationships in em square coordinate system\n    switch (textBaseline) {\n      case 'top':\n        // Top of em square → Bottom of em square\n        // Move down by full em height: ascent + descent\n        return fba + fbd;\n\n      case 'hanging':\n        // Hanging baseline → Bottom of em square\n        // Hanging is hb above alphabetic, bottom is fbd below alphabetic\n        // Total distance: hb (up to alphabetic) + fbd (down to bottom)\n        return hb + fbd;\n\n      case 'middle':\n        // Middle of em square → Bottom of em square\n        // Middle is halfway between top and bottom\n        // Distance from middle to bottom: (ascent + descent) / 2\n        return (fba + fbd) / 2;\n\n      case 'alphabetic':\n        // Alphabetic baseline → Bottom of em square\n        // Alphabetic is fbd above bottom (standard for Latin text)\n        return fbd;\n\n      case 'ideographic':\n        // Ideographic baseline → Bottom of em square\n        // Ideographic is ib pixels relative to alphabetic (negative = below alphabetic)\n        // Distance from ideographic to bottom: fbd + ib\n        // Example: if fbd=4 and ib=-4.0264, offset = 4 + (-4.0264) = -0.0264\n        // This small negative offset places ideographic just above bottom, matching native Canvas\n        return fbd + ib;\n\n      case 'bottom':\n        // Already at bottom baseline - no offset needed\n        return 0;\n\n      default:\n        // Unknown baseline value - warn and default to bottom\n        console.warn(`BitmapText: Unknown textBaseline '${textBaseline}', defaulting to 'bottom'. Valid values: top, hanging, middle, alphabetic, ideographic, bottom`);\n        return 0;\n    }\n  }\n\n  /**\n   * Calculate x-offset to convert from specified textAlign to 'left' alignment\n   *\n   * INTERNAL REFERENCE: BitmapText uses 'left' alignment for internal rendering.\n   * All text rendering starts from the x-coordinate and advances rightward.\n   * This method converts user's chosen alignment to that internal reference.\n   *\n   * COORDINATE SYSTEM: x increases rightward (Canvas convention)\n   * All measurements are in CSS pixels\n   *\n   * ALIGNMENT GEOMETRY:\n   * - left: x marks the start of the text (no offset needed)\n   * - center: x marks the center of the text (offset by -width/2)\n   * - right: x marks the end of the text (offset by -width)\n   *\n   * @private\n   * @param {string} textAlign - User's chosen alignment ('left', 'center', 'right')\n   * @param {number} textWidth_CssPx - Total width of the text in CSS pixels\n   * @returns {number} Offset in CSS pixels to add to x coordinate to reach 'left' alignment\n   */\n  static #calculateAlignmentOffsetToLeft(textAlign, textWidth_CssPx) {\n    // Convert from user's alignment to left alignment (internal reference)\n    switch (textAlign) {\n      case 'left':\n        // Already at left alignment - no offset needed\n        return 0;\n\n      case 'center':\n        // Center alignment → Left alignment\n        // Text is centered at x, need to shift left by half width to get start position\n        return -textWidth_CssPx / 2;\n\n      case 'right':\n        // Right alignment → Left alignment\n        // Text ends at x, need to shift left by full width to get start position\n        return -textWidth_CssPx;\n\n      default:\n        // Unknown alignment value - warn and default to left\n        console.warn(`BitmapText: Unknown textAlign '${textAlign}', defaulting to 'left'. Valid values: left, center, right`);\n        return 0;\n    }\n  }\n\n  /**\n   * Draw colored text using optimized batch rendering\n   *\n   * OPTIMIZATION: Instead of switching composite operations for EACH character:\n   * 1. Measure total text extent ONCE\n   * 2. Draw ALL glyphs to one scratch canvas (in original black form)\n   * 3. Apply color transformation ONCE using composite operation\n   * 4. Copy entire colored text block to main canvas ONCE\n   *\n   * This reduces expensive composite operation switches from N (per character) to 1 (per text string)\n   * Expected performance improvement: 2-5x faster for colored text rendering\n   *\n   * @private\n   * @param {CanvasRenderingContext2D} ctx - Main canvas context\n   * @param {string} text - Full text string to render\n   * @param {Array<string>} chars - Text split into characters\n   * @param {Object} startPosition_PhysPx - Starting position in physical pixels {x, y}\n   * @param {AtlasData} atlasData - Atlas data containing glyphs\n   * @param {FontMetrics} fontMetrics - Font metrics for measurements\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {TextProperties} textProperties - Text rendering configuration\n   * @returns {{missingAtlasChars: Set, placeholdersUsed: boolean}} Status information\n   */\n  static #drawColoredTextBatched(ctx, text, chars, startPosition_PhysPx, atlasData, fontMetrics, fontProperties, textProperties) {\n    const missingAtlasChars = new Set();\n    let placeholdersUsed = false;\n\n    // Step 1: Measure text to determine bounding box for scratch canvas\n    const measureResult = BitmapText.measureText(text, fontProperties, textProperties);\n    if (measureResult.status.code !== 0 || !measureResult.metrics) {\n      // Cannot measure - fallback to character-by-character rendering\n      console.warn('BitmapText: Batch rendering failed (cannot measure text), falling back to per-character rendering');\n      return { missingAtlasChars, placeholdersUsed };\n    }\n\n    const metrics = measureResult.metrics;\n\n    // Calculate scratch canvas dimensions in physical pixels\n    // CRITICAL: Use FONT bounding box (not actual text bounding box)\n    // This ensures we have room for ALL characters in the font, not just those in this text\n    // Example: \"hello\" has small actualBoundingBoxAscent (x-height only)\n    //          but we need room for \"HELLO\" (cap-height) when rendering any text\n    //\n    // CRITICAL: Calculate VISUAL width (actual pixel span) not typographic width (advancement)\n    //\n    // Canvas API Semantics:\n    // - metrics.width = sum of character advancements (includes kerning, represents \"cursor advancement\")\n    // - metrics.actualBoundingBoxLeft = distance from text start to leftmost pixel\n    // - metrics.actualBoundingBoxRight = distance from text start to rightmost pixel\n    // - Visual width = actualBoundingBoxLeft + actualBoundingBoxRight (actual pixels occupied)\n    //\n    // WIDTH DIMENSION ROUNDING: Use Math.ceil on physical pixels for visual width\n    // Canvas width must accommodate all pixels including those at fractional positions.\n    // Math.ceil ensures glyphs drawing at rounded-up positions won't be clipped.\n    // Example: visualWidth=24.4 → Math.ceil(24.4)=25 → canvas [0-24] → glyph at px 24 fits ✓\n    const visualWidth_CssPx = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n    const textWidth_PhysPx = Math.ceil(visualWidth_CssPx * fontProperties.pixelDensity);\n\n    // HEIGHT DIMENSION ROUNDING: MUST match GlyphFAB.js calculation EXACTLY\n    // CRITICAL: GlyphFAB.js (lines 247-252) uses Math.round on CSS pixels, then multiplies by pixelDensity\n    // The dy offsets in atlas were calculated based on THIS EXACT canvas height\n    const fontBoundingBoxHeight_CssPx = Math.round(\n      metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent\n    );\n    const textHeight_PhysPx = fontBoundingBoxHeight_CssPx * fontProperties.pixelDensity;\n\n    // Pre-round position offset values for consistent positioning throughout\n    // CRITICAL: These values are used both for positioning glyphs inside scratch canvas\n    // and for positioning the final scratch canvas copy to main canvas\n    // Using the SAME rounded values prevents 1-pixel misalignment from float rounding discrepancies\n    const actualBoundingBoxLeft_PhysPx = Math.round(metrics.actualBoundingBoxLeft * fontProperties.pixelDensity);\n\n    // CRITICAL: Baseline position must match GlyphFAB.js (GlyphFAB.js:288)\n    // GlyphFAB positions baseline at \"canvas.height / pixelDensity - 1\" in CSS pixels\n    // In physical pixels: baseline_y = canvas.height - pixelDensity\n    // The dy offsets in atlas are calculated relative to THIS baseline position\n    // Missing this offset causes descender clipping (bottom row of j, y, g, p, q cut off)\n    const baselineY_PhysPx = textHeight_PhysPx - fontProperties.pixelDensity;\n\n    // Safety check: ensure dimensions are reasonable\n    if (textWidth_PhysPx <= 0 || textHeight_PhysPx <= 0 || textWidth_PhysPx > 32000 || textHeight_PhysPx > 32000) {\n      console.warn(`BitmapText: Invalid scratch canvas dimensions (${textWidth_PhysPx}x${textHeight_PhysPx}), falling back`);\n      return { missingAtlasChars, placeholdersUsed };\n    }\n\n    // Step 2: Setup scratch canvas sized for entire text block\n    BitmapText.#coloredGlyphCanvas.width = textWidth_PhysPx;\n    BitmapText.#coloredGlyphCanvas.height = textHeight_PhysPx;\n    BitmapText.#coloredGlyphCtx.clearRect(0, 0, textWidth_PhysPx, textHeight_PhysPx);\n\n    // Step 3: Draw ALL glyphs to scratch canvas in their original black form\n    // Position relative to scratch canvas origin (not main canvas)\n    const position_PhysPx = {\n      // Horizontal: Start at actualBoundingBoxLeft to account for glyphs that protrude left (e.g., italic 'f')\n      // CRITICAL: Use pre-rounded value (line 950) for consistency with final copy (line 1017+)\n      x: actualBoundingBoxLeft_PhysPx,\n      // Vertical: Position baseline to match GlyphFAB.js rendering (GlyphFAB.js:288)\n      // Baseline is at \"canvas.height / pixelDensity - 1\" in CSS pixels\n      // which equals \"canvas.height - pixelDensity\" in physical pixels\n      // NOT at canvas bottom, but one pixel-row above it\n      // Glyphs draw upward/downward from here using their dy offsets from atlas\n      // CRITICAL: Must match glyph building baseline or dy offsets will be wrong (descenders clip)\n      y: baselineY_PhysPx\n    };\n\n    for (let i = 0; i < chars.length; i++) {\n      const currentChar = chars[i];\n      const nextChar = chars[i + 1];\n\n      // Track missing characters\n      if (currentChar !== ' ' && !atlasData.hasPositioning(currentChar)) {\n        missingAtlasChars.add(currentChar);\n        placeholdersUsed = true;\n        // Advance position even for missing characters to maintain layout\n        position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(\n          fontMetrics, fontProperties, currentChar, nextChar, textProperties\n        );\n        continue;\n      }\n\n      // Draw glyph to scratch canvas (skip spaces, they have no visual)\n      if (currentChar !== ' ' && atlasData.hasPositioning(currentChar)) {\n        const atlasPositioning = atlasData.atlasPositioning.getPositioning(currentChar);\n        const atlasImage = atlasData.atlasImage.image;\n        const { xInAtlas, tightWidth, tightHeight, dx, dy } = atlasPositioning;\n\n        // Draw original glyph (black) to scratch canvas at correct position\n        BitmapText.#coloredGlyphCtx.drawImage(\n          atlasImage,\n          xInAtlas, 0,\n          tightWidth, tightHeight,\n          Math.round(position_PhysPx.x + dx),\n          Math.round(position_PhysPx.y + dy),\n          tightWidth, tightHeight\n        );\n      }\n\n      // Advance position for next character\n      position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(\n        fontMetrics, fontProperties, currentChar, nextChar, textProperties\n      );\n    }\n\n    // Step 4: Apply color transformation ONCE to entire text\n    // This is the key optimization - only ONE composite operation instead of N\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-in';\n    BitmapText.#coloredGlyphCtx.fillStyle = textProperties.textColor;\n    BitmapText.#coloredGlyphCtx.fillRect(0, 0, textWidth_PhysPx, textHeight_PhysPx);\n\n    // Reset composite operation for future use\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-over';\n\n    // Step 5: Copy entire colored text block to main canvas ONCE\n    // POSITIONING GEOMETRY:\n    // - Main canvas: startPosition_PhysPx.y is at the bottom baseline (textBaseline='bottom')\n    // - Scratch canvas: baseline is at y = baselineY_PhysPx (textHeight - pixelDensity, NOT at canvas bottom)\n    // - To align baselines: scratch canvas top = startPosition_PhysPx.y - baselineY_PhysPx\n    // - Horizontal: account for actualBoundingBoxLeft offset (glyphs that protrude left)\n    // CRITICAL: Use baselineY_PhysPx (line 957) not textHeight_PhysPx to account for baseline offset\n    ctx.drawImage(\n      BitmapText.#coloredGlyphCanvas,\n      0, 0,\n      textWidth_PhysPx, textHeight_PhysPx,\n      Math.round(startPosition_PhysPx.x) - actualBoundingBoxLeft_PhysPx,\n      Math.round(startPosition_PhysPx.y) - baselineY_PhysPx,\n      textWidth_PhysPx, textHeight_PhysPx\n    );\n\n    return { missingAtlasChars, placeholdersUsed };\n  }\n\n  // Rendering optimizations:\n  // 1. ✓ IMPLEMENTED: Black text fast path (see #drawCharacterDirect for 2-3x speedup)\n  // 2. ✓ IMPLEMENTED: Batch colored text rendering (single composite operation per text string)\n  // 3. FUTURE: Cache colored glyphs in LRU cache to avoid re-coloring same characters\n  static #drawCharacter(ctx, char, position_PhysPx, atlasData, fontMetrics, textColor) {\n    // If atlasData is missing but metrics exist, draw simplified placeholder rectangle\n    if (!BitmapText.#isValidAtlas(atlasData)) {\n      const characterMetrics = fontMetrics.getCharacterMetrics(char);\n      if (characterMetrics) {\n        BitmapText.#drawPlaceholderRectangle(ctx, char, position_PhysPx, characterMetrics, textColor);\n      }\n      return;\n    }\n\n    // FAST PATH: Black text renders directly from atlas (2-3x faster)\n    // Skips scratch canvas + composite operations when using default color\n    if (textColor === BitmapText.#DEFAULT_TEXT_COLOR) {\n      BitmapText.#drawCharacterDirect(ctx, char, position_PhysPx, atlasData, fontMetrics);\n      return;\n    }\n\n    // NOTE: Colored text now uses batch rendering in drawTextFromAtlas\n    // This method is kept for compatibility/fallback but should rarely be called for colored text\n    // SLOW PATH: Colored text requires double-pass rendering\n    // 1. Copy glyph from atlas to scratch canvas\n    // 2. Apply color using composite operation\n    // 3. Draw colored glyph to main canvas\n    if (!atlasData.hasPositioning(char)) return;\n\n    const atlasPositioning = atlasData.atlasPositioning.getPositioning(char);\n    const atlasImage = atlasData.atlasImage.image;\n    const coloredGlyphCanvas = BitmapText.#createColoredGlyph(atlasImage, atlasPositioning, textColor);\n    BitmapText.#renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position_PhysPx, atlasPositioning);\n  }\n\n  static #createColoredGlyph(atlasImage, atlasPositioning, textColor) {\n    const { xInAtlas, tightWidth, tightHeight } = atlasPositioning;\n\n    // Setup temporary canvas, same size as the glyph\n    BitmapText.#coloredGlyphCanvas.width = tightWidth;\n    BitmapText.#coloredGlyphCanvas.height = tightHeight;\n    BitmapText.#coloredGlyphCtx.clearRect(0, 0, tightWidth, tightHeight);\n\n    // Draw original glyph\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-over';\n    BitmapText.#coloredGlyphCtx.drawImage(\n      atlasImage,\n      xInAtlas, 0,\n      tightWidth, tightHeight,\n      0, 0,\n      tightWidth, tightHeight\n    );\n\n    // Apply color\n    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-in';\n    BitmapText.#coloredGlyphCtx.fillStyle = textColor;\n    BitmapText.#coloredGlyphCtx.fillRect(0, 0, tightWidth, tightHeight);\n\n    return BitmapText.#coloredGlyphCanvas;\n  }\n\n  static #renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position_PhysPx, atlasPositioning) {\n    const { tightWidth, tightHeight, dx, dy } = atlasPositioning;\n\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    // see https://stackoverflow.com/a/6061102\n    ctx.drawImage(\n      coloredGlyphCanvas,\n      0, 0,\n      tightWidth, tightHeight,\n      Math.round(position_PhysPx.x + dx),\n      Math.round(position_PhysPx.y + dy),\n      tightWidth, tightHeight\n    );\n  }\n\n  /**\n   * Fast path: Draw character directly from atlas (black text only)\n   * Skips scratch canvas and color composite operations for 2-3x faster rendering\n   * @private\n   */\n  static #drawCharacterDirect(ctx, char, position_PhysPx, atlasData, fontMetrics) {\n    if (!atlasData.hasPositioning(char)) return;\n\n    const atlasPositioning = atlasData.atlasPositioning.getPositioning(char);\n    const atlasImage = atlasData.atlasImage.image;\n    const { xInAtlas, tightWidth, tightHeight, dx, dy } = atlasPositioning;\n\n    // Single drawImage operation: atlas → main canvas\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    ctx.drawImage(\n      atlasImage,\n      xInAtlas, 0,\n      tightWidth, tightHeight,\n      Math.round(position_PhysPx.x + dx),\n      Math.round(position_PhysPx.y + dy),\n      tightWidth, tightHeight\n    );\n  }\n\n  static #drawPlaceholderRectangle(ctx, char, position_PhysPx, characterMetrics, textColor) {\n    if (char === ' ') return;\n\n    if (characterMetrics.actualBoundingBoxLeft === undefined ||\n        characterMetrics.actualBoundingBoxRight === undefined ||\n        characterMetrics.actualBoundingBoxAscent === undefined ||\n        characterMetrics.actualBoundingBoxDescent === undefined) {\n      console.warn(`Missing bounding box metrics for character '${char}'`);\n      return;\n    }\n\n    const pixelDensity = characterMetrics.pixelDensity || 1;\n\n    // Use CHARACTER-SPECIFIC actual bounding box (not font-wide fontBoundingBox)\n    // This makes:\n    // - 'a' shorter than 'A' (x-height vs cap-height)\n    // - 'g' extends below baseline (shows descender)\n    // - '.' very short (near baseline only)\n    // Width: actualBoundingBoxLeft + actualBoundingBoxRight (CSS px) * pixelDensity → physical px\n    // Height: actualBoundingBoxAscent + actualBoundingBoxDescent (CSS px) * pixelDensity → physical px\n    const width_PhysPx = Math.round(\n      characterMetrics.actualBoundingBoxLeft + characterMetrics.actualBoundingBoxRight\n    ) * pixelDensity;\n\n\n    const height_PhysPx = Math.round(\n      characterMetrics.actualBoundingBoxAscent + characterMetrics.actualBoundingBoxDescent\n    ) * pixelDensity;\n\n    // X position: Account for actualBoundingBoxLeft (glyphs may protrude left, e.g., italic 'f')\n    // This matches the dx offset calculation in atlas rendering (AtlasPositioningFAB.js:92)\n    const rectX_PhysPx = position_PhysPx.x\n      - Math.round(characterMetrics.actualBoundingBoxLeft) * pixelDensity;\n\n    // Y position calculation:\n    // - position_PhysPx.y is at em square BOTTOM (textBaseline='bottom')\n    // - Em square bottom is fontBoundingBoxDescent below the alphabetic baseline\n    // - So: alphabetic_baseline_y = position_PhysPx.y - fontBoundingBoxDescent * pixelDensity\n    // - Character top = alphabetic_baseline_y - actualBoundingBoxAscent * pixelDensity\n    // Result: rectY = position_PhysPx.y - fontBoundingBoxDescent * pixelDensity - actualBoundingBoxAscent * pixelDensity\n    const rectY_PhysPx = position_PhysPx.y\n      - characterMetrics.fontBoundingBoxDescent * pixelDensity\n      - characterMetrics.actualBoundingBoxAscent * pixelDensity;\n\n    const actualColor = textColor || 'black';\n\n    // Draw character-specific rectangle\n    // Round coordinates at draw stage for crisp, pixel-aligned rendering\n    // Position tracking uses floats to avoid accumulation errors, but final\n    // draw coordinates must be integers to prevent subpixel antialiasing\n    ctx.fillStyle = actualColor;\n    ctx.fillRect(\n      Math.round(rectX_PhysPx),\n      Math.round(rectY_PhysPx),\n      Math.round(width_PhysPx),\n      Math.round(height_PhysPx)\n    );\n  }\n\n  static #calculateCharacterAdvancement_PhysPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties) {\n    return this.calculateAdvancement_CssPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties)\n      * fontProperties.pixelDensity;\n  }\n\n  /**\n   * Check if atlas data is valid and ready for rendering\n   * @private\n   * @param {*} atlasData - Potential AtlasData instance\n   * @returns {boolean} True if atlasData is an AtlasData instance and is valid\n   */\n  static #isValidAtlas(atlasData) {\n    if (!(atlasData instanceof AtlasData)) {\n      return false;\n    }\n    return atlasData.isValid();\n  }\n\n  // ============================================\n  // Loading API (Delegates to FontLoader)\n  // ============================================\n\n  /**\n   * Load a single font\n   * @param {string} idString - Font ID string\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @returns {Promise} Resolves when font is loaded\n   */\n  static async loadFont(idString, options = {}) {\n    BitmapText.#ensureFontLoader();\n    // Redirect sizes < 8.5 to size 8.5\n    const redirection = BitmapText.#redirectIdStringIfNeeded(idString);\n    return BitmapText.#fontLoader.loadFont(redirection.idString, options, BitmapText);\n  }\n\n  /**\n   * Load multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {boolean} [options.loadMetrics] - Load metrics (default: true)\n   * @param {boolean} [options.loadAtlases] - Load atlases (default: true)\n   * @returns {Promise} Resolves when all fonts are loaded\n   */\n  static async loadFonts(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    // Redirect sizes < 8.5 to size 8.5 for all idStrings\n    const redirectedIdStrings = idStrings.map(idString => {\n      const redirection = BitmapText.#redirectIdStringIfNeeded(idString);\n      return redirection.idString;\n    });\n    return BitmapText.#fontLoader.loadFonts(redirectedIdStrings, options, BitmapText);\n  }\n\n  /**\n   * Load only metrics for fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetrics(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    // Redirect sizes < 8.5 to size 8.5 for all idStrings\n    const redirectedIdStrings = idStrings.map(idString => {\n      const redirection = BitmapText.#redirectIdStringIfNeeded(idString);\n      return redirection.idString;\n    });\n    return BitmapText.#fontLoader.loadMetrics(redirectedIdStrings, options, BitmapText);\n  }\n\n  /**\n   * Load only atlases for fonts (metrics must be loaded first)\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @returns {Promise} Resolves when atlases are loaded\n   */\n  static async loadAtlases(idStrings, options = {}) {\n    BitmapText.#ensureFontLoader();\n    // Redirect sizes < 8.5 to size 8.5 for all idStrings\n    const redirectedIdStrings = idStrings.map(idString => {\n      const redirection = BitmapText.#redirectIdStringIfNeeded(idString);\n      return redirection.idString;\n    });\n    return BitmapText.#fontLoader.loadAtlases(redirectedIdStrings, options, BitmapText);\n  }\n\n  // ============================================\n  // Builder/Testing Tool API\n  // ============================================\n\n  /**\n   * Set atlas data for a font (for builder/testing tools)\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {AtlasData} atlasData - Atlas data to store\n   */\n  static setAtlasData(fontProperties, atlasData) {\n    AtlasDataStore.setAtlasData(fontProperties, atlasData);\n  }\n\n  /**\n   * Get atlas data for a font\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {AtlasData|undefined} Atlas data or undefined if not found\n   */\n  static getAtlasData(fontProperties) {\n    return AtlasDataStore.getAtlasData(fontProperties);\n  }\n\n  /**\n   * Delete atlas data for a font\n   * Public API - delegates to AtlasDataStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if atlas was deleted\n   */\n  static deleteAtlas(fontProperties) {\n    return AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Set font metrics for a font (for builder/testing tools)\n   * Public API - delegates to FontMetricsStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {FontMetrics} fontMetrics - Font metrics to store\n   */\n  static setFontMetrics(fontProperties, fontMetrics) {\n    FontMetricsStore.setFontMetrics(fontProperties, fontMetrics);\n  }\n\n  /**\n   * Get font metrics for a font\n   * Public API - delegates to FontMetricsStore\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {FontMetrics|undefined} Font metrics or undefined if not found\n   */\n  static getFontMetrics(fontProperties) {\n    return FontMetricsStore.getFontMetrics(fontProperties);\n  }\n\n  /**\n   * Unload both metrics and atlas for a font\n   * @param {string} idString - Font ID string\n   */\n  static unloadFont(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    FontMetricsStore.deleteFontMetrics(fontProperties);\n    AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Unload multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   */\n  static unloadFonts(idStrings) {\n    idStrings.forEach(id => this.unloadFont(id));\n  }\n\n  /**\n   * Unload metrics (cascades to unload atlas)\n   * @param {string} idString - Font ID string\n   */\n  static unloadMetrics(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    FontMetricsStore.deleteFontMetrics(fontProperties);\n    AtlasDataStore.deleteAtlas(fontProperties); // Cascade: no metrics = no atlas\n  }\n\n  /**\n   * Unload atlas only (keeps metrics)\n   * @param {string} idString - Font ID string\n   */\n  static unloadAtlas(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n    AtlasDataStore.deleteAtlas(fontProperties);\n  }\n\n  /**\n   * Unload all fonts (both metrics and atlases)\n   */\n  static unloadAllFonts() {\n    FontMetricsStore.clear();\n    AtlasDataStore.clear();\n  }\n\n  /**\n   * Unload all atlases (keep metrics)\n   */\n  static unloadAllAtlases() {\n    AtlasDataStore.clear();\n  }\n\n  // ============================================\n  // Query API\n  // ============================================\n\n  /**\n   * Check if font is fully loaded (both metrics and atlas)\n   * For sizes < 8.5, checks if size 8.5 metrics exist (atlas always false for < 8.5)\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if both metrics and atlas are loaded\n   */\n  static hasFont(idString) {\n    return this.hasMetrics(idString) && this.hasAtlas(idString);\n  }\n\n  /**\n   * Check if metrics are loaded for a font\n   * For sizes < 8.5, checks if size 8.5 metrics exist\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if metrics are loaded\n   */\n  static hasMetrics(idString) {\n    // Redirect sizes < 8.5 to check for 8.5 metrics (silent to avoid log spam)\n    const redirection = BitmapText.#redirectIdStringIfNeeded(idString, true);\n    const fontProperties = FontProperties.fromIDString(redirection.idString);\n    return FontMetricsStore.hasFontMetrics(fontProperties);\n  }\n\n  /**\n   * Check if atlas is loaded for a font\n   * For sizes < 8.5, always returns false (these sizes use placeholder mode)\n   * @param {string} idString - Font ID string\n   * @returns {boolean} True if atlas is loaded\n   */\n  static hasAtlas(idString) {\n    const fontProperties = FontProperties.fromIDString(idString);\n\n    // Sizes < 8.5 never have atlases (always use placeholder mode)\n    if (BitmapText.#shouldUseMinSize(fontProperties.fontSize)) {\n      return false;\n    }\n\n    const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n    return atlasData && BitmapText.#isValidAtlas(atlasData);\n  }\n\n  /**\n   * Get list of fully loaded fonts (both metrics and atlas)\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedFonts() {\n    const loaded = [];\n    for (const key of FontMetricsStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n      if (atlasData && BitmapText.#isValidAtlas(atlasData)) {\n        loaded.push(fontProperties.idString);\n      }\n    }\n    return loaded;\n  }\n\n  /**\n   * Get list of fonts with loaded metrics\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedMetrics() {\n    const loaded = [];\n    for (const key of FontMetricsStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      loaded.push(fontProperties.idString);\n    }\n    return loaded;\n  }\n\n  /**\n   * Get list of fonts with loaded atlases\n   * @returns {Array<string>} Array of font ID strings\n   */\n  static getLoadedAtlases() {\n    const loaded = [];\n    for (const key of AtlasDataStore.getAvailableFonts()) {\n      const fontProperties = FontProperties.fromKey(key);\n      const atlasData = AtlasDataStore.getAtlasData(fontProperties);\n      if (BitmapText.#isValidAtlas(atlasData)) {\n        loaded.push(fontProperties.idString);\n      }\n    }\n    return loaded;\n  }\n\n  // ============================================\n  // Testing Helpers\n  // ============================================\n\n  /**\n   * Reset all state for testing\n   * @private\n   */\n  static __resetForTesting() {\n    FontMetricsStore.clear();\n    AtlasDataStore.clear();\n    // Clear FontLoader state\n    if (FontLoaderBase._loadingPromises) {\n      FontLoaderBase._loadingPromises.clear();\n    }\n    if (FontLoaderBase._tempAtlasPackages) {\n      FontLoaderBase._tempAtlasPackages = {};\n    }\n    if (FontLoaderBase._pendingAtlases) {\n      FontLoaderBase._pendingAtlases.clear();\n    }\n    // Reset FontLoader configuration\n    if (FontLoaderBase.setFontDirectory) {\n      FontLoaderBase.setFontDirectory(null);\n    }\n    BitmapText.#coloredGlyphCanvas = null;\n    BitmapText.#coloredGlyphCtx = null;\n    BitmapText.#canvasFactory = null;\n    BitmapText.#fontLoader = null;\n  }\n\n  // ============================================\n  // Character Set Generation\n  // ============================================\n\n  /**\n   * Generate character set programmatically\n   * Creates a sorted string of 204 characters including:\n   * - ASCII printable (32-126): 95 characters\n   * - Windows-1252 subset (128-159): 14 characters\n   * - Latin-1 Supplement (161-255): 94 characters (excluding soft hyphen)\n   * - Full Block character (█): 1 character\n   * @private\n   * @returns {string} Sorted character set string\n   */\n  static #generateCharacterSet() {\n    const chars = [];\n\n    // ASCII printable characters (32-126)\n    // Includes space, numbers, letters, and common symbols\n    for (let i = 32; i <= 126; i++) {\n      chars.push(String.fromCharCode(i));\n    }\n\n    // A selection from Windows-1252 (CP-1252) printable characters.\n    // This is the most standard definition of \"extended ASCII codes\" from 128 to 159\n    // and many of these are common/useful symbols that people \"expect to have\".\n    // However fromCharCode doesn't work on those as that range is not defined\n    // in UTF-8/Unicode (modern web standard, so we want to include (some of) them but we have\n    // to map them to specific Unicode code points, not the byte values themselves.\n    // NOTE: we could likely shave some of these off, as they are not easily printable\n    // in Javascript and some of them are fairly arcane/\n    const cp1252PrintableChars = [\n      8364, // € Euro sign (CP-1252: 128)\n      //  8218, // ‚ Single low-9 quotation mark (CP-1252: 130)\n      //  402,  // ƒ Latin small letter f with hook (CP-1252: 131)\n      //  8222, // „ Double low-9 quotation mark (CP-1252: 132)\n      8230, // … Horizontal ellipsis (CP-1252: 133)\n      //  8224, // † Dagger (CP-1252: 134)\n      //  8225, // ‡ Double dagger (CP-1252: 135)\n      //  710,  // ˆ Modifier letter circumflex accent (CP-1252: 136)\n      8240, // ‰ Per mille sign (CP-1252: 137)\n      //  352,  // Š Latin capital letter S with caron (CP-1252: 138)\n      8249, // ‹ Single left-pointing angle quotation (CP-1252: 139)\n      //  338,  // Œ Latin capital ligature OE (CP-1252: 140)\n      381,  // Ž Latin capital letter Z with caron (CP-1252: 142)\n      //  8216, // ' Left single quotation mark (CP-1252: 145)\n\n      // UNFORTUNATELY SOMETIMES USED INSTEAD OF APOSTROPHE\n      8217, // ' \"\"curly apostrophe\"\" or \"right single quotation mark\" (CP-1252: 146)\n\n      //  8220, // \" Left double quotation mark (CP-1252: 147)\n      //  8221, // \" Right double quotation mark (CP-1252: 148)\n      8226, // • Bullet (CP-1252: 149)\n      //  8211, // – En dash (CP-1252: 150)\n      8212, // — Em dash (CP-1252: 151)\n      //  732,  // ˜ Small tilde (CP-1252: 152)\n      8482, // ™ Trade mark sign (CP-1252: 153)\n      353,  // š Latin small letter s with caron (CP-1252: 154)\n      8250, // › Single right-pointing angle quotation mark (CP-1252: 155)\n      339,  // œ Latin small ligature oe (CP-1252: 156)\n      382,  // ž Latin small letter z with caron (CP-1252: 158)\n      376   // Ÿ Latin capital letter Y with diaeresis (CP-1252: 159)\n    ];\n\n    for (const code of cp1252PrintableChars) {\n      chars.push(String.fromCharCode(code));\n    }\n\n    // Latin-1 Supplement characters (161-255)\n    // These are properly defined in UTF-8/Unicode\n    // Exclude U+00AD (173) - soft hyphen, which has zero width\n    for (let i = 161; i <= 255; i++) {\n      if (i !== 173) { // Skip soft hyphen\n        chars.push(String.fromCharCode(i));\n      }\n    }\n\n    // Add Full Block character (allows us to see the maximum space taken by a glyph)\n    chars.push('█');\n\n    // Sort the character set (this is how it's used throughout the codebase)\n    return chars.sort().join('');\n  }\n}\n\n// TIER 6b OPTIMIZATION: Short aliases for registration methods (saves ~15 bytes per file)\nBitmapText.r = BitmapText.registerMetrics;\nBitmapText.a = BitmapText.registerAtlas;\n\n// ============================================================================\n// MetricsExpander.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/builder/MetricsExpander.js\n// ============================================================================\n\n// Static utility class for expanding minified font metrics data (runtime only)\n// Converts compact format back to FontMetrics instances for use by the rendering engine\n// NOTE: Requires BitmapText.js to be loaded first (uses BitmapText.CHARACTER_SET)\n\nclass MetricsExpander {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('MetricsExpander cannot be instantiated - use static methods');\n  }\n\n  /**\n   * TIER 6c OPTIMIZATION: Decode base64 string to array of integers\n   * Reverses the base64 byte encoding from MetricsMinifier\n   *\n   * @param {string} base64 - Base64 encoded string\n   * @returns {Array<number>} Array of integers (0-255)\n   */\n  static #decodeFromBase64Bytes(base64) {\n    // In browser: use atob\n    // In Node.js: use Buffer\n    let bytes;\n\n    if (typeof Buffer !== 'undefined') {\n      // Node.js environment\n      bytes = Buffer.from(base64, 'base64');\n    } else {\n      // Browser environment\n      const binary = atob(base64);\n      bytes = new Uint8Array(binary.length);\n      for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n      }\n    }\n\n    return Array.from(bytes);\n  }\n\n  /**\n   * TIER 6c OPTIMIZATION: Decode varint+zigzag+base64 to signed integers\n   * Reverses the VarInt encoding from MetricsMinifier\n   *\n   * @param {string} base64 - Base64 encoded varint bytes\n   * @returns {Array<number>} Array of signed integers\n   */\n  static #decodeVarInts(base64) {\n    const bytes = this.#decodeFromBase64Bytes(base64);\n    const integers = [];\n    let i = 0;\n\n    while (i < bytes.length) {\n      // Decode VarInt: 7 bits per byte, MSB indicates continuation\n      let value = 0;\n      let shift = 0;\n      let byte;\n\n      do {\n        byte = bytes[i++];\n        value |= (byte & 0x7F) << shift;\n        shift += 7;\n      } while (byte & 0x80);\n\n      // Zigzag decoding: convert unsigned back to signed\n      // 0→0, 1→-1, 2→1, 3→-2, 4→2, ...\n      const signed = (value & 1) ? -(value + 1) / 2 : value / 2;\n      integers.push(signed);\n    }\n\n    return integers;\n  }\n\n  /**\n   * TIER 7 OPTIMIZATION: Decompress value lookup array from delta encoding + base64\n   *\n   * Reverses the compression:\n   * 1. Decode base64 → varint → zigzag → deltas\n   * 2. Reconstruct sorted values from deltas\n   * 3. Return as unsorted array (order doesn't matter for lookup)\n   *\n   * @param {string} base64 - Base64 encoded delta-compressed string\n   * @returns {Array<number>} Array of metric value integers\n   */\n  static #decompressValueArray(base64) {\n    // Decode base64 → deltas\n    const deltas = this.#decodeVarInts(base64);\n\n    // Reconstruct sorted values from deltas\n    const sorted = [deltas[0]]; // First value is absolute\n    for (let i = 1; i < deltas.length; i++) {\n      sorted.push(sorted[i - 1] + deltas[i]);\n    }\n\n    // Return as-is (order doesn't matter for value lookup)\n    // The indices in tuplets refer to sorted positions\n    return sorted;\n  }\n\n  /**\n   * Expands minified metrics back to FontMetrics instance for runtime use\n   * TIER 7 FORMAT (backward compatible with Tier 6c)\n   *\n   * @param {Array} minified - Minified metrics array [kv, k, b, v, t, g, s, cl]\n   *   - v can be array (Tier 6c) or base64 string (Tier 7)\n   * @returns {FontMetrics} FontMetrics instance with expanded data\n   * @throws {Error} If invalid format detected\n   */\n  static expand(minified) {\n    // Check if FontMetrics class is available\n    if (typeof FontMetrics === 'undefined') {\n      throw new Error('FontMetrics class not found. Please ensure FontMetrics.js is loaded before MetricsExpander.js');\n    }\n\n    // Validate Tier 6c format: 8-element array only\n    if (!Array.isArray(minified) || minified.length !== 8) {\n      throw new Error(\n        `Invalid format - expected 8-element array (Tier 6c), got ${typeof minified === 'object' ? 'array' : typeof minified} with ${minified?.length || 0} elements.\\n` +\n        `Please regenerate font assets with the current version.`\n      );\n    }\n\n    // Extract values from Tier 6c/7 array format\n    let [kv, k, b, v, t, g, s, cl] = minified;\n\n    // Convert integer values back to floats (divide by 10000)\n    kv = this.#convertIntegersToValues(kv);\n\n    // TIER 7: Handle value lookup array - can be array (Tier 6c) or base64 string (Tier 7)\n    if (typeof v === 'string') {\n      // Tier 7: Decompress from delta-encoded base64\n      v = this.#decompressValueArray(v);\n      v = this.#convertIntegersToValues(v);\n    } else if (Array.isArray(v)) {\n      // Tier 6c: Already an array of integers\n      v = this.#convertIntegersToValues(v);\n    } else {\n      throw new Error('Invalid value lookup format - expected array or string');\n    }\n\n    // Unflatten baseline array to object\n    b = this.#unflattenBaseline(b);\n\n    // Decode base64-encoded binary data\n    // t = VarInt+zigzag encoded flattened tuplets\n    // g = byte-encoded tuplet indices\n    t = this.#decodeVarInts(t);\n    g = this.#decodeFromBase64Bytes(g);\n\n    // Unflatten tuplet data from negative-delimiter format\n    t = this.#unflattenTuplets(t);\n\n    const expandedData = {\n      kerningTable: this.#expandKerningTable(k, kv),\n      characterMetrics: this.#expandCharacterMetrics(g, b, v, t, cl),\n      spaceAdvancementOverrideForSmallSizesInPx: s\n    };\n\n    // Verify pixelDensity was preserved\n    const firstChar = Object.keys(expandedData.characterMetrics)[0];\n    const pixelDensity = expandedData.characterMetrics[firstChar]?.pixelDensity;\n    console.debug(`🔍 MetricsExpander: Restored pixelDensity=${pixelDensity} for ${Object.keys(expandedData.characterMetrics).length} characters`);\n\n    return new FontMetrics(expandedData);\n  }\n  \n  /**\n   * Expands kerning table with range notation support\n   * TIER 3 OPTIMIZATION: Two-dimensional expansion (reverse order of compression)\n   * TIER 4 OPTIMIZATION: Value indexing (looks up actual kerning values from indices)\n   *   Pass 1 (left-side):  {\"A-B\":{\"s\":0}} → {\"A\":{\"s\":0},\"B\":{\"s\":0}}\n   *   Pass 2 (right-side): {\"A\":{\"0-1\":0}} → {\"A\":{\"0\":0,\"1\":0}}\n   *   Pass 3 (values):     {\"A\":{\"s\":0}} → {\"A\":{\"s\":20}} (lookup from kerningValueLookup[0])\n   * Always uses BitmapText.CHARACTER_SET for range expansion\n   * Later entries override earlier ones, allowing exceptions to ranges\n   * @param {Object} minified - Minified kerning table with indexed values\n   * @param {Array} kerningValueLookup - Value lookup table for kerning values\n   * @private\n   */\n  static #expandKerningTable(minified, kerningValueLookup) {\n    // PASS 1: Expand left side (characters that come before)\n    const leftExpanded = this.#expandLeftSide(minified);\n\n    // PASS 2: Expand right side (characters that follow)\n    const rangeExpanded = {};\n    for (const [leftChar, pairs] of Object.entries(leftExpanded)) {\n      rangeExpanded[leftChar] = this.#expandKerningPairs(pairs);\n    }\n\n    // PASS 3 (TIER 4): Replace all indices with actual values from lookup table\n    const expanded = {};\n    for (const [leftChar, pairs] of Object.entries(rangeExpanded)) {\n      expanded[leftChar] = {};\n      for (const [rightChar, index] of Object.entries(pairs)) {\n        expanded[leftChar][rightChar] = kerningValueLookup[index];\n      }\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Expands left side of kerning table (characters that come before)\n   * TIER 3 OPTIMIZATION: Two-dimensional expansion pass 1\n   * Handles left-side range notation like \"A-C\":{\"s\":20} → {\"A\":{\"s\":20},\"B\":{\"s\":20},\"C\":{\"s\":20}}\n   * Always uses BitmapText.CHARACTER_SET for range expansion\n   * @param {Object} minified - Minified kerning table with potential left-side ranges\n   * @returns {Object} Left-expanded kerning table\n   * @private\n   */\n  static #expandLeftSide(minified) {\n    const expanded = {};\n\n    // Process entries in order so later entries can override earlier ones\n    for (const [key, rightSideObj] of Object.entries(minified)) {\n      if (key.includes('-') && key.length >= 3) {\n        // Potential range notation (e.g., \"A-Z\" or \"0-9\")\n        const hyphenIndex = key.indexOf('-');\n        const startChar = key.substring(0, hyphenIndex);\n        const endChar = key.substring(hyphenIndex + 1);\n\n        // Check if both start and end are single characters in the character set\n        if (startChar.length === 1 && endChar.length === 1) {\n          const startIndex = BitmapText.CHARACTER_SET.indexOf(startChar);\n          const endIndex = BitmapText.CHARACTER_SET.indexOf(endChar);\n\n          if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {\n            // Valid range, expand it\n            for (let i = startIndex; i <= endIndex; i++) {\n              expanded[BitmapText.CHARACTER_SET[i]] = rightSideObj;\n            }\n            continue;\n          }\n        }\n      }\n\n      // Not a range, or invalid range - treat as literal character\n      expanded[key] = rightSideObj;\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Expands kerning pairs from compact string notation to individual character pairs\n   * TIER 6b OPTIMIZATION: Handles advanced compact notation with non-sequential grouping\n   *\n   * Parses compact strings like \"-,.:;ac-egj-s\" which means:\n   * - Dash at START is literal\n   * - Individual chars: comma, dot, colon, semicolon\n   * - Ranges: a, c-e (c,d,e), g, j-s (j,k,l,m,n,o,p,q,r,s)\n   *\n   * Always uses BitmapText.CHARACTER_SET for range expansion\n   * @param {Object} pairs - Compressed pairs like {\"-,.:;ac-egj-s\":20}\n   * @returns {Object} Expanded pairs like {\"-\":20,\",\":20,\".\":20,...,\"s\":20}\n   * @private\n   */\n  static #expandKerningPairs(pairs) {\n    const expanded = {};\n\n    // Process entries in order so later entries can override earlier ones\n    for (const [key, value] of Object.entries(pairs)) {\n      // Parse the compact string notation\n      const chars = this.#parseCompactCharString(key);\n\n      // Assign value to all parsed characters\n      for (const char of chars) {\n        expanded[char] = value;\n      }\n    }\n\n    return expanded;\n  }\n\n  /**\n   * Parses compact character string notation\n   * TIER 6b OPTIMIZATION: Handles dash-at-start and range notation\n   *\n   * Format:\n   * - First char is dash → literal dash character\n   * - \"a-z\" → range from a to z\n   * - \"abc\" → individual characters a, b, c\n   * - \"-,.:;ac-egj-s\" → dash, comma, dot, colon, semicolon, a, c-e range, g, j-s range\n   *\n   * @param {string} compactStr - Compact string like \"-,.:;ac-egj-s\"\n   * @returns {string[]} Array of individual characters\n   * @private\n   */\n  static #parseCompactCharString(compactStr) {\n    const chars = [];\n    let i = 0;\n\n    // Handle dash at start (literal)\n    if (compactStr[0] === '-') {\n      chars.push('-');\n      i = 1;\n    }\n\n    // Parse rest of string\n    while (i < compactStr.length) {\n      const currentChar = compactStr[i];\n\n      // Check if this is the start of a range pattern\n      if (i + 2 < compactStr.length && compactStr[i + 1] === '-') {\n        // Pattern: \"X-Y\" where X and Y are single characters\n        const startChar = currentChar;\n        const endChar = compactStr[i + 2];\n\n        // Verify it's a valid range in BitmapText.CHARACTER_SET\n        const startIndex = BitmapText.CHARACTER_SET.indexOf(startChar);\n        const endIndex = BitmapText.CHARACTER_SET.indexOf(endChar);\n\n        if (startIndex !== -1 && endIndex !== -1 && startIndex < endIndex) {\n          // Valid range - expand it\n          for (let j = startIndex; j <= endIndex; j++) {\n            chars.push(BitmapText.CHARACTER_SET[j]);\n          }\n          i += 3; // Skip X, -, Y\n        } else {\n          // Not a valid range - treat as individual characters\n          chars.push(currentChar);\n          i++;\n        }\n      } else {\n        // Individual character\n        chars.push(currentChar);\n        i++;\n      }\n    }\n\n    return chars;\n  }\n  \n  /**\n   * Expands glyph metrics from arrays back to full objects\n   * TIER 2 OPTIMIZATION: Reconstructs from array of arrays using BitmapText.CHARACTER_SET\n   * TIER 4 OPTIMIZATION: Looks up actual values from indices using valueLookup table\n   * TIER 5a OPTIMIZATION: Decompresses variable-length tuplets (2/3/4/5 elements)\n   * TIER 5b OPTIMIZATION: Looks up tuplets from tuplet indices\n   * TIER 6b OPTIMIZATION: 2-element tuplets using common left index\n   *\n   * Tuplet decompression (deterministic based on length):\n   *   - Length 2: [w, a] → [w, CL, w, a, CL]  (w===r AND l===CL AND d===CL)\n   *   - Length 3: [w, l, a] → [w, l, w, a, l]  (w===r AND l===d)\n   *   - Length 4: [w, l, a, d] → [w, l, w, a, d]  (w===r only)\n   *   - Length 5: [w, l, r, a, d] (no decompression)\n   *\n   * Reconstructs full TextMetrics-compatible objects from compact arrays\n   * Always uses BitmapText.CHARACTER_SET for character order\n   * @param {Array} tupletIndices - Array of tuplet indices (single integers)\n   * @param {Object} metricsCommonToAllCharacters - Common metrics shared across all characters\n   * @param {Array} valueLookup - Value lookup table mapping indices to actual values\n   * @param {Array} tupletLookup - Tuplet lookup table mapping tuplet indices to index arrays\n   * @param {number} [commonLeftIndex] - Common left bounding box index (Tier 6b, optional)\n   * @private\n   */\n  static #expandCharacterMetrics(tupletIndices, metricsCommonToAllCharacters, valueLookup, tupletLookup, commonLeftIndex) {\n    const expanded = {};\n\n    // Convert BitmapText.CHARACTER_SET string to array of characters\n    const chars = Array.from(BitmapText.CHARACTER_SET);\n\n    // Reconstruct object by mapping array positions to characters\n    chars.forEach((char, index) => {\n      // TIER 5b: Look up tuplet from tuplet index\n      const tupletIndex = tupletIndices[index];\n      const compressed = tupletLookup[tupletIndex];\n\n      let indices;\n\n      // TIER 5+6b: Decompress tuplet based on length\n      if (compressed.length === 2) {\n        // Case D (TIER 6b): [w, a] → [w, CL, w, a, CL]\n        // All three patterns: w===r AND l===CL AND d===CL\n        if (commonLeftIndex === undefined) {\n          throw new Error(\n            `2-element tuplet found but no common left index provided.\\n` +\n            `Character \"${char}\" at index ${index}: [${compressed.join(',')}]\\n` +\n            `This indicates a corrupted Tier 6b font file. Please regenerate font assets.`\n          );\n        }\n        indices = [\n          compressed[0],    // width\n          commonLeftIndex,  // left = common left\n          compressed[0],    // right = width (pattern 1)\n          compressed[1],    // ascent\n          commonLeftIndex   // descent = common left (pattern 2)\n        ];\n      }\n      else if (compressed.length === 3) {\n        // Case C: [w, l, a] → [w, l, w, a, l]\n        // Both w===r and l===d\n        indices = [\n          compressed[0],  // width\n          compressed[1],  // left\n          compressed[0],  // right = width (pattern 1)\n          compressed[2],  // ascent\n          compressed[1]   // descent = left (pattern 2)\n        ];\n      }\n      else if (compressed.length === 4) {\n        // Case B: [w, l, a, d] → [w, l, w, a, d]\n        // Only w===r\n        indices = [\n          compressed[0],  // width\n          compressed[1],  // left\n          compressed[0],  // right = width (pattern 1)\n          compressed[2],  // ascent\n          compressed[3]   // descent\n        ];\n      }\n      else if (compressed.length === 5) {\n        // Case A: [w, l, r, a, d] - no decompression needed\n        indices = compressed;\n      }\n      else {\n        throw new Error(\n          `Invalid glyph tuplet length for character \"${char}\" at index ${index}.\\n` +\n          `Expected 2, 3, 4, or 5 elements, got ${compressed.length}: [${compressed.join(',')}]\\n` +\n          `This indicates a corrupted font file. Please regenerate font assets.`\n        );\n      }\n\n      // TIER 4: Look up actual values from indices\n      const width = valueLookup[indices[0]];\n      const actualBoundingBoxLeft = valueLookup[indices[1]];\n      const actualBoundingBoxRight = valueLookup[indices[2]];\n      const actualBoundingBoxAscent = valueLookup[indices[3]];\n      const actualBoundingBoxDescent = valueLookup[indices[4]];\n\n      expanded[char] = {\n        // Glyph-specific metrics looked up from value table\n        width,\n        actualBoundingBoxLeft,\n        actualBoundingBoxRight,\n        actualBoundingBoxAscent,\n        actualBoundingBoxDescent,\n\n        // Copy over the metrics common to all characters.\n        // This is a bit of a waste of memory, however this object needs to\n        // look as much as possible like a TextMetrics object, and this\n        // is what it looks like.\n        fontBoundingBoxAscent: metricsCommonToAllCharacters.fba,\n        fontBoundingBoxDescent: metricsCommonToAllCharacters.fbd,\n        emHeightAscent: metricsCommonToAllCharacters.fba,          // Same as fontBoundingBoxAscent\n        emHeightDescent: metricsCommonToAllCharacters.fbd,         // Same as fontBoundingBoxDescent\n        hangingBaseline: metricsCommonToAllCharacters.hb,\n        alphabeticBaseline: metricsCommonToAllCharacters.ab,\n        ideographicBaseline: metricsCommonToAllCharacters.ib,\n        pixelDensity: metricsCommonToAllCharacters.pd              // pixelDensity (CRITICAL for atlas reconstruction)\n      };\n    });\n    return expanded;\n  }\n\n  /**\n   * Converts array of integer values back to floats by dividing by 10000\n   * TIER 6 OPTIMIZATION: Integer to value conversion\n   *\n   * @param {number[]} integers - Array of integer values\n   * @returns {number[]} Array of float values\n   * @private\n   */\n  static #convertIntegersToValues(integers) {\n    return integers.map(int => int / 10000);\n  }\n\n  /**\n   * Unflattens baseline array back to object\n   * TIER 6 OPTIMIZATION: Baseline array → object\n   *\n   * @param {number[]} baselineArray - Array [fba, fbd, hb, ab, ib, pd]\n   * @returns {Object} Baseline object with {fba, fbd, hb, ab, ib, pd}\n   * @private\n   */\n  static #unflattenBaseline(baselineArray) {\n    if (!Array.isArray(baselineArray) || baselineArray.length !== 6) {\n      throw new Error(\n        `Invalid baseline array - expected 6 elements, got ${baselineArray?.length}.\\n` +\n        `This indicates a corrupted font file. Please regenerate font assets.`\n      );\n    }\n\n    // Fixed order: fba, fbd, hb, ab, ib, pd\n    return {\n      fba: baselineArray[0],\n      fbd: baselineArray[1],\n      hb: baselineArray[2],\n      ab: baselineArray[3],\n      ib: baselineArray[4],\n      pd: baselineArray[5]\n    };\n  }\n\n  /**\n   * Unflattens tuplet data from negative delimiter format\n   * TIER 6b OPTIMIZATION: Tuplet array unflattening with negative delimiters\n   *\n   * Parses negative-delimited format and shifts back to 0-based indices.\n   * Negative numbers mark the end of each tuplet.\n   *\n   * Converts: [3,2,-15,1,2,16,-8] → [[2,1,14],[0,1,15,7]]\n   * Each tuplet ends with a negative number (1-based) which becomes last element (0-based)\n   *\n   * @param {number[]} flattened - Flattened array with negative delimiters (1-based indices)\n   * @returns {Array<Array<number>>} Array of tuplet arrays (0-based indices)\n   * @private\n   */\n  static #unflattenTuplets(flattened) {\n    const tuplets = [];\n    let currentTuplet = [];\n\n    for (let i = 0; i < flattened.length; i++) {\n      const value = flattened[i];\n\n      if (value < 0) {\n        // Negative marks end of tuplet\n        // Negate back and subtract 1 to get 0-based index\n        currentTuplet.push((-value) - 1);\n\n        // Validate tuplet length\n        if (currentTuplet.length < 2 || currentTuplet.length > 5) {\n          throw new Error(\n            `Invalid tuplet length ${currentTuplet.length} at position ${i}.\\n` +\n            `Expected 2, 3, 4, or 5. This indicates a corrupted font file.\\n` +\n            `Please regenerate font assets.`\n          );\n        }\n\n        tuplets.push(currentTuplet);\n        currentTuplet = [];\n      } else {\n        // Positive value: subtract 1 to get 0-based index\n        currentTuplet.push(value - 1);\n      }\n    }\n\n    // Check for incomplete tuplet at end\n    if (currentTuplet.length > 0) {\n      throw new Error(\n        `Incomplete tuplet at end of data.\\n` +\n        `Found ${currentTuplet.length} elements without negative delimiter.\\n` +\n        `This indicates a corrupted font file. Please regenerate font assets.`\n      );\n    }\n\n    return tuplets;\n  }\n\n}\n// ============================================================================\n// AtlasPositioning.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasPositioning.js\n// ============================================================================\n\n// AtlasPositioning - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It encapsulates atlas positioning data for a single font configuration as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasPositioningFAB for font assets building capabilities (if needed)\n// - Contains only essential positioning data and accessor methods\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas positioning for ONE font configuration\n// - Pre-computed lookups for optimal performance during glyph rendering\n// - xInAtlas values are reconstructed from tightWidth during deserialization (not serialized)\n// - Reconstruction happens once at load time, not per-character at render time\n// - All positioning data stored in memory for O(1) access during rendering\n// - Provides clean API for accessing glyph positioning within atlas\n// - Follows same immutable pattern as FontProperties and FontMetrics\n//\n// SEPARATION RATIONALE:\n// - Encapsulates related atlas positioning data together\n// - Eliminates repeated parameter passing for positioning lookups\n// - Serves as domain object for atlas positioning\n// - Enables cleaner, more object-oriented API\n//\nclass AtlasPositioning {\n  constructor(data, options = {}) {\n    // Validate input data structure\n    if (!data || typeof data !== 'object') {\n      throw new Error('AtlasPositioning constructor requires data object');\n    }\n\n    // Atlas positioning data for glyph rendering\n    this._tightWidth = data.tightWidth || {};\n    this._tightHeight = data.tightHeight || {};\n    this._dx = data.dx || {};\n    this._dy = data.dy || {};\n    // NOTE: xInAtlas is reconstructed from tightWidth during deserialization (not serialized to reduce file size)\n    // At build time: populated by AtlasPositioningFAB during atlas packing\n    // At runtime: reconstructed by TightAtlasReconstructor during atlas loading\n    this._xInAtlas = data.xInAtlas || {};\n\n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this._tightWidth);\n      Object.freeze(this._tightHeight);\n      Object.freeze(this._dx);\n      Object.freeze(this._dy);\n      Object.freeze(this._xInAtlas);\n      Object.freeze(this);\n    }\n  }\n\n  /**\n   * Get positioning metrics for glyph rendering from atlas\n   * @param {string} char - Character (code point) to get positioning for\n   * @returns {Object} Object with xInAtlas, tightWidth, tightHeight, dx, dy\n   */\n  getPositioning(char) {\n    return {\n      xInAtlas: this._xInAtlas[char],\n      tightWidth: this._tightWidth[char],\n      tightHeight: this._tightHeight[char],\n      dx: this._dx[char],\n      dy: this._dy[char]\n    };\n  }\n\n  /**\n   * Check if positioning data exists for a character\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if positioning data exists\n   */\n  hasPositioning(char) {\n    return this._xInAtlas[char] !== undefined &&\n           this._tightWidth[char] !== undefined &&\n           this._tightHeight[char] !== undefined;\n  }\n\n  /**\n   * Check if atlas position (xInAtlas) exists for a character\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if atlas position exists\n   */\n  hasAtlasPosition(char) {\n    return this._xInAtlas[char] !== undefined;\n  }\n\n  /**\n   * Get all available characters in this atlas positioning\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    return Object.keys(this._xInAtlas);\n  }\n\n  /**\n   * Get tight width for a character\n   * @param {string} char - Character (code point) to get width for\n   * @returns {number|undefined} Tight width or undefined if not found\n   */\n  getTightWidth(char) {\n    return this._tightWidth[char];\n  }\n\n  /**\n   * Get tight height for a character\n   * @param {string} char - Character (code point) to get height for\n   * @returns {number|undefined} Tight height or undefined if not found\n   */\n  getTightHeight(char) {\n    return this._tightHeight[char];\n  }\n\n  /**\n   * Get X position in atlas for a character\n   * @param {string} char - Character (code point) to get X position for\n   * @returns {number|undefined} X position in atlas or undefined if not found\n   */\n  getXInAtlas(char) {\n    return this._xInAtlas[char];\n  }\n\n  /**\n   * Get dx offset for a character\n   * @param {string} char - Character (code point) to get dx for\n   * @returns {number|undefined} dx offset or undefined if not found\n   */\n  getDx(char) {\n    return this._dx[char];\n  }\n\n  /**\n   * Get dy offset for a character\n   * @param {string} char - Character (code point) to get dy for\n   * @returns {number|undefined} dy offset or undefined if not found\n   */\n  getDy(char) {\n    return this._dy[char];\n  }\n\n  /**\n   * Generate a deterministic hash of the positioning data\n   * Uses a simple but stable algorithm that works cross-browser/cross-platform\n   * @returns {string} 6-character hex hash\n   */\n  getHash() {\n    // Get sorted characters for deterministic ordering\n    const chars = this.getAvailableCharacters().sort();\n\n    // Build deterministic string representation\n    const parts = [];\n    for (const char of chars) {\n      const pos = this.getPositioning(char);\n      // Use fixed-precision to avoid floating point variations\n      parts.push(\n        `${char}:` +\n        `w${pos.tightWidth}` +\n        `h${pos.tightHeight}` +\n        `x${pos.dx}` +\n        `y${pos.dy}` +\n        `a${pos.xInAtlas}`\n      );\n    }\n\n    // Simple hash function (FNV-1a variant)\n    const str = parts.join('|');\n    let hash = 2166136261; // FNV offset basis\n    for (let i = 0; i < str.length; i++) {\n      hash ^= str.charCodeAt(i);\n      hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n    }\n\n    // Return as 6-character hex (24 bits)\n    return (hash >>> 0).toString(16).substring(0, 6).padStart(6, '0');\n  }\n\n}\n// ============================================================================\n// AtlasImage.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasImage.js\n// ============================================================================\n\n// AtlasImage - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It encapsulates atlas image data as an immutable domain object.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasImageFAB for font assets building capabilities\n// - Contains only essential image data and accessor methods\n// - No image generation, validation, or serialization code\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas image for ONE font configuration\n// - Provides clean API for accessing image properties and validation\n// - Follows same immutable pattern as FontProperties, TextProperties, FontMetrics, and AtlasPositioning\n// - Establishes architectural symmetry: AtlasImage + AtlasPositioning = AtlasData\n//\n// SEPARATION RATIONALE:\n// - Encapsulates image-related functionality in dedicated domain object\n// - Eliminates raw Canvas/Image element handling throughout the codebase\n// - Provides consistent interface for image validation and access\n// - Enables cleaner, more object-oriented API design\n//\n// For font assets building capabilities, use AtlasImageFAB which extends this class.\nclass AtlasImage {\n  constructor(image, options = {}) {\n    // Validate input image\n    if (!image) {\n      throw new Error('AtlasImage constructor requires image (Canvas or Image element)');\n    }\n\n    if (typeof image !== 'object' || (image.width === undefined && image.naturalWidth === undefined)) {\n      throw new Error('AtlasImage constructor requires Canvas or Image element with width property');\n    }\n\n    // Store image (Canvas or Image element) - public field (object is frozen)\n    this.image = image;\n\n    // Freeze for immutability (safe to use as value object)\n    // Skip freezing if this is for font assets building (FAB)\n    if (!options.mutable) {\n      Object.freeze(this);\n    }\n  }\n\n  /**\n   * Get the width of the atlas image\n   * @returns {number} Width in pixels\n   */\n  get width() {\n    // Handle both Canvas (width) and Image (naturalWidth/width) elements\n    return this.image.naturalWidth || this.image.width || 0;\n  }\n\n  /**\n   * Get the height of the atlas image\n   * @returns {number} Height in pixels\n   */\n  get height() {\n    // Handle both Canvas (height) and Image (naturalHeight/height) elements\n    return this.image.naturalHeight || this.image.height || 0;\n  }\n\n  /**\n   * Check if this atlas image is valid for rendering\n   * @returns {boolean} True if image has valid dimensions\n   */\n  isValid() {\n    return this.image &&\n           typeof this.image === 'object' &&\n           this.width > 0 &&\n           this.height > 0;\n  }\n\n  /**\n   * Check if the image is ready for rendering operations\n   * @returns {boolean} True if image can be used for drawing operations\n   */\n  canRender() {\n    if (!this.isValid()) return false;\n\n    // For Image elements, check if they're loaded\n    if (this.image instanceof Image) {\n      return this.image.complete && this.image.naturalWidth > 0;\n    }\n\n    // Canvas elements are always ready if they have valid dimensions\n    return true;\n  }\n\n  /**\n   * Get the type of the underlying image element\n   * @returns {string} 'canvas' or 'image'\n   */\n  getImageType() {\n    if (this.image instanceof HTMLCanvasElement ||\n        (typeof OffscreenCanvas !== 'undefined' && this.image instanceof OffscreenCanvas)) {\n      return 'canvas';\n    }\n    if (this.image instanceof Image || this.image instanceof HTMLImageElement) {\n      return 'image';\n    }\n    return 'unknown';\n  }\n\n  /**\n   * Get a canvas context for drawing operations (if image is a canvas)\n   * @param {string} contextType - Context type (default: '2d')\n   * @returns {CanvasRenderingContext2D|null} Canvas context or null if not a canvas\n   */\n  getContext(contextType = '2d') {\n    if (this.getImageType() === 'canvas') {\n      return this.image.getContext(contextType);\n    }\n    return null;\n  }\n\n  /**\n   * Check if this atlas image equals another atlas image\n   * @param {AtlasImage} other - Another AtlasImage instance\n   * @returns {boolean} True if they reference the same image\n   */\n  equals(other) {\n    if (!(other instanceof AtlasImage)) return false;\n    return this.image === other.image;\n  }\n\n  /**\n   * Get debug information about this atlas image\n   * @returns {Object} Debug information\n   */\n  getDebugInfo() {\n    return {\n      type: this.getImageType(),\n      width: this.width,\n      height: this.height,\n      isValid: this.isValid(),\n      canRender: this.canRender()\n    };\n  }\n}\n// ============================================================================\n// AtlasData.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasData.js\n// ============================================================================\n\n// AtlasData - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).\n// It encapsulates both atlas image and positioning data for a font configuration.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Combines AtlasImage with AtlasPositioning data\n// - Provides unified interface for atlas image and positioning access\n// - Establishes architectural symmetry: AtlasImage + AtlasPositioning = AtlasData\n//\n// ARCHITECTURE:\n// - Immutable object representing atlas image + positioning for ONE font configuration\n// - Stores AtlasImage instance with AtlasPositioning instance\n// - Provides clean API for accessing both image and positioning data\n// - Validates atlas integrity for rendering safety\n//\n// SEPARATION RATIONALE:\n// - Atlas positioning data moved from FontMetrics to be co-located with atlas images\n// - Reduces metrics file sizes (positioning only loaded when atlas is loaded)\n// - Better separation: metrics for measurement, atlas for rendering\n// - Perfect symmetry: both image and positioning are encapsulated in domain objects\n//\nclass AtlasData {\n  constructor(atlasImage, atlasPositioning) {\n    // Validate AtlasImage instance\n    if (!(atlasImage instanceof AtlasImage)) {\n      throw new Error('AtlasData constructor requires AtlasImage instance (not raw Canvas/Image)');\n    }\n\n    // Validate AtlasPositioning instance (optional but recommended)\n    if (atlasPositioning && !(atlasPositioning instanceof AtlasPositioning)) {\n      throw new Error('AtlasData constructor requires AtlasPositioning instance (not raw positioning object)');\n    }\n\n    // Store AtlasImage instance (public field - object is frozen)\n    this.atlasImage = atlasImage;\n\n    // Store AtlasPositioning instance (public field - object is frozen)\n    this.atlasPositioning = atlasPositioning;\n\n    // Freeze for immutability (safe to use as value object)\n    Object.freeze(this);\n  }\n\n  /**\n   * Check if positioning data exists for a character\n   * Null-safe convenience method that delegates to the AtlasPositioning instance.\n   * This demonstrates the delegation pattern: AtlasData wraps AtlasPositioning\n   * and provides a simplified interface for checking character availability.\n   * @param {string} char - Character (code point) to check\n   * @returns {boolean} True if positioning data exists\n   */\n  hasPositioning(char) {\n    if (!this.atlasPositioning) return false;\n\n    // Delegate to AtlasPositioning instance\n    return this.atlasPositioning.hasPositioning(char);\n  }\n\n  /**\n   * Check if this atlas data is valid for rendering\n   * @returns {boolean} True if atlas has valid image and dimensions\n   */\n  isValid() {\n    return this.atlasImage?.isValid();\n  }\n\n  /**\n   * Get all available characters in this atlas\n   * @returns {string[]} Array of available characters\n   */\n  getAvailableCharacters() {\n    if (!this.atlasPositioning) return [];\n\n    // Delegate to AtlasPositioning instance\n    return this.atlasPositioning.getAvailableCharacters();\n  }\n\n  /**\n   * Get the width of the atlas image\n   * @returns {number} Width in pixels\n   */\n  get width() {\n    return this.atlasImage.width;\n  }\n\n  /**\n   * Get the height of the atlas image\n   * @returns {number} Height in pixels\n   */\n  get height() {\n    return this.atlasImage.height;\n  }\n\n  /**\n   * Check if the atlas can be rendered\n   * @returns {boolean} True if atlas is ready for rendering operations\n   */\n  canRender() {\n    return this.atlasImage?.canRender();\n  }\n\n  /**\n   * Check if this atlas data equals another atlas data\n   * @param {AtlasData} other - Another AtlasData instance\n   * @returns {boolean} True if they reference the same image and positioning\n   */\n  equals(other) {\n    if (!(other instanceof AtlasData)) return false;\n    return this.atlasImage.equals(other.atlasImage) &&\n           this.atlasPositioning === other.atlasPositioning;\n  }\n\n  /**\n   * Get debug information about this atlas data\n   * @returns {Object} Debug information\n   */\n  getDebugInfo() {\n    return {\n      atlasImage: this.atlasImage ? this.atlasImage.getDebugInfo() : null,\n      atlasPositioning: this.atlasPositioning ? {\n        availableCharacters: this.atlasPositioning.getAvailableCharacters().length,\n        characters: this.atlasPositioning.getAvailableCharacters().slice(0, 10) // First 10 for brevity\n      } : null,\n      isValid: this.isValid(),\n      canRender: this.canRender()\n    };\n  }\n}\n// ============================================================================\n// AtlasReconstructionUtils.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/builder/AtlasReconstructionUtils.js\n// ============================================================================\n\n// AtlasReconstructionUtils - Shared utility for image data extraction\n// Used by TightAtlasReconstructor for atlas image processing\n//\n// ARCHITECTURAL DESIGN RATIONALE:\n// This utility class provides cross-platform image data extraction that works\n// in both browser and Node.js environments. It handles different image sources\n// (HTMLImageElement, Canvas, AtlasImage wrapper) and creates temporary canvases\n// as needed for pixel data access.\n//\n// By centralizing this logic here, we ensure:\n// - Zero code duplication across different reconstruction contexts\n// - Single source of truth for image data extraction\n// - Consistent cross-platform behavior (browser vs Node.js)\n// - Easy to unit test independently\n\nclass AtlasReconstructionUtils {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('AtlasReconstructionUtils cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Gets ImageData from various image sources\n   * Handles: HTMLImageElement (PNG), Canvas (QOI), AtlasImage wrapper\n   * @param {Image|Canvas|AtlasImage} image - Image source\n   * @returns {ImageData} ImageData object with pixel data\n   * @throws {Error} If image is not a valid source\n   */\n  static getImageData(image) {\n    // Unwrap AtlasImage if needed\n    const actualImage = image?.image ? image.image : image;\n\n    if (!actualImage) {\n      throw new Error('getImageData: Invalid image source (null or undefined)');\n    }\n\n    // If Canvas, directly get image data\n    if (actualImage.getContext) {\n      const ctx = actualImage.getContext('2d');\n      return ctx.getImageData(0, 0, actualImage.width, actualImage.height);\n    }\n\n    // If Image element, draw to temporary canvas first\n    if (actualImage.naturalWidth !== undefined || actualImage.width !== undefined) {\n      // Create canvas using explicit double invocation\n      const canvas = BitmapText.getCanvasFactory()();\n      canvas.width = actualImage.naturalWidth || actualImage.width;\n      canvas.height = actualImage.naturalHeight || actualImage.height;\n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(actualImage, 0, 0);\n      return ctx.getImageData(0, 0, canvas.width, canvas.height);\n    }\n\n    throw new Error('getImageData: Image source is not a Canvas or Image element');\n  }\n}\n\n// ============================================================================\n// AtlasCellDimensions.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/utils/AtlasCellDimensions.js\n// ============================================================================\n\n// AtlasCellDimensions - Utility for calculating atlas cell dimensions\n//\n// Provides centralized formulas for calculating cell dimensions from character metrics.\n// These formulas MUST be consistent across AtlasBuilder and TightAtlasReconstructor.\n//\n// Cell dimensions follow the Atlas format (variable-width cells):\n// - Cell width: actualBoundingBoxLeft + actualBoundingBoxRight (varies per character)\n// - Cell height: fontBoundingBoxAscent + fontBoundingBoxDescent (constant per font)\n\nclass AtlasCellDimensions {\n  // Private constructor - prevent instantiation\n  constructor() {\n    throw new Error('AtlasCellDimensions cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Calculate cell width for a character\n   * CRITICAL: Must match GlyphFAB.js:155-160 which uses Math.round()\n   * @param {Object} charMetrics - Character metrics from FontMetrics\n   * @returns {number} Cell width in pixels (rounded, matching GlyphFAB canvas creation)\n   */\n  static getWidth(charMetrics) {\n    return Math.round(\n      charMetrics.actualBoundingBoxLeft +\n      charMetrics.actualBoundingBoxRight\n    );\n  }\n\n  /**\n   * Calculate cell height for a font\n   * CRITICAL: Must match GlyphFAB.js:170-175 which uses Math.round()\n   * @param {Object} charMetrics - Character metrics (any character from the font)\n   * @returns {number} Cell height in pixels (rounded, constant for entire font)\n   */\n  static getHeight(charMetrics) {\n    return Math.round(\n      charMetrics.fontBoundingBoxAscent +\n      charMetrics.fontBoundingBoxDescent\n    );\n  }\n\n  /**\n   * Calculate both dimensions\n   * @param {Object} charMetrics - Character metrics\n   * @returns {{width: number, height: number}}\n   */\n  static getDimensions(charMetrics) {\n    return {\n      width: this.getWidth(charMetrics),\n      height: this.getHeight(charMetrics)\n    };\n  }\n}\n\n// ============================================================================\n// TightAtlasReconstructor.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/TightAtlasReconstructor.js\n// ============================================================================\n\n// TightAtlasReconstructor - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for reconstructing tight atlases from\n// standard atlases via pixel scanning.\n//\n// DISTRIBUTION ROLE:\n// - Used by font-assets-builder.html and also by the runtime to reconstruct tight\n//   atlases for display and storage\n// - Reconstructs tight atlas + positioning data from atlas image\n//\n// ARCHITECTURE:\n// - Takes atlas image (variable-width cells) and FontMetrics\n// - Scans each character cell to find tight bounding box\n// - Repacks into tight atlas\n// - Calculates positioning data (dx, dy) using EXACT formulas from AtlasPositioningFAB\n//\n// CRITICAL REQUIREMENTS:\n// - MUST use sorted character order (same as AtlasBuilder)\n// - dx/dy formulas MUST match AtlasPositioningFAB.js:87-88 exactly\n// - MUST handle multi-part glyphs (i, j with dots) correctly\n// - MUST use 4-step optimized tight bounds detection algorithm\n//\nclass TightAtlasReconstructor {\n  // Private constructor - prevent instantiation following Effective Java patterns\n  constructor() {\n    throw new Error('TightAtlasReconstructor cannot be instantiated - use static methods');\n  }\n\n  /**\n   * Main entry point - reconstructs tight atlas from standard atlas\n   *\n   * PARAMETER ORDER: Standardized to (fontMetrics, data) for API consistency\n   *\n   * @param {FontMetrics} fontMetrics - Font metrics for cell dimensions (CSS pixels) and positioning\n   * @param {Image|Canvas|AtlasImage} atlasImage - Atlas image (variable-width cells, already at physical pixels)\n   * @returns {{atlasImage: AtlasImage, atlasPositioning: AtlasPositioning}}\n   */\n  static reconstructFromAtlas(fontMetrics, atlasImage) {\n    // 1. Get ImageData from atlas for pixel scanning\n    const imageData = AtlasReconstructionUtils.getImageData(atlasImage);\n\n    // 2. Get SORTED character list (CRITICAL for determinism)\n    // Must match the order used in AtlasBuilder\n    const characters = fontMetrics.getAvailableCharacters().sort();\n\n    if (characters.length === 0) {\n      throw new Error('TightAtlasReconstructor: No characters found in FontMetrics');\n    }\n\n    console.debug(`TightAtlasReconstructor: Processing ${characters.length} characters`);\n\n    // 3. Calculate cell dimensions from font metrics\n    // Cell height is constant across all characters in this font\n    // Character metrics contain CSS pixel values, but we need to infer physical pixel dimensions\n    // from the actual atlas image by detecting pixelDensity from the ratio\n    const firstChar = characters[0];\n    const firstMetrics = fontMetrics.getCharacterMetrics(firstChar);\n\n    // Infer pixelDensity from first character's metrics vs atlas dimensions\n    // This works because: physical_pixels = CSS_pixels * pixelDensity\n    const height_CssPx = AtlasCellDimensions.getHeight(firstMetrics);\n    const pixelDensity = firstMetrics.pixelDensity || 1; // Use pixelDensity from metrics if available\n    const cellHeight_PhysPx = Math.round(height_CssPx * pixelDensity);\n\n    console.debug(`🔍 TightAtlasReconstructor: pixelDensity=${pixelDensity}, height_CssPx=${height_CssPx}, cellHeight_PhysPx=${cellHeight_PhysPx}`);\n\n    // 4. Scan each cell to find tight bounds within the atlas cell\n    let cellX_PhysPx = 0;\n    const tightBounds = {};\n    const cellDebugInfo = []; // Track first 5 chars for debugging\n\n    for (const char of characters) {\n      const charMetrics = fontMetrics.getCharacterMetrics(char);\n\n      // Cell width is variable per character (scale CSS pixels to physical pixels)\n      const width_CssPx = AtlasCellDimensions.getWidth(charMetrics);\n      const cellWidth_PhysPx = Math.round(width_CssPx * pixelDensity);\n\n      // Debug first few characters\n      if (cellDebugInfo.length < 5) {\n        cellDebugInfo.push(`${char}:css=${width_CssPx},phys=${cellWidth_PhysPx},x=${cellX_PhysPx}`);\n      }\n\n      // Find tight bounds within this cell using 4-step optimized algorithm\n      const bounds = this.findTightBounds(\n        imageData,\n        cellX_PhysPx,\n        0,\n        cellWidth_PhysPx,\n        cellHeight_PhysPx\n      );\n\n      if (bounds) {\n        tightBounds[char] = bounds;\n      }\n\n      cellX_PhysPx += cellWidth_PhysPx;\n    }\n\n    console.debug(`🔍 Cell dimensions (first 5): ${cellDebugInfo.join(', ')}`);\n\n    // 5. Repack into tight atlas with positioning data\n    return this.packTightAtlas(\n      fontMetrics,\n      tightBounds,\n      characters,\n      atlasImage,\n      pixelDensity,\n      cellHeight_PhysPx\n    );\n  }\n\n  /**\n   * Find tight bounds within a cell using 4-step optimized algorithm\n   * This scans for the minimal bounding box of non-transparent pixels\n   *\n   * @param {ImageData} imageData - Image data from original atlas\n   * @param {number} cellX_PhysPx - X position of cell in atlas (physical pixels)\n   * @param {number} cellY_PhysPx - Y position of cell in atlas (physical pixels, always 0)\n   * @param {number} cellWidth_PhysPx - Width of this character's cell (physical pixels)\n   * @param {number} cellHeight_PhysPx - Height of cell (physical pixels, constant for font)\n   * @returns {{left, top, width, height} | null} - Tight bounds relative to cell origin, or null if empty\n   */\n  static findTightBounds(imageData, cellX_PhysPx, cellY_PhysPx, cellWidth_PhysPx, cellHeight_PhysPx) {\n    const pixels = imageData.data;\n    const atlasWidth_PhysPx = imageData.width;\n\n    // Helper to get alpha value at position\n    // Optimized: pre-calculate stride and use bit shift for x*4\n    const stride = atlasWidth_PhysPx * 4;\n    const getAlpha = (x, y) => pixels[y * stride + (x << 2) + 3];\n\n    // STEP 1: Find bottom edge (scan UP from bottom) - early exit\n    // This finds the bottommost row with any non-transparent pixel\n    let bottom_PhysPx = -1;\n    for (let y = cellY_PhysPx + cellHeight_PhysPx - 1; y >= cellY_PhysPx && bottom_PhysPx === -1; y--) {\n      for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx && bottom_PhysPx === -1; x++) {\n        if (getAlpha(x, y) > 0) {\n          bottom_PhysPx = y;\n        }\n      }\n    }\n\n    // Empty cell (no visible pixels)\n    if (bottom_PhysPx === -1) return null;\n\n    // STEP 2: Find top edge (scan DOWN, only to bottom) - early exit\n    // This finds the topmost row with any non-transparent pixel\n    let top_PhysPx = cellY_PhysPx;\n    for (let y = cellY_PhysPx; y <= bottom_PhysPx; y++) {\n      let found = false;\n      for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx; x++) {\n        if (getAlpha(x, y) > 0) {\n          top_PhysPx = y;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // STEP 3: Find left edge (scan columns, only vertical range found above) - early exit\n    // This finds the leftmost column with any non-transparent pixel\n    let left_PhysPx = cellX_PhysPx;\n    for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx; x++) {\n      let found = false;\n      for (let y = top_PhysPx; y <= bottom_PhysPx; y++) {\n        if (getAlpha(x, y) > 0) {\n          left_PhysPx = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // STEP 4: Find right edge (scan right→left, only vertical range) - early exit\n    // This finds the rightmost column with any non-transparent pixel\n    let right_PhysPx = cellX_PhysPx + cellWidth_PhysPx - 1;\n    for (let x = cellX_PhysPx + cellWidth_PhysPx - 1; x >= cellX_PhysPx; x--) {\n      let found = false;\n      for (let y = top_PhysPx; y <= bottom_PhysPx; y++) {\n        if (getAlpha(x, y) > 0) {\n          right_PhysPx = x;\n          found = true;\n          break;\n        }\n      }\n      if (found) break;\n    }\n\n    // Return bounds relative to cell origin (not absolute atlas coordinates)\n    return {\n      left: left_PhysPx - cellX_PhysPx,        // Relative to cell left edge (physical pixels)\n      top: top_PhysPx - cellY_PhysPx,          // Relative to cell top edge (physical pixels)\n      width: right_PhysPx - left_PhysPx + 1,   // Inclusive width (physical pixels)\n      height: bottom_PhysPx - top_PhysPx + 1   // Inclusive height (physical pixels)\n    };\n  }\n\n  /**\n   * Pack tight glyphs and calculate positioning data\n   *\n   * PARAMETER ORDER: Standardized to (fontMetrics, data, options) for API consistency\n   *\n   * @param {FontMetrics} fontMetrics - Font metrics for positioning calculations\n   * @param {Object} tightBounds - Map of char → {left, top, width, height} within cells\n   * @param {Array<string>} characters - Sorted array of characters\n   * @param {Image|Canvas} sourceAtlasImage - Source Atlas image for extraction\n   * @param {number} pixelDensity - Pixel density multiplier for positioning calculations\n   * @param {number} cellHeight_PhysPx - Cell height in physical pixels (for distanceBetweenBottomAndBottomOfCanvas calculation)\n   * @returns {{atlasImage: AtlasImage, atlasPositioning: AtlasPositioning}}\n   */\n  static packTightAtlas(fontMetrics, tightBounds, characters, sourceAtlasImage, pixelDensity, cellHeight_PhysPx) {\n    // Calculate tight atlas dimensions (all in physical pixels)\n    let totalWidth_PhysPx = 0;\n    let maxHeight_PhysPx = 0;\n\n    for (const char of characters) {\n      if (tightBounds[char]) {\n        totalWidth_PhysPx += tightBounds[char].width;\n        maxHeight_PhysPx = Math.max(maxHeight_PhysPx, tightBounds[char].height);\n      }\n    }\n\n    // Create tight atlas canvas (explicit double invocation: get factory, call factory)\n    const tightCanvas = BitmapText.getCanvasFactory()();\n    tightCanvas.width = totalWidth_PhysPx;\n    tightCanvas.height = maxHeight_PhysPx;\n    const ctx = tightCanvas.getContext('2d');\n\n    // Initialize positioning data structure\n    let xInTightAtlas_PhysPx = 0;\n    const positioning = {\n      tightWidth: {},\n      tightHeight: {},\n      dx: {},\n      dy: {},\n      xInAtlas: {}\n    };\n\n    // Extract and pack each tight glyph\n    let cellX_PhysPx = 0;\n\n    for (const char of characters) {\n      const charMetrics = fontMetrics.getCharacterMetrics(char);\n\n      // Calculate cell width in physical pixels (CSS pixels * pixelDensity)\n      // MUST be calculated for ALL characters to track cellX_PhysPx correctly\n      const width_CssPx = AtlasCellDimensions.getWidth(charMetrics);\n      const cellWidth_PhysPx = Math.round(width_CssPx * pixelDensity);\n      // cellHeight_PhysPx is passed as parameter (already in physical pixels)\n\n      const bounds = tightBounds[char];\n      if (!bounds) {\n        // No visible pixels, but still need to advance cellX_PhysPx for next character\n        cellX_PhysPx += cellWidth_PhysPx;\n        continue;\n      }\n\n      // Extract tight glyph from original atlas\n      const tempCanvas = BitmapText.getCanvasFactory()();\n      tempCanvas.width = bounds.width;\n      tempCanvas.height = bounds.height;\n      const tempCtx = tempCanvas.getContext('2d');\n\n      // Copy tight region from atlas to temp canvas\n      const srcX_PhysPx = Math.floor(cellX_PhysPx + bounds.left);\n      const srcY_PhysPx = Math.floor(bounds.top);\n      const srcWidth_PhysPx = Math.floor(bounds.width);\n      const srcHeight_PhysPx = Math.floor(bounds.height);\n\n      tempCtx.drawImage(\n        sourceAtlasImage,\n        srcX_PhysPx, srcY_PhysPx,      // Source position in atlas (physical pixels)\n        srcWidth_PhysPx, srcHeight_PhysPx,  // Source dimensions (physical pixels)\n        0, 0,                           // Dest position in temp canvas\n        srcWidth_PhysPx, srcHeight_PhysPx   // Dest dimensions (physical pixels)\n      );\n\n      // Draw to tight atlas at sequential position\n      ctx.drawImage(tempCanvas, xInTightAtlas_PhysPx, 0);\n\n      // ═══════════════════════════════════════════════════════════════════════\n      // POSITIONING CALCULATION\n      // ═══════════════════════════════════════════════════════════════════════\n      //\n      // We need to calculate dx/dy offsets for rendering the tight glyph.\n      // These formulas MUST match AtlasPositioningFAB.js:91-92 exactly.\n      //\n      // Coordinate System Overview:\n      //\n      //   Atlas Cell (variable-width):        Tight Bounds:\n      //   ┌──────────────────────────┐\n      //   │ actualBoundingBox        │        ┌──────────┐\n      //   │ ┌──────────────────┐     │        │  ████    │  ← Minimal box\n      //   │ │                  │     │   →    │  ████    │     around pixels\n      //   │ │    ████          │     │        └──────────┘\n      //   │ │    ████          │     │\n      //   │ └──────────────────┘     │        dx = horizontal offset to align\n      //   │ fontBoundingBox          │        dy = vertical offset from baseline\n      //   └──────────────────────────┘\n      //     ↑                          ↑\n      //     cellX_PhysPx             cellX_PhysPx + cellWidth_PhysPx\n      //\n      // dx: Horizontal offset from rendering position to tight glyph position\n      //     Components:\n      //     - actualBoundingBoxLeft: Distance from text baseline to left edge of actual glyph\n      //     - bounds.left: Left edge of tight bounds within cell\n      //     Formula: -actualBoundingBoxLeft * pixelDensity + bounds.left\n      //\n      // dy: Vertical offset from baseline to top of tight glyph\n      //     Components:\n      //     - bounds.height: Height of tight glyph\n      //     - distanceBetweenBottomAndBottomOfCanvas: Gap below glyph (accounts for descenders)\n      //     - pixelDensity: Scale factor for high-DPI displays\n      //     Formula: -bounds.height - distanceBetweenBottomAndBottomOfCanvas + pixelDensity\n      //\n      //     The distanceBetweenBottomAndBottomOfCanvas accounts for descenders (like 'g', 'y')\n      //     and ensures proper vertical alignment relative to the text baseline.\n      //\n      // Note: pixelDensity is passed as a parameter (charMetrics only contains CSS pixel measurements)\n\n      // Calculate distance from bottom of tight bounds to bottom of character canvas\n      // This is used in the dy calculation\n      // Note: bounds.top + bounds.height - 1 gives the Y coordinate of the bottom pixel (like bottomRightCorner.y)\n      const distanceBetweenBottomAndBottomOfCanvas_PhysPx =\n        cellHeight_PhysPx - (bounds.top + bounds.height - 1) - 1;\n\n      // Store positioning data (all in physical pixels)\n      positioning.tightWidth[char] = bounds.width;    // Physical pixels\n      positioning.tightHeight[char] = bounds.height;  // Physical pixels\n      positioning.xInAtlas[char] = xInTightAtlas_PhysPx;  // Physical pixels\n\n      // EXACT dx formula from AtlasPositioningFAB.js:91 (physical pixels)\n      positioning.dx[char] =\n        - Math.round(charMetrics.actualBoundingBoxLeft) * pixelDensity\n        + bounds.left;\n\n      // EXACT dy formula from AtlasPositioningFAB.js:92 (physical pixels)\n      positioning.dy[char] =\n        - bounds.height\n        - distanceBetweenBottomAndBottomOfCanvas_PhysPx\n        + 1 * pixelDensity;\n\n      xInTightAtlas_PhysPx += bounds.width;\n      cellX_PhysPx += cellWidth_PhysPx;\n    }\n\n    // Create domain objects\n    const tightAtlasImage = new AtlasImage(tightCanvas);\n    const atlasPositioning = new AtlasPositioning(positioning);\n\n    console.debug(`TightAtlasReconstructor: Packed ${Object.keys(positioning.xInAtlas).length} glyphs into ${totalWidth_PhysPx}×${maxHeight_PhysPx} atlas`);\n\n    return { atlasImage: tightAtlasImage, atlasPositioning };\n  }\n}\n\n// ============================================================================\n// AtlasDataStore.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/AtlasDataStore.js\n// ============================================================================\n\n// AtlasDataStore - Core Runtime Static Class\n//\n// This is a CORE RUNTIME static class designed for minimal bundle size (~2-3KB).\n// It provides essential atlas data storage and retrieval for text rendering.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by AtlasDataStoreFAB for font assets building and generation\n// - Contains only atlas data structures and accessors needed at runtime\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Static class with private storage for AtlasData objects\n// - Uses Map-based storage for O(1) atlas lookups by font properties\n// - Provides the minimal atlas interface needed by BitmapText for glyph rendering\n// - Optimized for fast atlas access during text drawing\n// - Separate from FontMetricsStore to enable independent loading strategies\n//\n// SEPARATION RATIONALE:\n// - Atlas data contains both large binary images and positioning data loaded from atlas-*.js files\n// - Can be lazy-loaded on demand to optimize memory usage\n// - Independent of font metrics which are small and loaded upfront\n// - Aligns with file structure: atlas-*.js vs metrics-*.js\n//\n// For font assets building and generation capabilities, use AtlasDataStoreFAB.\nclass AtlasDataStore {\n  // Private static storage\n  // Keys are FontProperties.key strings for O(1) lookup\n  static #atlases = new Map(); // fontProperties.key → AtlasData\n\n  static getAtlasData(fontProperties) {\n    return AtlasDataStore.#atlases.get(fontProperties.key);\n  }\n\n  static setAtlasData(fontProperties, atlasData) {\n    // Only accept AtlasData instances\n    if (!(atlasData instanceof AtlasData)) {\n      throw new Error('AtlasDataStore.setAtlasData requires AtlasData instance (not raw images)');\n    }\n    AtlasDataStore.#atlases.set(fontProperties.key, atlasData);\n  }\n\n  // Helper method to check if an atlas is valid for rendering\n  static isValidAtlas(atlas) {\n    // Only work with AtlasData instances\n    if (!(atlas instanceof AtlasData)) {\n      return false;\n    }\n    return atlas.isValid();\n  }\n\n  // Get all available font properties keys\n  static getAvailableFonts() {\n    return Array.from(AtlasDataStore.#atlases.keys());\n  }\n\n  // Check if atlas exists for font properties\n  static hasAtlas(fontProperties) {\n    return AtlasDataStore.#atlases.has(fontProperties.key);\n  }\n\n  // Remove atlas for font properties\n  static deleteAtlas(fontProperties) {\n    return AtlasDataStore.#atlases.delete(fontProperties.key);\n  }\n\n  // Clear all atlases\n  static clear() {\n    AtlasDataStore.#atlases.clear();\n  }\n\n  // Get count of stored atlases\n  static size() {\n    return AtlasDataStore.#atlases.size;\n  }\n}\n\n// ============================================================================\n// FontMetricsStore.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontMetricsStore.js\n// ============================================================================\n\n// FontMetricsStore - Core Runtime Static Class\n//\n// This is a CORE RUNTIME static class designed for minimal bundle size (~2-3KB).\n// It provides essential font metrics storage and retrieval as a repository of FontMetrics instances.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Extended by FontMetricsStoreFAB for font assets building and generation\n// - Contains only FontMetrics instance storage and retrieval\n// - No font generation, validation, or optimization code\n//\n// ARCHITECTURE:\n// - Static class with private storage for FontMetrics instances\n// - Stores FontMetrics instances for fast O(1) lookup by font properties\n// - Simple repository pattern with get/set/has operations\n// - FontMetrics instances encapsulate all metrics data and behavior\n// - Separate from AtlasDataStore to enable independent loading strategies\n//\n// SEPARATION RATIONALE:\n// - Font metrics are small data loaded from metrics-*.js files\n// - Can be loaded upfront for immediate text measurement capabilities\n// - Independent of atlas images which are larger and can be lazy-loaded\n// - FontMetrics instances provide clean API without fontProperties parameter passing\n//\n// For font assets building and generation capabilities, use FontMetricsStoreFAB.\nclass FontMetricsStore {\n  // Private static storage\n  // Keys are FontProperties.key strings for O(1) FontMetrics instance lookup\n  static #fontMetrics = new Map(); // fontProperties.key → FontMetrics instance\n\n  /**\n   * Get FontMetrics instance for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {FontMetrics|undefined} FontMetrics instance or undefined if not found\n   */\n  static getFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.get(fontProperties.key);\n  }\n\n  /**\n   * Set FontMetrics instance for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @param {FontMetrics} fontMetrics - FontMetrics instance to store\n   */\n  static setFontMetrics(fontProperties, fontMetrics) {\n    FontMetricsStore.#fontMetrics.set(fontProperties.key, fontMetrics);\n  }\n\n  /**\n   * Check if FontMetrics exists for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if FontMetrics instance exists\n   */\n  static hasFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.has(fontProperties.key);\n  }\n\n  /**\n   * Remove FontMetrics for a font configuration\n   * @param {FontProperties} fontProperties - Font configuration\n   * @returns {boolean} True if FontMetrics was removed\n   */\n  static deleteFontMetrics(fontProperties) {\n    return FontMetricsStore.#fontMetrics.delete(fontProperties.key);\n  }\n\n  /**\n   * Get all available font configurations\n   * @returns {string[]} Array of fontProperties.key strings\n   */\n  static getAvailableFonts() {\n    return Array.from(FontMetricsStore.#fontMetrics.keys());\n  }\n\n  /**\n   * Clear all stored FontMetrics instances\n   */\n  static clear() {\n    FontMetricsStore.#fontMetrics.clear();\n  }\n\n  /**\n   * Get count of stored FontMetrics instances\n   * @returns {number} Number of stored font configurations\n   */\n  static size() {\n    return FontMetricsStore.#fontMetrics.size;\n  }\n}\n\n// ============================================================================\n// FontManifest.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontManifest.js\n// ============================================================================\n\n// FontManifest - Core Runtime Class\n//\n// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).\n// It provides centralized font registry management for test and development environments.\n//\n// DISTRIBUTION ROLE:\n// - Part of \"runtime-only\" distribution for production applications\n// - Manages available font IDs without polluting global namespace\n// - Provides clean API for font registry operations\n// - Designed for use in test-renderer and development tools\n//\n// ARCHITECTURE:\n// - Static-only class for singleton behavior\n// - Modern private fields for encapsulation\n// - Returns copies of arrays to prevent external modification\n// - Simple, focused API for font ID management\n//\n// This class replaces the global bitmapTextManifest variable and provides\n// better encapsulation and a cleaner API for managing font registrations.\nclass FontManifest {\n  // Private static field to store font IDs\n  static #fontIDs = [];\n\n  // Add one or more font IDs to the registry\n  // Accepts either a single string ID or an array of IDs\n  static addFontIDs(ids) {\n    // Handle both single ID and array inputs\n    const idsArray = Array.isArray(ids) ? ids : [ids];\n\n    // Add IDs, avoiding duplicates\n    for (const id of idsArray) {\n      if (typeof id === 'string' && !this.#fontIDs.includes(id)) {\n        this.#fontIDs.push(id);\n      }\n    }\n  }\n\n  // Get all registered font IDs\n  // Returns a shallow copy to prevent external modification\n  static allFontIDs() {\n    return [...this.#fontIDs];\n  }\n\n  // Check if a specific font ID is registered\n  static hasFontID(id) {\n    return this.#fontIDs.includes(id);\n  }\n\n  // Get the count of registered font IDs\n  static count() {\n    return this.#fontIDs.length;\n  }\n\n  // Clear all registered font IDs\n  // Useful for testing and resetting state\n  static clear() {\n    this.#fontIDs.length = 0;\n  }\n\n  // Get font IDs as a sorted array\n  // Useful for consistent iteration order\n  static allFontIDsSorted() {\n    return [...this.#fontIDs].sort();\n  }\n}\n// ============================================================================\n// FontLoaderBase.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/runtime/FontLoaderBase.js\n// ============================================================================\n\n// FontLoaderBase - Abstract Static Base Class for Font Loading\n//\n// This abstract static class provides the core font loading infrastructure\n// for BitmapText. It defines the public API and shared logic for font loading,\n// while platform-specific implementations (browser, Node.js) extend this class.\n//\n// DISTRIBUTION ROLE:\n// - Used by both browser and Node.js distributions\n// - Defines abstract methods implemented by platform-specific loaders\n// - Contains shared loading orchestration and atlas reconstruction logic\n//\n// ARCHITECTURE:\n// - Abstract static class (not instantiated)\n// - Extended by FontLoaderBrowser and FontLoaderNode\n// - Owns fontDirectory configuration (#fontDirectory private field)\n// - Works with BitmapText's internal stores (#fontMetrics, #atlasData)\n// - Uses Template Method Pattern for platform-specific operations\n// - BitmapText delegates fontDirectory get/set to FontLoader (this class owns what it uses)\n//\n// LOADING FLOW:\n// 1. loadFonts() orchestrates loading of multiple fonts\n// 2. loadMetricsFile() loads metrics (platform-specific)\n// 3. loadAtlasFile() loads atlas image (platform-specific)\n// 4. loadAtlasFromPackage() reconstructs atlas from image (shared)\n// 5. processPendingAtlas() handles async atlas/metrics loading (shared)\n\nclass FontLoaderBase {\n  // ============================================\n  // Shared Static Storage\n  // ============================================\n\n  // Temporary storage for atlas packages before reconstruction\n  static _tempAtlasPackages = {};\n\n  // Pending atlases waiting for metrics\n  static _pendingAtlases = new Map();\n\n  // Loading promises to prevent duplicate loads\n  static _loadingPromises = new Map();\n\n  // ============================================\n  // Configuration\n  // ============================================\n\n  /**\n   * Default font directory for all platforms\n   * @constant {string}\n   */\n  static DEFAULT_FONT_DIRECTORY = './font-assets/';\n\n  /**\n   * User-configured font directory override (null = use default)\n   * @private\n   */\n  static #fontDirectory = null;\n\n  /**\n   * Set font directory (overrides default)\n   * @param {string} path - Path to font assets directory\n   */\n  static setFontDirectory(path) {\n    FontLoaderBase.#fontDirectory = path;\n  }\n\n  /**\n   * Get font directory (returns override or default)\n   * @returns {string} Font directory path\n   */\n  static getFontDirectory() {\n    return FontLoaderBase.#fontDirectory ?? FontLoaderBase.DEFAULT_FONT_DIRECTORY;\n  }\n\n  /**\n   * Get default font directory (shared across all platforms)\n   * @deprecated Use getFontDirectory() instead\n   * @returns {string} Font directory path\n   */\n  static getDefaultFontDirectory() {\n    return FontLoaderBase.DEFAULT_FONT_DIRECTORY;\n  }\n\n  // ============================================\n  // Registration API (called by asset files)\n  // ============================================\n\n  /**\n   * Register font metrics from metrics-*.js file\n   * Called by self-registering metrics files\n   * @param {string} idString - Font ID string\n   * @param {Object} compactedData - Compacted metrics data\n   * @param {Object} bitmapTextClass - BitmapText class reference (for backward compatibility)\n   */\n  static registerMetrics(idString, compactedData, bitmapTextClass) {\n    if (typeof idString !== 'string') {\n      console.warn('FontLoader.registerMetrics: Invalid idString - must be string');\n      return;\n    }\n\n    if (typeof MetricsExpander === 'undefined') {\n      console.warn('FontLoader.registerMetrics: MetricsExpander not available');\n      return;\n    }\n\n    if (typeof FontProperties === 'undefined') {\n      console.warn('FontLoader.registerMetrics: FontProperties not available');\n      return;\n    }\n\n    const fontProperties = FontProperties.fromIDString(idString);\n    const fontMetrics = MetricsExpander.expand(compactedData);\n\n    // Store metrics directly in FontMetricsStore\n    FontMetricsStore.setFontMetrics(fontProperties, fontMetrics);\n\n    // Process any pending atlases that were waiting for these metrics\n    FontLoaderBase._processPendingAtlas(idString);\n  }\n\n  /**\n   * Register atlas from atlas-*.js file (base64 only, positioning reconstructed later)\n   * Called by self-registering atlas files\n   * @param {string} idString - Font ID string\n   * @param {string} base64Data - Base64-encoded atlas data\n   */\n  static registerAtlas(idString, base64Data) {\n    if (typeof idString !== 'string' || typeof base64Data !== 'string') {\n      console.warn('FontLoader.registerAtlas: Invalid arguments - idString and base64Data must be strings');\n      return;\n    }\n\n    FontLoaderBase._tempAtlasPackages[idString] = { base64Data };\n  }\n\n  // ============================================\n  // Public Loading API\n  // ============================================\n\n  /**\n   * Load a single font\n   * @param {string} idString - Font ID string\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when font is loaded\n   */\n  static async loadFont(idString, options, bitmapTextClass) {\n    return this.loadFonts([idString], options, bitmapTextClass);\n  }\n\n  /**\n   * Load multiple fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Function} [options.onProgress] - Progress callback (loaded, total)\n   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol\n   * @param {boolean} [options.loadMetrics] - Load metrics (default: true)\n   * @param {boolean} [options.loadAtlases] - Load atlases (default: true)\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when all fonts are loaded\n   */\n  static async loadFonts(idStrings, options = {}, bitmapTextClass) {\n    const {\n      onProgress = null,\n      isFileProtocol = false,\n      loadMetrics = true,\n      loadAtlases = true\n    } = options;\n\n    const filesPerFont = (loadMetrics ? 1 : 0) + (loadAtlases ? 1 : 0);\n    const totalFiles = idStrings.length * filesPerFont;\n    let loadedFiles = 0;\n\n    const reportProgress = () => {\n      if (onProgress) onProgress(loadedFiles, totalFiles);\n    };\n\n    for (const idString of idStrings) {\n      // Check if already loading\n      if (FontLoaderBase._loadingPromises.has(idString)) {\n        await FontLoaderBase._loadingPromises.get(idString);\n        continue;\n      }\n\n      const loadPromise = (async () => {\n        try {\n          if (loadMetrics) {\n            await this.loadMetricsFile(idString, bitmapTextClass);\n            loadedFiles++;\n            reportProgress();\n          }\n\n          if (loadAtlases) {\n            await this.loadAtlasFile(idString, isFileProtocol, bitmapTextClass);\n            loadedFiles++;\n            reportProgress();\n          }\n        } finally {\n          FontLoaderBase._loadingPromises.delete(idString);\n        }\n      })();\n\n      FontLoaderBase._loadingPromises.set(idString, loadPromise);\n      await loadPromise;\n    }\n  }\n\n  /**\n   * Load only metrics for fonts\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetrics(idStrings, options, bitmapTextClass) {\n    return this.loadFonts(idStrings, { ...options, loadAtlases: false }, bitmapTextClass);\n  }\n\n  /**\n   * Load only atlases for fonts (metrics must be loaded first)\n   * @param {Array<string>} idStrings - Array of font ID strings\n   * @param {Object} options - Loading options\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlases are loaded\n   */\n  static async loadAtlases(idStrings, options, bitmapTextClass) {\n    return this.loadFonts(idStrings, { ...options, loadMetrics: false }, bitmapTextClass);\n  }\n\n  // ============================================\n  // Platform-Specific Loading (Abstract Methods)\n  // ============================================\n\n  /**\n   * Load metrics file for a font\n   * @abstract Must be implemented by derived classes\n   * @param {string} idString - Font ID string\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetricsFile(idString, bitmapTextClass) {\n    throw new Error('FontLoaderBase.loadMetricsFile() must be implemented by derived class');\n  }\n\n  /**\n   * Load atlas file for a font\n   * @abstract Must be implemented by derived classes\n   * @param {string} idString - Font ID string\n   * @param {boolean} isFileProtocol - Whether using file:// protocol\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlas is loaded\n   */\n  static async loadAtlasFile(idString, isFileProtocol, bitmapTextClass) {\n    throw new Error('FontLoaderBase.loadAtlasFile() must be implemented by derived class');\n  }\n\n  // ============================================\n  // Shared Atlas Reconstruction Logic\n  // ============================================\n\n  /**\n   * Load atlas from package (image + metrics) and reconstruct positioning\n   * @param {string} idString - Font ID string\n   * @param {HTMLImageElement|HTMLCanvasElement} atlasImage - Atlas source image\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {boolean} True if atlas was reconstructed, false if pending metrics\n   */\n  static _loadAtlasFromPackage(idString, atlasImage, bitmapTextClass) {\n    const fontProperties = FontProperties.fromIDString(idString);\n\n    // Clean up temporary package storage\n    delete FontLoaderBase._tempAtlasPackages[idString];\n\n    // Get font metrics (required for reconstruction)\n    const fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);\n\n    if (!fontMetrics) {\n      // Store atlas for later reconstruction when metrics become available\n      FontLoaderBase._pendingAtlases.set(idString, {atlasImage, bitmapTextClass});\n      return false;\n    }\n\n    // Check if TightAtlasReconstructor is available\n    if (typeof TightAtlasReconstructor === 'undefined') {\n      throw new Error(`FontLoader: TightAtlasReconstructor required for font loading - not available for ${idString}`);\n    }\n\n    // Reconstruct tight atlas + positioning from Atlas image\n    const { atlasImage: tightAtlasImage, atlasPositioning } =\n      TightAtlasReconstructor.reconstructFromAtlas(fontMetrics, atlasImage);\n\n    // Create AtlasData instance\n    const atlasData = new AtlasData(tightAtlasImage, atlasPositioning);\n\n    // Store directly in AtlasDataStore\n    AtlasDataStore.setAtlasData(fontProperties, atlasData);\n\n    return true;\n  }\n\n  /**\n   * Process pending atlas that was waiting for metrics\n   * @param {string} idString - Font ID string\n   */\n  static _processPendingAtlas(idString) {\n    // Check if there's a pending atlas waiting for these metrics\n    if (!FontLoaderBase._pendingAtlases.has(idString)) {\n      return;\n    }\n\n    const {atlasImage, bitmapTextClass} = FontLoaderBase._pendingAtlases.get(idString);\n    FontLoaderBase._pendingAtlases.delete(idString);\n\n    // Try to load the atlas now that metrics are available\n    FontLoaderBase._loadAtlasFromPackage(idString, atlasImage, bitmapTextClass);\n  }\n}\n\n// ============================================================================\n// QOIDecode.js - Source: /Users/davidedellacasa/code/BitmapText.js/lib/QOIDecode.js\n// ============================================================================\n\n/**\n * Decode a QOI file given as an ArrayBuffer.\n *\n * @param {ArrayBuffer} arrayBuffer ArrayBuffer containing the QOI file.\n * @param {int|null} [byteOffset] Offset to the start of the QOI file in arrayBuffer\n * @param {int|null} [byteLength] Length of the QOI file in bytes\n * @param {int|null} [outputChannels] Number of channels to include in the decoded array\n *\n * @returns {{channels: number, data: Uint8Array, colorspace: number, width: number, error: boolean, height: number}}\n */\nfunction QOIDecode (arrayBuffer, byteOffset, byteLength, outputChannels) {\n    if (typeof byteOffset === 'undefined' || byteOffset === null) {\n        byteOffset = 0;\n    }\n\n    if (typeof byteLength === 'undefined' || byteLength === null) {\n        byteLength = arrayBuffer.byteLength - byteOffset;\n    }\n\n    const uint8 = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n\n    const magic1 = uint8[0];\n    const magic2 = uint8[1];\n    const magic3 = uint8[2];\n    const magic4 = uint8[3];\n\n    const width = ((uint8[4] << 24) | (uint8[5] << 16) | (uint8[6] << 8) | uint8[7]) >>> 0;\n    const height = ((uint8[8] << 24) | (uint8[9] << 16) | (uint8[10] << 8) | uint8[11]) >>> 0;\n\n    const channels = uint8[12];\n    const colorspace = uint8[13];\n\n    if (typeof outputChannels === 'undefined' || outputChannels === null) {\n        outputChannels = channels;\n    }\n\n    if (magic1 !== 0x71 || magic2 !== 0x6F || magic3 !== 0x69 || magic4 !== 0x66) {\n        throw new Error('QOI.decode: The signature of the QOI file is invalid');\n    }\n\n    if (channels < 3 || channels > 4) {\n        throw new Error('QOI.decode: The number of channels declared in the file is invalid');\n    }\n\n    if (colorspace > 1) {\n        throw new Error('QOI.decode: The colorspace declared in the file is invalid');\n    }\n\n    if (outputChannels < 3 || outputChannels > 4) {\n        throw new Error('QOI.decode: The number of channels for the output is invalid');\n    }\n\n    const pixelLength = width * height * outputChannels;\n    const result = new Uint8Array(pixelLength);\n\n    let arrayPosition = 14;\n\n    const index = new Uint8Array(64 * 4);\n    let indexPosition = 0;\n\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    let alpha = 255;\n\n    const chunksLength = byteLength - 8;\n\n    let run = 0;\n    let pixelPosition = 0;\n\n    for (; pixelPosition < pixelLength && arrayPosition < byteLength - 4; pixelPosition += outputChannels) {\n        if (run > 0) {\n            run--;\n        } else if (arrayPosition < chunksLength) {\n            const byte1 = uint8[arrayPosition++];\n\n            if (byte1 === 0b11111110) { // QOI_OP_RGB\n                red = uint8[arrayPosition++];\n                green = uint8[arrayPosition++];\n                blue = uint8[arrayPosition++];\n            } else if (byte1 === 0b11111111) { // QOI_OP_RGBA\n                red = uint8[arrayPosition++];\n                green = uint8[arrayPosition++];\n                blue = uint8[arrayPosition++];\n                alpha = uint8[arrayPosition++];\n            } else if ((byte1 & 0b11000000) === 0b00000000) { // QOI_OP_INDEX\n                red = index[byte1 * 4];\n                green = index[byte1 * 4 + 1];\n                blue = index[byte1 * 4 + 2];\n                alpha = index[byte1 * 4 + 3];\n            } else if ((byte1 & 0b11000000) === 0b01000000) { // QOI_OP_DIFF\n                red += ((byte1 >> 4) & 0b00000011) - 2;\n                green += ((byte1 >> 2) & 0b00000011) - 2;\n                blue += (byte1 & 0b00000011) - 2;\n\n                // handle wraparound\n                red = (red + 256) % 256;\n                green = (green + 256) % 256;\n                blue = (blue + 256) % 256;\n            } else if ((byte1 & 0b11000000) === 0b10000000) { // QOI_OP_LUMA\n                const byte2 = uint8[arrayPosition++];\n                const greenDiff = (byte1 & 0b00111111) - 32;\n                const redDiff = greenDiff + ((byte2 >> 4) & 0b00001111) - 8;\n                const blueDiff = greenDiff + (byte2 & 0b00001111) - 8;\n\n                // handle wraparound\n                red = (red + redDiff + 256) % 256;\n                green = (green + greenDiff + 256) % 256;\n                blue = (blue + blueDiff + 256) % 256;\n            } else if ((byte1 & 0b11000000) === 0b11000000) { // QOI_OP_RUN\n                run = byte1 & 0b00111111;\n            }\n\n            indexPosition = ((red * 3 + green * 5 + blue * 7 + alpha * 11) % 64) * 4;\n            index[indexPosition] = red;\n            index[indexPosition + 1] = green;\n            index[indexPosition + 2] = blue;\n            index[indexPosition + 3] = alpha;\n        }\n\n        if (outputChannels === 4) { // RGBA\n            result[pixelPosition] = red;\n            result[pixelPosition + 1] = green;\n            result[pixelPosition + 2] = blue;\n            result[pixelPosition + 3] = alpha;\n        } else { // RGB\n            result[pixelPosition] = red;\n            result[pixelPosition + 1] = green;\n            result[pixelPosition + 2] = blue;\n        }\n    }\n\n    if (pixelPosition < pixelLength) {\n        throw new Error('QOI.decode: Incomplete image');\n    }\n\n    // checking the 00000001 padding is not required, as per specs\n\n    return {\n        width: width,\n        height: height,\n        colorspace: colorspace,\n        channels: outputChannels,\n        data: result\n    };\n}\n// ============================================================================\n// FontLoader-node.js - Source: /Users/davidedellacasa/code/BitmapText.js/src/platform/FontLoader-node.js\n// ============================================================================\n\n// FontLoader - Node.js-Specific Font Loader\n//\n// This static class extends FontLoaderBase to provide Node.js-specific\n// font loading implementation using Node.js APIs (fs, path, require).\n//\n// DISTRIBUTION ROLE:\n// - Only included in Node.js distributions\n// - Excluded from browser bundles via build scripts\n// - Uses Node.js-specific APIs (fs, path, eval)\n//\n// ARCHITECTURE:\n// - Static class extending FontLoaderBase\n// - Implements abstract methods for Node.js environment\n// - Uses fs.readFileSync for metrics and atlas loading\n// - Uses eval() to execute metrics registration code\n// - Uses QOIDecode for atlas decompression\n//\n// LOADING STRATEGIES:\n// - Metrics: fs.readFileSync + eval()\n// - Atlas: fs.readFileSync QOI file + QOIDecode + canvas creation\n\nclass FontLoader extends FontLoaderBase {\n\n  // ============================================\n  // File Name Constants (from BitmapText)\n  // ============================================\n\n  static METRICS_PREFIX = 'metrics-';\n  static ATLAS_PREFIX = 'atlas-';\n  static JS_EXTENSION = '.js';\n\n  // ============================================\n  // Node.js-Specific Loading Implementation\n  // ============================================\n\n  /**\n   * Load metrics file via fs.readFileSync + eval\n   * @param {string} idString - Font ID string\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when metrics are loaded\n   */\n  static async loadMetricsFile(idString, bitmapTextClass) {\n    if (typeof require === 'undefined') {\n      throw new Error('FontLoader.loadMetricsFile requires Node.js environment');\n    }\n\n    const fs = require('fs');\n    const path = require('path');\n\n    const fontDirectory = FontLoaderBase.getFontDirectory();\n    const metricsPath = path.resolve(fontDirectory, `${FontLoader.METRICS_PREFIX}${idString}${FontLoader.JS_EXTENSION}`);\n\n    try {\n      const metricsCode = fs.readFileSync(metricsPath, 'utf8');\n      // Execute with BitmapText in scope\n      // The metrics file will call BitmapText.registerMetrics()\n      eval(metricsCode);\n    } catch (error) {\n      console.warn(`Metrics file not found: ${metricsPath}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Load atlas file via fs.readFileSync + QOIDecode\n   * @param {string} idString - Font ID string\n   * @param {boolean} isFileProtocol - Not used in Node.js\n   * @param {Object} bitmapTextClass - BitmapText class reference\n   * @returns {Promise} Resolves when atlas is loaded\n   */\n  static async loadAtlasFile(idString, isFileProtocol, bitmapTextClass) {\n    if (typeof require === 'undefined') {\n      throw new Error('FontLoader.loadAtlasFile requires Node.js environment');\n    }\n\n    const fs = require('fs');\n    const path = require('path');\n\n    const fontDirectory = FontLoaderBase.getFontDirectory();\n    const atlasPath = path.resolve(fontDirectory, `${FontLoader.ATLAS_PREFIX}${idString}-qoi${FontLoader.JS_EXTENSION}`);\n\n    try {\n      const atlasCode = fs.readFileSync(atlasPath, 'utf8');\n      // Execute with BitmapText in scope to call registerAtlas\n      // The atlas file will call BitmapText.registerAtlas()\n      eval(atlasCode);\n\n      // Now reconstruct the atlas\n      const pkg = FontLoaderBase._tempAtlasPackages[idString];\n      if (pkg && pkg.base64Data) {\n        // Decode QOI\n        if (typeof QOIDecode === 'undefined') {\n          throw new Error('FontLoader: QOIDecode not available - required for atlas loading');\n        }\n\n        const qoiData = Uint8Array.from(atob(pkg.base64Data), c => c.charCodeAt(0));\n        const decoded = QOIDecode(qoiData.buffer);\n\n        // Create canvas and draw (explicit double invocation: get factory, call factory)\n        const canvas = bitmapTextClass.getCanvasFactory()();\n        canvas.width = decoded.width;\n        canvas.height = decoded.height;\n        const ctx = canvas.getContext('2d');\n        const imageData = ctx.createImageData(decoded.width, decoded.height);\n        imageData.data.set(decoded.data);\n        ctx.putImageData(imageData, 0, 0);\n\n        // Reconstruct atlas\n        FontLoaderBase._loadAtlasFromPackage(idString, canvas, bitmapTextClass);\n      }\n    } catch (error) {\n      console.warn(`Atlas loading error for ${atlasPath}: ${error.message}`);\n      console.warn('Will use placeholder rectangles');\n    }\n  }\n}\n\n// ============================================================================\n// GLOBAL EXPORTS (Node.js)\n// ============================================================================\n// Expose classes globally for Node.js require() usage\nif (typeof global !== 'undefined') {\n  global.StatusCode = StatusCode;\n  global.SUCCESS_STATUS = SUCCESS_STATUS;\n  global.createErrorStatus = createErrorStatus;\n  global.getStatusDescription = getStatusDescription;\n  global.FontProperties = FontProperties;\n  global.TextProperties = TextProperties;\n  global.FontMetrics = FontMetrics;\n  global.BitmapText = BitmapText;\n  global.AtlasDataStore = AtlasDataStore;\n  global.FontMetricsStore = FontMetricsStore;\n  global.FontManifest = FontManifest;\n  global.QOIDecode = QOIDecode;\n}\n"],"mappings":"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","ignoreList":[]}