<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BitmapText.js Browser Profiling Suite</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .section {
      background: white;
      padding: 20px;
      margin-bottom: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .instructions {
      background: #e3f2fd;
      padding: 15px;
      border-radius: 4px;
      border-left: 4px solid #2196f3;
      margin: 15px 0;
    }
    .warning {
      background: #fff3e0;
      padding: 15px;
      border-radius: 4px;
      border-left: 4px solid #ff9800;
      margin: 15px 0;
    }
    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }
    button:hover {
      background: #5568d3;
    }
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    .results {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 13px;
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 15px;
      border-radius: 4px;
      max-height: 600px;
      overflow-y: auto;
    }
    .metric {
      margin: 10px 0;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    .metric-label {
      font-weight: bold;
      color: #666;
    }
    .metric-value {
      font-size: 1.2em;
      color: #333;
    }
    .status {
      padding: 10px;
      border-radius: 4px;
      margin: 10px 0;
    }
    .status.active {
      background: #e3f2fd;
      color: #1976d2;
    }
    .status.complete {
      background: #e8f5e9;
      color: #388e3c;
    }
    ol li {
      margin: 10px 0;
    }
    code {
      background: #f5f5f5;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>üî¨ BitmapText.js Browser Profiling Suite</h1>
    <p>Comprehensive performance profiling with Chrome DevTools integration</p>
  </div>

  <div class="section">
    <h2>üìã Manual Profiling Instructions</h2>

    <div class="instructions">
      <strong>How to Profile with Chrome DevTools:</strong>
      <ol>
        <li>Open Chrome DevTools (F12 or Cmd+Option+I on Mac)</li>
        <li>Go to the <strong>"Performance"</strong> tab</li>
        <li>Click the record button (‚è∫) to start recording</li>
        <li>Click one of the benchmark buttons below</li>
        <li>Wait for the benchmark to complete</li>
        <li>Click the stop button (‚èπ) in DevTools to stop recording</li>
        <li>Analyze the flame chart and identify hot functions</li>
        <li>Export the profile: Click the download button and save as .json</li>
      </ol>
    </div>

    <div class="warning">
      <strong>‚ö†Ô∏è Important:</strong> For accurate profiling, close other tabs and applications.
      Run each benchmark 2-3 times and compare results.
    </div>
  </div>

  <div class="section">
    <h2>üéØ Quick Profile Benchmarks</h2>
    <p>Click these buttons to run benchmarks with built-in performance instrumentation:</p>

    <div>
      <button id="profile-measurement">Profile Measurement Benchmark</button>
      <button id="profile-rendering">Profile Rendering Benchmark</button>
      <button id="clear-results">Clear Results</button>
    </div>

    <div id="status" class="status"></div>
    <div id="results" class="results" style="display: none;"></div>
  </div>

  <div class="section">
    <h2>üîó External Benchmark Links</h2>
    <p>Open these in new tabs for full benchmark runs:</p>
    <ul>
      <li><a href="../../perf/browser/measurement-benchmark.html" target="_blank">Measurement Benchmark (Unbundled)</a></li>
      <li><a href="../../perf/browser/rendering-benchmark.html" target="_blank">Rendering Benchmark (Unbundled)</a></li>
    </ul>
  </div>

  <div class="section">
    <h2>üìä Profiling Data Export</h2>
    <p>After running benchmarks, export the collected data:</p>
    <button id="export-data">Export Profiling Data (JSON)</button>
  </div>

  <!-- Load BitmapText.js for inline benchmarking -->
  <script src="../../src/runtime/StatusCode.js"></script>
  <script src="../../src/runtime/FontProperties.js"></script>
  <script src="../../src/runtime/TextProperties.js"></script>
  <script src="../../src/runtime/FontMetrics.js"></script>
  <script src="../../src/runtime/InterpolatedFontMetrics.js"></script>
  <script src="../../src/builder/MetricsExpander.js"></script>
  <script src="../../src/runtime/AtlasPositioning.js"></script>
  <script src="../../src/runtime/AtlasImage.js"></script>
  <script src="../../src/runtime/AtlasData.js"></script>
  <script src="../../src/builder/AtlasReconstructionUtils.js"></script>
  <script src="../../src/utils/AtlasCellDimensions.js"></script>
  <script src="../../src/runtime/TightAtlasReconstructor.js"></script>
  <script src="../../src/runtime/AtlasDataStore.js"></script>
  <script src="../../src/runtime/FontMetricsStore.js"></script>
  <script src="../../src/runtime/FontLoaderBase.js"></script>
  <script src="../../src/platform/FontLoader-browser.js"></script>
  <script src="../../src/runtime/BitmapText.js"></script>
  <script src="../../src/shared/test-data.js"></script>

  <script>
    // Configure BitmapText
    BitmapText.setFontDirectory('../../font-assets/');

    const statusDiv = document.getElementById('status');
    const resultsDiv = document.getElementById('results');
    const profileData = {
      browserInfo: {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        cores: navigator.hardwareConcurrency
      },
      measurements: [],
      renderings: []
    };

    function updateStatus(message, type = 'active') {
      statusDiv.textContent = message;
      statusDiv.className = `status ${type}`;
    }

    function appendResults(text) {
      resultsDiv.style.display = 'block';
      resultsDiv.textContent += text + '\n';
      resultsDiv.scrollTop = resultsDiv.scrollHeight;
    }

    function clearResults() {
      resultsDiv.textContent = '';
      resultsDiv.style.display = 'none';
    }

    // Detailed performance measurement with User Timing API
    function measureWithTiming(name, fn) {
      performance.mark(`${name}-start`);
      fn();
      performance.mark(`${name}-end`);
      performance.measure(name, `${name}-start`, `${name}-end`);

      const measure = performance.getEntriesByName(name)[0];
      return measure.duration;
    }

    // Measurement Benchmark
    async function runMeasurementProfile() {
      clearResults();
      updateStatus('Running measurement benchmark...', 'active');
      appendResults('='.repeat(60));
      appendResults('Measurement Benchmark Profile');
      appendResults('='.repeat(60));
      appendResults('');

      try {
        // Load font
        appendResults('Loading font...');
        const fontProperties = new FontProperties(1, 'Arial', 'normal', 'normal', 19);
        const loadStart = performance.now();
        await BitmapText.loadFont(fontProperties.idString, { isFileProtocol: true });
        const loadTime = performance.now() - loadStart;
        appendResults(`‚úÖ Font loaded in ${loadTime.toFixed(2)}ms\n`);

        const textProps = new TextProperties({ isKerningEnabled: true });
        const results = {
          fontLoading: loadTime,
          tests: []
        };

        // Test different text lengths
        appendResults('Testing text length scaling...');
        const lengths = [5, 10, 25, 50, 100, 250, 500];

        for (const length of lengths) {
          const text = TEST_LONG_LINE.substring(0, length);
          const iterations = 1000;

          const testName = `measure-${length}chars`;
          const start = performance.now();

          for (let i = 0; i < iterations; i++) {
            BitmapText.measureText(text, fontProperties, textProps);
          }

          const elapsed = performance.now() - start;
          const avgTime = elapsed / iterations;

          appendResults(`  ${length} chars: ${avgTime.toFixed(3)}ms avg (${iterations} iterations)`);

          results.tests.push({
            textLength: length,
            iterations,
            totalTime: elapsed,
            avgTime,
            opsPerSec: 1000 / avgTime
          });
        }

        // Kerning comparison
        appendResults('\nTesting kerning overhead...');
        const testText = TEST_LONG_LINE.substring(0, 50);
        const textPropsNoKerning = new TextProperties({ isKerningEnabled: false });
        const iterations = 1000;

        const kerningOnStart = performance.now();
        for (let i = 0; i < iterations; i++) {
          BitmapText.measureText(testText, fontProperties, textProps);
        }
        const kerningOnTime = performance.now() - kerningOnStart;

        const kerningOffStart = performance.now();
        for (let i = 0; i < iterations; i++) {
          BitmapText.measureText(testText, fontProperties, textPropsNoKerning);
        }
        const kerningOffTime = performance.now() - kerningOffStart;

        const overhead = ((kerningOnTime - kerningOffTime) / kerningOffTime * 100).toFixed(1);

        appendResults(`  Kerning ON:  ${kerningOnTime.toFixed(2)}ms total`);
        appendResults(`  Kerning OFF: ${kerningOffTime.toFixed(2)}ms total`);
        appendResults(`  Overhead: ${overhead}%`);

        results.kerningTest = {
          kerningOn: kerningOnTime,
          kerningOff: kerningOffTime,
          overhead: parseFloat(overhead)
        };

        profileData.measurements.push({
          timestamp: new Date().toISOString(),
          results
        });

        appendResults('\n‚úÖ Measurement profiling complete!');
        updateStatus('Measurement profiling complete', 'complete');

      } catch (error) {
        appendResults(`\n‚ùå Error: ${error.message}`);
        updateStatus('Error during profiling', 'active');
      }
    }

    // Rendering Benchmark
    async function runRenderingProfile() {
      clearResults();
      updateStatus('Running rendering benchmark...', 'active');
      appendResults('='.repeat(60));
      appendResults('Rendering Benchmark Profile');
      appendResults('='.repeat(60));
      appendResults('');

      try {
        // Load font
        appendResults('Loading font...');
        const fontProperties = new FontProperties(1, 'Arial', 'normal', 'normal', 19);
        const loadStart = performance.now();
        await BitmapText.loadFont(fontProperties.idString, { isFileProtocol: true });
        const loadTime = performance.now() - loadStart;
        appendResults(`‚úÖ Font loaded in ${loadTime.toFixed(2)}ms\n`);

        const canvas = document.createElement('canvas');
        canvas.width = 1200;
        canvas.height = 800;
        const ctx = canvas.getContext('2d');

        const textProperties = new TextProperties({
          textColor: '#000000',
          textBaseline: 'top',
          textAlign: 'left',
          kerning: true
        });

        const results = {
          fontLoading: loadTime,
          tests: []
        };

        // Test different block counts
        appendResults('Testing rendering with different block counts...');
        const blockCounts = [1, 5, 10, 25, 50];

        for (const blockCount of blockCounts) {
          const iterations = 10;

          const start = performance.now();

          for (let iter = 0; iter < iterations; iter++) {
            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Render blocks
            let yOffset = 10;
            const lineHeight = 25;
            const blockHeight = TEST_BLOCK_5_LINES.length * lineHeight;

            for (let i = 0; i < blockCount; i++) {
              TEST_BLOCK_5_LINES.forEach((line, lineIndex) => {
                const y = yOffset + (lineIndex * lineHeight);
                BitmapText.drawTextFromAtlas(ctx, line, 10, y, fontProperties, textProperties);
              });
              yOffset += blockHeight + 10;
              if (yOffset > canvas.height - blockHeight) {
                yOffset = 10;
              }
            }
          }

          const elapsed = performance.now() - start;
          const avgTime = elapsed / iterations;

          appendResults(`  ${blockCount} blocks: ${avgTime.toFixed(2)}ms avg (${iterations} iterations)`);

          results.tests.push({
            blockCount,
            iterations,
            totalTime: elapsed,
            avgTime,
            fps: 1000 / avgTime
          });
        }

        profileData.renderings.push({
          timestamp: new Date().toISOString(),
          results
        });

        appendResults('\n‚úÖ Rendering profiling complete!');
        updateStatus('Rendering profiling complete', 'complete');

      } catch (error) {
        appendResults(`\n‚ùå Error: ${error.message}`);
        updateStatus('Error during profiling', 'active');
      }
    }

    // Export data
    function exportData() {
      const dataStr = JSON.stringify(profileData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `browser-profile-data-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      updateStatus('Data exported successfully', 'complete');
    }

    // Event listeners
    document.getElementById('profile-measurement').addEventListener('click', runMeasurementProfile);
    document.getElementById('profile-rendering').addEventListener('click', runRenderingProfile);
    document.getElementById('clear-results').addEventListener('click', clearResults);
    document.getElementById('export-data').addEventListener('click', exportData);
  </script>
</body>
</html>
