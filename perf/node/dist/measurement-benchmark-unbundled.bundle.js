#!/usr/bin/env node

/**
 * ⚠️  THIS IS A BUNDLED/BUILT FILE - DO NOT EDIT ⚠️
 *
 * BitmapText.js Measurement Performance Benchmark - Unbundled Version
 *
 * This file is automatically generated by concatenating multiple source files.
 * Tests measureText() performance with all source files concatenated.
 *
 * Usage:
 *   node perf/node/dist/measurement-benchmark-unbundled.bundle.js
 *
 * Output:
 *   JSON results to stdout
 *
 * Generated by: scripts/build-measurement-benchmark.sh
 */

// ============================================================================
// MINIMAL CANVAS MOCK
// ============================================================================
//
// This module provides a lightweight Canvas API implementation for Node.js
// environments where node-canvas is not available or desired. It implements
// only the subset of Canvas API methods required by BitmapText.js.
//
// DISTRIBUTION ROLE:
// - Only included in Node.js distributions
// - Excluded from browser bundles via build scripts
// - Used as fallback when node-canvas is unavailable
//
// ARCHITECTURE:
// - Three classes: Canvas, Context2D, and Image
// - Pure JavaScript pixel manipulation using Uint8ClampedArray
// - No external dependencies (no node-canvas, no Sharp, no Jimp)
// - Implements minimal Canvas API surface needed for font rendering
//
// SUPPORTED CANVAS API SUBSET:
// - Canvas: width, height properties, getContext('2d')
// - Context2D: fillStyle, globalCompositeOperation, fillRect, clearRect,
//   drawImage, createImageData, putImageData, getImageData
// - Image: width, height, data properties
//
// LIMITATIONS COMPARED TO REAL CANVAS:
// - No anti-aliasing or bilinear filtering (nearest-neighbor only)
// - Limited color format support (hex colors and named 'black'/'white')
// - No text rendering (fillText is stub)
// - No path operations (moveTo, lineTo, stroke, etc.)
// - No gradients or patterns
// - Only 'source-over' and 'source-in' composite operations
// - No image format encoding (no PNG/JPEG output)
// - drawImage supports only 3-argument, 5-argument, and 9-argument forms
//
// PERFORMANCE CONSIDERATIONS:
// - Pure JavaScript pixel operations are slower than native implementations
// - Best suited for small images and simple operations
// - For production Node.js use, prefer node-canvas when available

// ============================================
// Canvas Class - Minimal Canvas Element Mock
// ============================================

/**
 * Canvas - Minimal HTML Canvas element implementation
 *
 * Provides a basic canvas with width/height properties and pixel buffer.
 * The pixel buffer is a Uint8ClampedArray in RGBA format (4 bytes per pixel).
 *
 * @class Canvas
 */
class Canvas {
  constructor() {
    this._width = 0;
    this._height = 0;
    this.data = null;
  }
  
  get width() { return this._width; }
  set width(w) {
    this._width = w;
    this._updateBuffer();
  }
  
  get height() { return this._height; }
  set height(h) {
    this._height = h;
    this._updateBuffer();
  }
  
  /**
   * Update internal pixel buffer when dimensions change
   * @private
   */
  _updateBuffer() {
    if (this._width > 0 && this._height > 0) {
      this.data = new Uint8ClampedArray(this._width * this._height * 4);
    }
  }

  /**
   * Get rendering context (only '2d' is supported)
   * @param {string} type - Context type ('2d' is the only supported value)
   * @returns {Context2D|null} 2D rendering context or null if unsupported type
   */
  getContext(type) {
    if (type === '2d') {
      return new Context2D(this);
    }
    return null;
  }
}

// ============================================
// Context2D Class - Canvas 2D Rendering Context
// ============================================

/**
 * Context2D - Minimal CanvasRenderingContext2D implementation
 *
 * Provides basic 2D drawing operations for font rendering. Supports
 * rectangular operations, image drawing, and pixel data manipulation.
 * Does not support paths, text rendering, or advanced compositing.
 *
 * @class Context2D
 */
class Context2D {
  constructor(canvas) {
    this.canvas = canvas;
    this.fillStyle = '#000000';
    this.globalCompositeOperation = 'source-over';

    // Transform stack for save/restore (minimal implementation)
    this._stateStack = [];
  }

  // ============================================
  // Transform Operations (Minimal Implementation)
  // ============================================

  /**
   * Save current context state
   *
   * In full Canvas API, this saves transform, fill style, etc.
   * For canvas-mock, we only save fillStyle and globalCompositeOperation
   * since we don't actually use transforms for drawing.
   */
  save() {
    this._stateStack.push({
      fillStyle: this.fillStyle,
      globalCompositeOperation: this.globalCompositeOperation
    });
  }

  /**
   * Restore previously saved context state
   *
   * Restores the most recently saved state from the stack.
   */
  restore() {
    if (this._stateStack.length > 0) {
      const state = this._stateStack.pop();
      this.fillStyle = state.fillStyle;
      this.globalCompositeOperation = state.globalCompositeOperation;
    }
  }

  /**
   * Set transform matrix (no-op in canvas-mock)
   *
   * Canvas-mock uses direct pixel coordinate operations without transforms.
   * This method exists for API compatibility with BitmapText's transform reset,
   * but does not actually modify drawing behavior.
   *
   * @param {number} a - Transform matrix parameter (ignored)
   * @param {number} b - Transform matrix parameter (ignored)
   * @param {number} c - Transform matrix parameter (ignored)
   * @param {number} d - Transform matrix parameter (ignored)
   * @param {number} e - Transform matrix parameter (ignored)
   * @param {number} f - Transform matrix parameter (ignored)
   */
  setTransform(a, b, c, d, e, f) {
    // No-op: canvas-mock doesn't implement transforms
    // Drawing operations use direct pixel coordinates regardless of transform state
  }

  // ============================================
  // Rectangle Operations
  // ============================================

  /**
   * Clear a rectangular area to transparent black
   * @param {number} x - X coordinate of rectangle top-left corner
   * @param {number} y - Y coordinate of rectangle top-left corner
   * @param {number} w - Rectangle width
   * @param {number} h - Rectangle height
   */
  clearRect(x, y, w, h) {
    if (!this.canvas.data) return;
    
    const data = this.canvas.data;
    const canvasWidth = this.canvas.width;
    
    for (let py = Math.max(0, y); py < Math.min(this.canvas.height, y + h); py++) {
      for (let px = Math.max(0, x); px < Math.min(canvasWidth, x + w); px++) {
        const i = (py * canvasWidth + px) * 4;
        data[i] = data[i+1] = data[i+2] = data[i+3] = 0;
      }
    }
  }

  /**
   * Fill a rectangular area with the current fillStyle
   *
   * Supports two composite operations:
   * - 'source-over': Normal fill (replaces pixels with fillStyle)
   * - 'source-in': Preserve alpha channel, only change RGB channels
   *                (used for colorizing glyph masks)
   *
   * @param {number} x - X coordinate of rectangle top-left corner
   * @param {number} y - Y coordinate of rectangle top-left corner
   * @param {number} w - Rectangle width
   * @param {number} h - Rectangle height
   */
  fillRect(x, y, w, h) {
    if (!this.canvas.data) return;

    const data = this.canvas.data;
    const canvasWidth = this.canvas.width;
    const [r, g, b] = this._parseColor(this.fillStyle);

    // Canvas coordinates must be integers (callers should round before calling)
    // Clamp to canvas bounds
    const x0 = Math.max(0, x);
    const y0 = Math.max(0, y);
    const x1 = Math.min(canvasWidth, x + w);
    const y1 = Math.min(this.canvas.height, y + h);

    for (let py = y0; py < y1; py++) {
      for (let px = x0; px < x1; px++) {
        const i = (py * canvasWidth + px) * 4;

        if (this.globalCompositeOperation === 'source-in') {
          // 'source-in' composite operation: Only fill where destination alpha > 0
          // This preserves the alpha channel (glyph shape) while changing the color.
          // Used by BitmapText to colorize white glyph masks with desired text color.
          if (data[i+3] > 0) {
            data[i] = r;
            data[i+1] = g;
            data[i+2] = b;
            // Keep existing alpha value (don't modify data[i+3])
          }
        } else {
          // 'source-over': Normal fill operation (default)
          data[i] = r;
          data[i+1] = g;
          data[i+2] = b;
          data[i+3] = 255;
        }
      }
    }
  }

  // ============================================
  // Composite Operation Property
  // ============================================

  /**
   * Set global composite operation (getter/setter handled by direct property access)
   *
   * Supported operations:
   * - 'source-over': Default - new pixels replace old pixels
   * - 'source-in': New pixels only drawn where destination alpha > 0,
   *                preserving destination alpha (used for colorization)
   *
   * @type {string}
   */
  // Note: globalCompositeOperation is set directly as a property in constructor

  // ============================================
  // Image Drawing
  // ============================================

  /**
   * Draw an image onto the canvas with optional scaling and clipping
   *
   * Supports three call signatures:
   * 1. drawImage(image, dx, dy) - Draw at position without scaling
   * 2. drawImage(image, dx, dy, dw, dh) - Draw scaled to fit rectangle
   * 3. drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) - Draw clipped source region
   *
   * Uses nearest-neighbor sampling for scaling (no bilinear filtering).
   * This is faster but produces pixelated results when scaling.
   * Sufficient for bitmap font rendering where glyphs are drawn at original size.
   *
   * @param {Image|Canvas} image - Source image or canvas
   * @param {number} sx - Source X (or dx in 3-arg form)
   * @param {number} sy - Source Y (or dy in 3-arg form)
   * @param {number} sw - Source width (or dw in 5-arg form)
   * @param {number} sh - Source height (or dh in 5-arg form)
   * @param {number} dx - Destination X
   * @param {number} dy - Destination Y
   * @param {number} dw - Destination width
   * @param {number} dh - Destination height
   */
  drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (!this.canvas.data || !image.data) return;
    
    // Handle different call signatures by reassigning parameters
    // JavaScript allows flexible parameter handling through arguments.length
    if (arguments.length === 5) {
      // 5-argument form: drawImage(image, dx, dy, dw, dh)
      // Parameters are shifted: sx->dw, sy->dh, sw->dx, sh->dy
      dw = sx; dh = sy; dx = sw; dy = sh;
      sx = 0; sy = 0; sw = image.width; sh = image.height;
    } else if (arguments.length === 3) {
      // 3-argument form: drawImage(image, dx, dy)
      // Parameters are shifted: sx->dx, sy->dy
      dx = sx; dy = sy;
      sx = 0; sy = 0; sw = image.width; sh = image.height;
      dw = sw; dh = sh;
    }
    // 9-argument form uses parameters as-is (no reassignment needed)
    
    const destData = this.canvas.data;
    const srcData = image.data;
    const destWidth = this.canvas.width;
    const srcWidth = image.width;

    // Nearest-neighbor sampling (no bilinear filtering)
    // This is the simplest scaling algorithm: for each destination pixel,
    // find the closest source pixel and copy its color. Fast but produces
    // pixelated results when scaling up. For bitmap fonts, glyphs are typically
    // drawn at original size, so scaling artifacts are rarely visible.
    for (let y = 0; y < dh; y++) {
      for (let x = 0; x < dw; x++) {
        const srcX = Math.floor(sx + (x * sw / dw));
        const srcY = Math.floor(sy + (y * sh / dh));
        const destX = dx + x;
        const destY = dy + y;
        
        if (srcX >= 0 && srcX < image.width && srcY >= 0 && srcY < image.height &&
            destX >= 0 && destX < this.canvas.width && destY >= 0 && destY < this.canvas.height) {
          
          const srcI = (srcY * srcWidth + srcX) * 4;
          const destI = (destY * destWidth + destX) * 4;
          
          if (srcData[srcI + 3] > 0) {  // Only copy non-transparent pixels
            destData[destI] = srcData[srcI];     // R
            destData[destI + 1] = srcData[srcI + 1]; // G
            destData[destI + 2] = srcData[srcI + 2]; // B
            destData[destI + 3] = srcData[srcI + 3]; // A
          }
        }
      }
    }
  }

  // ============================================
  // Image Data Operations
  // ============================================

  /**
   * Create a new ImageData object with specified dimensions
   * @param {number} w - Width in pixels
   * @param {number} h - Height in pixels
   * @returns {Object} ImageData object with width, height, and data properties
   */
  createImageData(w, h) {
    return {
      width: w,
      height: h,
      data: new Uint8ClampedArray(w * h * 4)
    };
  }

  /**
   * Write ImageData directly to canvas at specified position
   *
   * Copies pixel data from ImageData object to canvas buffer.
   * Ignores composite operations and alpha blending - raw pixel copy.
   *
   * @param {Object} imageData - ImageData object with width, height, and data
   * @param {number} dx - Destination X coordinate
   * @param {number} dy - Destination Y coordinate
   */
  putImageData(imageData, dx, dy) {
    if (!this.canvas.data) return;

    const canvasData = this.canvas.data;
    const canvasWidth = this.canvas.width;
    const canvasHeight = this.canvas.height;
    const srcData = imageData.data;
    const srcWidth = imageData.width;
    const srcHeight = imageData.height;

    for (let y = 0; y < srcHeight; y++) {
      for (let x = 0; x < srcWidth; x++) {
        const destX = dx + x;
        const destY = dy + y;

        if (destX >= 0 && destX < canvasWidth && destY >= 0 && destY < canvasHeight) {
          const srcI = (y * srcWidth + x) * 4;
          const destI = (destY * canvasWidth + destX) * 4;

          canvasData[destI] = srcData[srcI];
          canvasData[destI + 1] = srcData[srcI + 1];
          canvasData[destI + 2] = srcData[srcI + 2];
          canvasData[destI + 3] = srcData[srcI + 3];
        }
      }
    }
  }

  /**
   * Extract pixel data from canvas as ImageData object
   *
   * Reads a rectangular region from the canvas and returns it as an
   * ImageData object. Pixels outside canvas bounds are transparent black.
   *
   * @param {number} x - Source X coordinate
   * @param {number} y - Source Y coordinate
   * @param {number} w - Width of region to extract
   * @param {number} h - Height of region to extract
   * @returns {Object} ImageData object containing the extracted pixels
   */
  getImageData(x, y, w, h) {
    if (!this.canvas.data) {
      return {
        width: w,
        height: h,
        data: new Uint8ClampedArray(w * h * 4)
      };
    }

    const canvasWidth = this.canvas.width;
    const canvasHeight = this.canvas.height;
    const canvasData = this.canvas.data;
    const imageData = new Uint8ClampedArray(w * h * 4);

    for (let py = 0; py < h; py++) {
      for (let px = 0; px < w; px++) {
        const srcX = x + px;
        const srcY = y + py;

        if (srcX >= 0 && srcX < canvasWidth && srcY >= 0 && srcY < canvasHeight) {
          const srcI = (srcY * canvasWidth + srcX) * 4;
          const destI = (py * w + px) * 4;

          imageData[destI] = canvasData[srcI];
          imageData[destI + 1] = canvasData[srcI + 1];
          imageData[destI + 2] = canvasData[srcI + 2];
          imageData[destI + 3] = canvasData[srcI + 3];
        }
      }
    }

    return {
      width: w,
      height: h,
      data: imageData
    };
  }

  // ============================================
  // Color Parsing Utilities
  // ============================================

  /**
   * Parse color string to RGB values
   *
   * Supports limited color format subset:
   * - Named colors: 'white', 'black'
   * - Hex colors: '#RRGGBB' (6-digit hex)
   * - Unsupported formats default to black
   *
   * Does not support:
   * - Short hex (#RGB)
   * - rgba() or rgb() functions
   * - hsl() colors
   * - Other named colors
   *
   * @private
   * @param {string} color - Color string to parse
   * @returns {number[]} RGB values as [r, g, b] array (0-255 range)
   */
  _parseColor(color) {
    if (color === 'white') return [255, 255, 255];
    if (color === 'black' || color === '#000000') return [0, 0, 0];

    // Simple hex parsing
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      if (hex.length === 6) {
        return [
          parseInt(hex.slice(0, 2), 16),
          parseInt(hex.slice(2, 4), 16),
          parseInt(hex.slice(4, 6), 16)
        ];
      }
    }

    return [0, 0, 0]; // Default to black
  }
}

// ============================================
// Image Class - Decoded Image Container
// ============================================

/**
 * Image - Simple container for decoded image pixel data
 *
 * Holds decoded image data in RGBA format. Unlike browser Image objects,
 * this does not support loading from URLs or file paths - pixel data
 * must be provided directly during construction.
 *
 * @class Image
 */
class Image {
  /**
   * Create a new Image with pixel data
   * @param {number} width - Image width in pixels
   * @param {number} height - Image height in pixels
   * @param {Uint8ClampedArray} data - Pixel data in RGBA format (4 bytes per pixel)
   */
  constructor(width, height, data) {
    this.width = width;
    this.height = height;
    this.data = data;
  }
}
// ============================================================================
// STATUS CODE CONSTANTS
// ============================================================================
// StatusCode - Core Runtime Constants
//
// This is a CORE RUNTIME module designed for minimal bundle size (~0.5KB).
// It provides status code constants and pre-created status objects for performance optimization.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Used by BitmapText for efficient status reporting
// - No dependencies, pure constants and helper objects
//
// PERFORMANCE OPTIMIZATIONS:
// - Numeric codes for faster comparisons than strings
// - Pre-created immutable SUCCESS_STATUS object to avoid allocations
// - Frozen objects for memory safety and immutability

/**
 * Status codes for BitmapText operations
 * Using numeric values for optimal performance in comparisons
 */
const StatusCode = Object.freeze({
  SUCCESS: 0,           // Everything worked perfectly
  NO_METRICS: 1,        // No FontMetrics found at all for this font configuration
  PARTIAL_METRICS: 2,   // Some characters missing metrics data
  NO_ATLAS: 3,          // No atlas available (will render placeholder rectangles)
  PARTIAL_ATLAS: 4      // Some characters missing from atlas (partial placeholders)
});

/**
 * Pre-created immutable success status object for performance
 * Reused for all successful operations to avoid object allocation overhead
 */
const SUCCESS_STATUS = Object.freeze({
  code: StatusCode.SUCCESS
});

/**
 * Helper function to create error status objects
 * @param {number} code - StatusCode value
 * @param {Object} details - Additional details object
 * @returns {Object} Immutable status object
 */
function createErrorStatus(code, details = {}) {
  return Object.freeze({
    code,
    ...details
  });
}

/**
 * Helper function to check if a status indicates success
 * @param {Object} status - Status object with code property
 * @returns {boolean} True if status indicates success
 */
function isSuccess(status) {
  return status?.code === StatusCode.SUCCESS;
}

/**
 * Helper function to check if a status indicates complete failure
 * (NO_METRICS or PARTIAL_METRICS - cannot render at all)
 * @param {Object} status - Status object with code property
 * @returns {boolean} True if status indicates complete failure
 */
function isCompleteFailure(status) {
  return status && (
    status.code === StatusCode.NO_METRICS ||
    status.code === StatusCode.PARTIAL_METRICS
  );
}

/**
 * Helper function to check if a status indicates partial success
 * (NO_ATLAS or PARTIAL_ATLAS - can render with placeholders)
 * @param {Object} status - Status object with code property
 * @returns {boolean} True if status indicates partial success
 */
function isPartialSuccess(status) {
  return status && (
    status.code === StatusCode.NO_ATLAS ||
    status.code === StatusCode.PARTIAL_ATLAS
  );
}

/**
 * Helper function to get human-readable status description
 * @param {Object} status - Status object with code property
 * @returns {string} Human-readable description
 */
function getStatusDescription(status) {
  if (!status || typeof status.code !== 'number') {
    return 'Invalid status';
  }

  switch (status.code) {
    case StatusCode.SUCCESS:
      return 'Success';
    case StatusCode.NO_METRICS:
      return 'No font metrics available';
    case StatusCode.PARTIAL_METRICS:
      return `Missing metrics for characters: ${status.missingChars ? [...status.missingChars].join('') : 'unknown'}`;
    case StatusCode.NO_ATLAS:
      return 'No atlas available (using placeholders)';
    case StatusCode.PARTIAL_ATLAS:
      return `Missing atlas data for characters: ${status.missingAtlasChars ? [...status.missingAtlasChars].join('') : 'unknown'} (using placeholders)`;
    default:
      return `Unknown status code: ${status.code}`;
  }
}
// ============================================================================
// FONT PROPERTIES CLASS
// ============================================================================
// FontProperties - Core Runtime Class  
//
// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).
// It provides essential font configuration management with maximum performance.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Extended by FontPropertiesFAB for validation and font assets building utilities  
// - Contains no validation code to minimize runtime overhead
// - Optimized for performance with pre-computed keys and immutability
//
// ARCHITECTURE:
// - Immutable font configuration object safe to use as Map keys
// - Pre-computes storage keys and ID strings for optimal lookup performance
// - Provides factory methods for creating instances from various inputs
// - Properties in fixed order: pixelDensity, fontFamily, fontStyle, fontWeight, fontSize
//
// For validation and font assets building utilities, use FontPropertiesFAB.
class FontProperties {
  constructor(pixelDensity, fontFamily, fontStyle, fontWeight, fontSize) {
    // Direct assignment, no validation in core for performance
    this.pixelDensity = pixelDensity || 1;
    this.fontFamily = fontFamily;
    this.fontStyle = fontStyle || 'normal';
    this.fontWeight = fontWeight || 'normal';
    this.fontSize = fontSize;
    
    // Pre-compute storage key (critical for performance optimization)
    // Used for Map lookups in AtlasDataStore
    this._key = `${this.pixelDensity}:${this.fontFamily}:${this.fontStyle}:${this.fontWeight}:${this.fontSize}`;
    
    // Pre-compute ID string for file naming and manifest keys
    // Format: density-1-0-Arial-style-normal-weight-normal-size-18-0
    this._idString = `density-${this.#formatNumber(this.pixelDensity)}-${this.fontFamily}-style-${this.fontStyle}-weight-${this.fontWeight}-size-${this.#formatNumber(this.fontSize)}`;
    
    // Freeze for immutability (safe to use as Map keys)
    Object.freeze(this);
  }
  
  // Format number handling non-integers: 1.5 → "1-5", 18.5 → "18-5", 18 → "18-0"
  #formatNumber(num) {
    const str = String(num);
    return str.includes('.') ? str.replace('.', '-') : `${str}-0`;
  }
  
  // Getter for pre-computed storage key
  get key() {
    return this._key;
  }
  
  // Getter for pre-computed ID string
  get idString() {
    return this._idString;
  }
  
  
  // Factory method to create FontProperties from ID string
  // Parses: density-1-0-Arial-style-normal-weight-normal-size-18-0
  static fromIDString(idString) {
    const parts = idString.split('-');

    // Extract and format numeric values (handling decimal parts)
    const pixelDensity = parseFloat(FontProperties.#formatNumericPart(parts[1], parts[2]));
    const fontSize = parseFloat(FontProperties.#formatNumericPart(parts[9], parts[10]));
    const fontFamily = parts[3];
    const fontStyle = parts[5];
    const fontWeight = parts[7];

    // Return new FontProperties instance
    return new FontProperties(pixelDensity, fontFamily, fontStyle, fontWeight, fontSize);
  }

  // Factory method to create FontProperties from storage key
  // Parses: "1:Arial:normal:normal:19" or "1.5:Arial:italic:bold:18.5"
  static fromKey(key) {
    const [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize] = key.split(':');

    // Return new FontProperties instance with parsed numeric values
    return new FontProperties(
      parseFloat(pixelDensity),
      fontFamily,
      fontStyle,
      fontWeight,
      parseFloat(fontSize)
    );
  }

  // Helper method to format numeric parts (used by fromIDString)
  static #formatNumericPart(integerPart, decimalPart) {
    if (!decimalPart || decimalPart === '0') {
      return integerPart;
    }
    return `${integerPart}.${decimalPart}`;
  }
  
  // Equality comparison based on key
  equals(other) {
    if (!(other instanceof FontProperties)) return false;
    return this._key === other._key;
  }
}
// ============================================================================
// TEXT PROPERTIES CLASS
// ============================================================================
// TextProperties - Core Runtime Class
//
// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).
// It provides essential text rendering configuration with maximum performance.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Manages text rendering properties: kerning, alignment, baseline, color
// - Contains no validation code to minimize runtime overhead
// - Optimized for performance with pre-computed keys and immutability
//
// ARCHITECTURE:
// - Immutable text configuration object safe to use as Map keys
// - Pre-computes storage keys for optimal lookup performance
// - Provides factory methods for creating instances from various inputs
// - Properties: isKerningEnabled, textBaseline, textAlign, textColor
//
// This class replaces the global isKerningEnabled variable and consolidates
// all text rendering properties into a single, immutable configuration object.
class TextProperties {
  constructor(options = {}) {
    // Extract options with defaults - optimized for BitmapText usage
    const {
      isKerningEnabled = true,        // Enable kerning by default for better text rendering
      textBaseline = 'bottom',        // BitmapText uses 'bottom' baseline by architectural design (HTML5 Canvas default is 'alphabetic')
      textAlign = 'left',             // HTML5 Canvas default
      textColor = '#000000'           // Black color default
    } = options;

    // Direct assignment, no validation in core for performance
    this.isKerningEnabled = isKerningEnabled;
    this.textBaseline = textBaseline;
    this.textAlign = textAlign;
    this.textColor = textColor;

    // Pre-compute storage key (for potential caching or Map lookups)
    this._key = `kerning:${this.isKerningEnabled}:baseline:${this.textBaseline}:align:${this.textAlign}:color:${this.textColor}`;

    // Freeze for immutability (safe to use as Map keys)
    Object.freeze(this);
  }

  // Getter for pre-computed storage key
  get key() {
    return this._key;
  }

  // Factory method to create TextProperties with specific kerning setting
  static withKerning(isKerningEnabled, options = {}) {
    return new TextProperties({
      ...options,
      isKerningEnabled
    });
  }

  // Factory method to create TextProperties with specific color
  static withColor(textColor, options = {}) {
    return new TextProperties({
      ...options,
      textColor
    });
  }

  // Factory method to create TextProperties for BitmapText (uses 'bottom' baseline)
  static forBitmapText(options = {}) {
    return new TextProperties({
      textBaseline: 'bottom',  // BitmapText uses bottom baseline positioning
      ...options
    });
  }

  // Create a new TextProperties with modified kerning
  withKerningEnabled(isKerningEnabled) {
    return new TextProperties({
      isKerningEnabled,
      textBaseline: this.textBaseline,
      textAlign: this.textAlign,
      textColor: this.textColor
    });
  }

  // Create a new TextProperties with modified color
  withTextColor(textColor) {
    return new TextProperties({
      isKerningEnabled: this.isKerningEnabled,
      textBaseline: this.textBaseline,
      textAlign: this.textAlign,
      textColor
    });
  }

  // Equality comparison based on key
  equals(other) {
    if (!(other instanceof TextProperties)) return false;
    return this._key === other._key;
  }

  // Return plain object for compatibility/debugging
  toObject() {
    return {
      isKerningEnabled: this.isKerningEnabled,
      textBaseline: this.textBaseline,
      textAlign: this.textAlign,
      textColor: this.textColor
    };
  }
}
// ============================================================================
// FONT METRICS CLASS
// ============================================================================
// FontMetrics - Core Runtime Class
//
// This is a CORE RUNTIME class designed for minimal bundle size (~3-4KB).
// It encapsulates all metrics data for a single font configuration as an immutable domain object.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Extended by FontMetricsFAB for font assets building capabilities
// - Contains only essential metrics data and accessor methods
// - No font generation, validation, or optimization code
//
// ARCHITECTURE:
// - Immutable object representing all metrics for ONE font configuration
// - Pre-computed lookups for optimal performance during text rendering
// - Provides clean API without needing fontProperties passed to every method
// - Follows same immutable pattern as FontProperties
//
// SEPARATION RATIONALE:
// - Encapsulates related metrics data together
// - Eliminates repeated fontProperties parameter passing
// - Serves as domain object for font metrics
// - Enables cleaner, more object-oriented API
//
// For font assets building capabilities, use FontMetricsFAB which extends this class.
class FontMetrics {
  constructor(data, options = {}) {
    // Validate input data structure
    if (!data || typeof data !== 'object') {
      throw new Error('FontMetrics constructor requires data object');
    }
    
    // Kerning table: character pairs → adjustment values
    this._kerningTable = data.kerningTable || {};
    
    // Character metrics: character → TextMetrics-compatible object
    this._characterMetrics = data.characterMetrics || {};
    
    // Space advancement override for small font sizes
    this._spaceAdvancementOverride = data.spaceAdvancementOverrideForSmallSizesInPx || null;
    
    // Freeze for immutability (safe to use as value object)
    // Skip freezing if this is for font assets building (FAB)
    if (!options.mutable) {
      Object.freeze(this._kerningTable);
      Object.freeze(this._characterMetrics);
      Object.freeze(this);
    }
  }
  
  /**
   * Get text measurement metrics for a character
   * @param {string} char - Character (code point) to get metrics for
   * @returns {Object} TextMetrics-compatible object
   */
  getCharacterMetrics(char) {
    return this._characterMetrics[char];
  }
  
  /**
   * Get kerning adjustment between two characters
   * @param {string} leftChar - Left character in pair
   * @param {string} rightChar - Right character in pair  
   * @returns {number} Kerning adjustment value (0 if no adjustment)
   */
  getKerningAdjustment(leftChar, rightChar) {
    if (!leftChar || !rightChar) return 0;
    return this._kerningTable[leftChar]?.[rightChar] || 0;
  }
  
  /**
   * Check if glyph exists in this font
   * @param {string} char - Character (code point) to check
   * @returns {boolean} True if glyph has metrics
   */
  hasGlyph(char) {
    return char in this._characterMetrics;
  }
  
  /**
   * Get space advancement override for small font sizes
   * @returns {number|null} Override value in pixels, or null if no override
   */
  getSpaceAdvancementOverride() {
    return this._spaceAdvancementOverride;
  }
  
  /**
   * Get the complete kerning table (for compatibility/debugging)
   * @returns {Object} Complete kerning table
   */
  getKerningTable() {
    return this._kerningTable;
  }
  
  /**
   * Get all available characters in this font
   * @returns {string[]} Array of available characters
   */
  getAvailableCharacters() {
    return Object.keys(this._characterMetrics);
  }
  
}
// ============================================================================
// BITMAP TEXT STATIC CLASS
// ============================================================================
// BitmapText - Static Core Runtime Class
//
// Status constants are loaded as global variables by StatusCode.js (loaded before this file)
// In Node.js bundles, StatusCode.js is concatenated before this file
if (typeof StatusCode === 'undefined' || typeof SUCCESS_STATUS === 'undefined' || typeof createErrorStatus === 'undefined') {
  throw new Error('StatusCode.js must be loaded before BitmapText.js');
}
//
// This is a STATIC CORE RUNTIME class designed for minimal bundle size and zero-ceremony usage.
// It provides essential text rendering capabilities for consuming pre-built bitmap fonts.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - All methods are static - no instantiation needed
// - Contains no font generation code to keep bundle size minimal
//
// ARCHITECTURE:
// - Facade pattern: Delegates storage to AtlasDataStore/FontMetricsStore, font loading to FontLoader
// - fontDirectory configuration owned by FontLoader (this class delegates get/set)
// - Auto-detects environment (browser vs Node.js) for canvas creation
// - Draws text by looking up glyphs from atlases and positioning them with metrics/kerning
// - Uses textBaseline='bottom' positioning (y = bottom of text bounding box)
// - Supports placeholder rectangles when atlases are missing but metrics are available
//
// CANVAS FACTORY (Node.js only):
// - Node.js has no DOM, thus no native Canvas
// - BitmapText needs Canvas to:
//   1. Load atlas images from files
//   2. Scan pixels to find tight bounding boxes for each glyph
//   3. Create tight atlas from scanned data
// - Cannot pass class reference: HTMLCanvasElement is NOT constructible
//   (new HTMLCanvasElement() throws "Illegal constructor")
// - Must pass factory function: () => new Canvas()
// - Browser: via document.createElement('canvas')
// - Node.js: Must configure with canvas-mock providing Canvas constructor
//
// USAGE:
// - Zero configuration for browser: Just call BitmapText.drawTextFromAtlas()
// - Node.js: Optionally set canvas factory: BitmapText.setCanvasFactory(() => new Canvas())
// - Loading: BitmapText.loadFont(idString) or BitmapText.loadFonts([idStrings])
// - Query: BitmapText.hasFont(idString), BitmapText.getLoadedFonts()
//
class BitmapText {
  // ============================================
  // Static Constants
  // ============================================

  // Kerning unit divisor (kerning measured in 1/1000 em units)
  static KERNING_UNIT_DIVISOR = 1000;

  // Font asset naming conventions
  static METRICS_PREFIX = 'metrics-';
  static ATLAS_PREFIX = 'atlas-';
  static WEBP_EXTENSION = '.webp';
  static QOI_EXTENSION = '.qoi';
  static JS_EXTENSION = '.js';

  // Default text color (matches TextProperties default)
  static #DEFAULT_TEXT_COLOR = '#000000';

  // Character set constant (204 characters)
  // Used by both build-time (MetricsMinifier) and runtime (MetricsExpander)
  // This is the sorted character set that defines the standard order for all font metrics.
  // ALL font files must contain exactly these 204 characters in this order.
  static CHARACTER_SET = BitmapText.#generateCharacterSet();

  // ============================================
  // Static Storage & Configuration
  // ============================================

  // Font data storage delegated to AtlasDataStore and FontMetricsStore
  // (no private maps - stores are the single source of truth)

  // Configuration (user overrides, delegates to FontLoader for defaults)
  // fontDirectory is owned by FontLoader (it's the component that uses it)
  static #canvasFactory = (typeof document !== 'undefined' ? () => document.createElement('canvas') : null);         // Optional user override

  // Rendering resources (lazy-initialized on first render)
  static #coloredGlyphCanvas = null;    // Shared scratch canvas for coloring
  static #coloredGlyphCtx = null;       // 2D context for scratch canvas

  // Font loader (platform-specific, set at runtime)
  static #fontLoader = null;            // FontLoaderBrowser or FontLoaderNode

  // ============================================
  // Configuration API (Optional)
  // ============================================

  /**
   * Set font directory (overrides default)
   * Delegates to FontLoader which owns this configuration
   * @param {string} path - Path to font assets directory
   */
  static setFontDirectory(path) {
    BitmapText.#ensureFontLoader();
    BitmapText.#fontLoader.setFontDirectory(path);
  }

  /**
   * Get font directory (returns override or default)
   * Delegates to FontLoader which owns this configuration
   * @returns {string} Font directory path
   */
  static getFontDirectory() {
    BitmapText.#ensureFontLoader();
    return BitmapText.#fontLoader.getFontDirectory();
  }

  /**
   * Override canvas factory (Node.js only, testing, or custom canvas implementations)
   *
   * WHY A FACTORY FUNCTION?
   * HTMLCanvasElement is not constructible in JavaScript - new HTMLCanvasElement()
   * throws "Illegal constructor". Browser uses document.createElement('canvas'),
   * Node.js requires canvas-mock providing Canvas constructor.
   *
   * @param {Function} factory - Function that returns a canvas instance
   * @example
   * // Node.js
   * BitmapText.setCanvasFactory(() => new Canvas());
   *
   * // Browser (custom implementation)
   * BitmapText.setCanvasFactory(() => new OffscreenCanvas(0, 0));
   */
  static setCanvasFactory(factory) {
    BitmapText.#canvasFactory = factory;
    // Reset canvas to use new factory on next render
    BitmapText.#coloredGlyphCanvas = null;
    BitmapText.#coloredGlyphCtx = null;
  }

  /**
   * Get canvas factory (with fallback to platform default)
   *
   * USAGE PATTERN:
   * const canvas = BitmapText.getCanvasFactory()();  // Note double invocation
   *   - First ():  Gets the factory function
   *   - Second (): Invokes factory to create canvas
   *
   * @returns {Function} Canvas factory function
   */
  static getCanvasFactory() {
    return BitmapText.#canvasFactory;
  }

  /**
   * Configure multiple options at once
   * @param {Object} options - Configuration options
   * @param {string} [options.fontDirectory] - Font assets directory
   * @param {Function} [options.canvasFactory] - Canvas factory function
   */
  static configure(options = {}) {
    if (options.fontDirectory !== undefined) {
      BitmapText.setFontDirectory(options.fontDirectory);
    }
    if (options.canvasFactory !== undefined) {
      BitmapText.setCanvasFactory(options.canvasFactory);
    }
  }

  /**
   * Ensure font loader is initialized
   * @private
   */
  static #ensureFontLoader() {
    if (BitmapText.#fontLoader) {
      return;
    }

    // Check if platform-specific FontLoader is available
    if (typeof FontLoader === 'undefined') {
      throw new Error(
        'BitmapText: FontLoader not loaded.\n' +
        'Ensure platform-specific FontLoader is included before BitmapText.js:\n' +
        '  - Browser: <script src="src/platform/FontLoader-browser.js"></script>\n' +
        '  - Node.js: Include src/platform/FontLoader-node.js in bundle'
      );
    }

    BitmapText.#fontLoader = FontLoader;
  }

  // ============================================
  // Registration API (called by asset files)
  // ============================================

  /**
   * Convert registration parameters to ID string
   * Shared helper for registerMetrics and registerAtlas
   * @private
   * @param {number} density - Pixel density
   * @param {string} fontFamily - Font family name
   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)
   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric)
   * @param {number} size - Font size
   * @returns {string} ID string (e.g., "density-1-0-Arial-style-normal-weight-normal-size-19-0")
   */
  static #parametersToIDString(density, fontFamily, styleIdx, weightIdx, size) {
    // Decompress style and weight indices
    const style = styleIdx === 0 ? 'normal' : (styleIdx === 1 ? 'italic' : 'oblique');
    const weight = weightIdx === 0 ? 'normal' : (weightIdx === 1 ? 'bold' : String(weightIdx));

    // Format density (1 → 1-0, 1.5 → 1-5)
    const densityStr = String(density);
    const densityFormatted = densityStr.includes('.') ? densityStr.replace('.', '-') : `${densityStr}-0`;

    // Format size (18 → 18-0, 18.5 → 18-5)
    const sizeStr = String(size);
    const sizeFormatted = sizeStr.includes('.') ? sizeStr.replace('.', '-') : `${sizeStr}-0`;

    // Reconstruct full ID
    return `density-${densityFormatted}-${fontFamily}-style-${style}-weight-${weight}-size-${sizeFormatted}`;
  }

  /**
   * Register font metrics from metrics-*.js file
   * TIER 6c: Multi-parameter format only (no legacy support)
   *
   * @param {number} density - Pixel density (e.g., 1 or 1.5)
   * @param {string} fontFamily - Font family name (e.g., 'Arial')
   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)
   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric weight)
   * @param {number} size - Font size (e.g., 18 or 18.5)
   * @param {Array} compactedData - Tier 6c compacted metrics array
   */
  static registerMetrics(density, fontFamily, styleIdx, weightIdx, size, compactedData) {
    BitmapText.#ensureFontLoader();
    const fullIDString = BitmapText.#parametersToIDString(density, fontFamily, styleIdx, weightIdx, size);
    FontLoaderBase.registerMetrics(fullIDString, compactedData, BitmapText);
  }

  /**
   * Register atlas from atlas-*.js file (base64 only, positioning reconstructed later)
   * Delegates to FontLoader which handles platform-specific details
   * @param {number} density - Pixel density (e.g., 1 or 1.5)
   * @param {string} fontFamily - Font family name (e.g., 'Arial')
   * @param {number} styleIdx - Style index (0=normal, 1=italic, 2=oblique)
   * @param {number} weightIdx - Weight index (0=normal, 1=bold, or numeric weight)
   * @param {number} size - Font size (e.g., 18 or 18.5)
   * @param {string} base64Data - Base64-encoded atlas data
   */
  static registerAtlas(density, fontFamily, styleIdx, weightIdx, size, base64Data) {
    BitmapText.#ensureFontLoader();
    const fullIDString = BitmapText.#parametersToIDString(density, fontFamily, styleIdx, weightIdx, size);
    FontLoaderBase.registerAtlas(fullIDString, base64Data);
  }

  // ============================================
  // Rendering API
  // ============================================

  /**
   * Measure text dimensions
   *
   * RETURN VALUES: All measurements are in CSS PIXELS
   * - width, actualBoundingBox* values are CSS pixels
   * - Measurements are independent of canvas setup or context transforms
   * - To convert to physical pixels: multiply by fontProperties.pixelDensity
   *
   * NOTE: This method does NOT draw anything and is NOT affected by context transforms.
   * It purely calculates metrics based on font data.
   *
   * The metrics object has the same shape and meaning as the TextMetrics object (see
   * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics ):
   * - width: sum of character advancements (minus kerning adjustments)
   * - actualBoundingBoxLeft: actualBoundingBoxLeft of first character
   * - actualBoundingBoxRight: sum of advancements (excluding last) + last char's actualBoundingBoxRight
   *
   * @param {string} text - Text to measure
   * @param {FontProperties} fontProperties - Font configuration
   * @param {TextProperties} [textProperties] - Text rendering configuration (optional)
   * @returns {{metrics: {width: number, actualBoundingBoxLeft: number, actualBoundingBoxRight: number, actualBoundingBoxAscent: number, actualBoundingBoxDescent: number, fontBoundingBoxAscent: number, fontBoundingBoxDescent: number}|null, status: {code: number, missingChars?: Set}}}
   *   All numeric values in metrics are CSS pixels
   */
  static measureText(text, fontProperties, textProperties) {
    if (!textProperties) {
      textProperties = new TextProperties();
    }

    // FAST PATH: Handle empty text (100% success)
    if (text.length === 0) {
      return {
        metrics: {
          width: 0,
          actualBoundingBoxLeft: 0,
          actualBoundingBoxRight: 0,
          actualBoundingBoxAscent: 0,
          actualBoundingBoxDescent: 0,
          fontBoundingBoxAscent: 0,
          fontBoundingBoxDescent: 0
        },
        status: SUCCESS_STATUS
      };
    }

    // Check if FontMetrics exists at all
    const fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);
    if (!fontMetrics) {
      return {
        metrics: null,
        status: createErrorStatus(StatusCode.NO_METRICS)
      };
    }

    // Scan text for missing glyphs (excluding spaces which are handled specially)
    const missingChars = new Set();
    for (const char of text) {
      if (char !== ' ' && !fontMetrics.hasGlyph(char)) {
        missingChars.add(char);
      }
    }

    // If any glyphs missing, can't calculate accurate metrics
    if (missingChars.size > 0) {
      return {
        metrics: null,
        status: createErrorStatus(StatusCode.PARTIAL_METRICS, {
          missingChars: missingChars
        })
      };
    }

    // SUCCESS PATH: Calculate metrics normally
    const chars = [...text];
    let width_CssPx = 0;
    let characterMetrics = fontMetrics.getCharacterMetrics(chars[0]);
    const actualBoundingBoxLeft_CssPx = characterMetrics.actualBoundingBoxLeft;
    let actualBoundingBoxAscent = 0;
    let actualBoundingBoxDescent = 0;
    let actualBoundingBoxRight_CssPx;
    let advancement_CssPx = 0;

    for (let i = 0; i < chars.length; i++) {
      const char = chars[i];
      const nextChar = chars[i + 1];

      characterMetrics = fontMetrics.getCharacterMetrics(char);

      actualBoundingBoxAscent = Math.max(actualBoundingBoxAscent, characterMetrics.actualBoundingBoxAscent);
      actualBoundingBoxDescent = Math.min(actualBoundingBoxDescent, characterMetrics.actualBoundingBoxDescent);

      advancement_CssPx = this.calculateAdvancement_CssPx(fontMetrics, fontProperties, char, nextChar, textProperties, characterMetrics);
      width_CssPx += advancement_CssPx;
    }

    actualBoundingBoxRight_CssPx = width_CssPx - advancement_CssPx;
    actualBoundingBoxRight_CssPx += characterMetrics.actualBoundingBoxRight;

    return {
      metrics: {
        width: width_CssPx,
        actualBoundingBoxLeft: actualBoundingBoxLeft_CssPx,
        actualBoundingBoxRight: actualBoundingBoxRight_CssPx,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent,
        fontBoundingBoxAscent: characterMetrics.fontBoundingBoxAscent,
        fontBoundingBoxDescent: characterMetrics.fontBoundingBoxDescent
      },
      status: SUCCESS_STATUS
    };
  }

  /**
   * Draw text using pre-rendered glyphs from atlas
   *
   * COORDINATE SYSTEM:
   * - All coordinates are in CSS PIXELS relative to canvas origin (0,0)
   * - BitmapText IGNORES all context transforms (scale, translate, rotate, etc.)
   * - Internal conversion: physicalPixels = cssPixels × fontProperties.pixelDensity
   * - Transform is reset to identity during rendering, then restored
   *
   * TRANSFORM BEHAVIOR:
   * BitmapText will reset the context transform to identity before drawing,
   * meaning any ctx.scale(), ctx.translate(), ctx.rotate(), etc. are IGNORED.
   * This ensures pixel-perfect rendering at exact physical pixel positions.
   *
   * Example:
   *   ctx.scale(2, 2);          // User scales context
   *   ctx.translate(100, 50);    // User translates
   *   BitmapText.drawTextFromAtlas(ctx, "Hello", 10, 30, fontProps);
   *   // Text renders at (10, 30) CSS pixels from origin, NOT (120, 80)!
   *   // Transforms are ignored - coordinates are always absolute
   *
   * PIXEL DENSITY:
   * - Specified via fontProperties.pixelDensity (e.g., window.devicePixelRatio)
   * - Canvas should be sized: canvas.width = cssWidth × pixelDensity
   * - Do NOT use ctx.scale(dpr, dpr) - BitmapText handles density internally
   *
   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context (transform will be temporarily reset)
   * @param {string} text - Text to render
   * @param {number} x_CssPx - X position in CSS pixels (absolute, from canvas origin)
   * @param {number} y_CssPx - Y position in CSS pixels (absolute, from canvas origin, bottom baseline)
   * @param {FontProperties} fontProperties - Font configuration (including pixelDensity)
   * @param {TextProperties} [textProperties] - Text rendering configuration (optional)
   * @returns {{rendered: boolean, status: {code: number, missingChars?: Set, missingAtlasChars?: Set, placeholdersUsed?: boolean}}}
   *   Rendering result and status information
   */
  static drawTextFromAtlas(ctx, text, x_CssPx, y_CssPx, fontProperties, textProperties = null) {
    textProperties = textProperties || new TextProperties();

    // Lazy-initialize canvas on first render
    if (!BitmapText.#coloredGlyphCanvas) {
      // Explicit factory invocation: get factory, then call it
      BitmapText.#coloredGlyphCanvas = BitmapText.getCanvasFactory()();
      BitmapText.#coloredGlyphCtx = BitmapText.#coloredGlyphCanvas.getContext('2d');
    }

    // Check FontMetrics availability first
    const fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);
    if (!fontMetrics) {
      return {
        rendered: false,
        status: createErrorStatus(StatusCode.NO_METRICS)
      };
    }

    // Scan for missing metrics (can't render without metrics)
    const missingMetricsChars = new Set();
    for (const char of text) {
      if (char !== ' ' && !fontMetrics.hasGlyph(char)) {
        missingMetricsChars.add(char);
      }
    }

    if (missingMetricsChars.size > 0) {
      return {
        rendered: false,
        status: createErrorStatus(StatusCode.PARTIAL_METRICS, {
          missingChars: missingMetricsChars
        })
      };
    }

    // Check atlas data availability
    const atlasData = AtlasDataStore.getAtlasData(fontProperties);
    const atlasValid = BitmapText.#isValidAtlas(atlasData);

    // Track which glyphs are missing from atlas (for partial atlas status)
    const missingAtlasChars = new Set();
    let placeholdersUsed = false;

    // CRITICAL: Reset transform to identity for pixel-perfect physical rendering
    // BitmapText ignores ALL context transforms (scale, translate, rotate, etc.)
    // Coordinates are ALWAYS relative to canvas origin (0,0)
    // This ensures:
    // 1. Predictable positioning regardless of context state
    // 2. Pixel-perfect rendering at physical pixel boundaries
    // 3. No double-scaling when users apply ctx.scale(dpr, dpr)
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);  // Reset to identity matrix

    // Render text
    const chars = [...text];
    const textColor = textProperties.textColor;

    // BASELINE SUPPORT: Convert user's y from their chosen baseline to 'bottom' baseline
    // Get baseline data from first character (baseline values are identical for all characters in a font)
    // Use first actual character, or fallback to space character for baseline calculation
    const firstChar = chars.find(c => fontMetrics.hasGlyph(c)) || chars[0];
    const characterMetricsForBaseline = fontMetrics.getCharacterMetrics(firstChar);
    const baselineOffset_CssPx = characterMetricsForBaseline
      ? BitmapText.#calculateBaselineOffsetToBottom(textProperties.textBaseline, characterMetricsForBaseline)
      : 0;

    // ALIGNMENT SUPPORT: Convert user's x from their chosen alignment to 'left' alignment
    // Measure text width to calculate alignment offset (measureText accounts for kerning if enabled)
    let alignmentOffset_CssPx = 0;
    if (textProperties.textAlign !== 'left') {
      const measureResult = BitmapText.measureText(text, fontProperties, textProperties);
      if (measureResult.status.code === 0 && measureResult.metrics) {
        // Successfully measured text - calculate alignment offset
        alignmentOffset_CssPx = BitmapText.#calculateAlignmentOffsetToLeft(
          textProperties.textAlign,
          measureResult.metrics.width
        );
      } else {
        // Failed to measure (missing glyphs, etc.) - default to left alignment (offset = 0)
        // Text will still render but won't be aligned as requested
        console.warn(`BitmapText: Failed to measure text for alignment '${textProperties.textAlign}', defaulting to left alignment`);
      }
    }

    // Apply baseline and alignment offsets, then convert to physical pixels
    const position_PhysPx = {
      x: (x_CssPx + alignmentOffset_CssPx) * fontProperties.pixelDensity,
      y: (y_CssPx + baselineOffset_CssPx) * fontProperties.pixelDensity
    };

    // OPTIMIZATION: Batch colored text rendering (single composite operation)
    // Check if we're rendering colored text with a valid atlas
    const isColoredText = textColor !== BitmapText.#DEFAULT_TEXT_COLOR;
    if (isColoredText && atlasValid) {
      // Use optimized batch rendering for colored text
      // This reduces composite operations from N (per character) to 1 (per text string)
      const batchResult = BitmapText.#drawColoredTextBatched(
        ctx, text, chars, position_PhysPx, atlasData, fontMetrics, fontProperties, textProperties
      );

      // Merge batch results into tracking sets
      batchResult.missingAtlasChars.forEach(char => missingAtlasChars.add(char));
      placeholdersUsed = placeholdersUsed || batchResult.placeholdersUsed;

      // Skip character-by-character loop for colored text
    } else {
      // Black text or invalid atlas: use character-by-character rendering
      for (let i = 0; i < chars.length; i++) {
        const currentChar = chars[i];
        const nextChar = chars[i + 1];

        // Check if atlas has a glyph for this character (excluding spaces)
        if (currentChar !== ' ') {
          if (!atlasValid || !atlasData.hasPositioning(currentChar)) {
            missingAtlasChars.add(currentChar);
            placeholdersUsed = true;
          }
        }

        // Draw (either real glyph or placeholder)
        BitmapText.#drawCharacter(ctx,
          currentChar,
          position_PhysPx,
          atlasData,
          fontMetrics,
          textColor
        );

        position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties);
      }
    }

    // Determine status code
    let statusCode;
    if (!atlasValid) {
      statusCode = StatusCode.NO_ATLAS;
    } else if (missingAtlasChars.size > 0) {
      statusCode = StatusCode.PARTIAL_ATLAS;
    } else {
      // Complete success
      ctx.restore();  // Restore original transform
      return {
        rendered: true,
        status: SUCCESS_STATUS
      };
    }

    // Return detailed status for non-success cases
    ctx.restore();  // Restore original transform
    return {
      rendered: true,
      status: createErrorStatus(statusCode, {
        missingAtlasChars: missingAtlasChars.size > 0 ? missingAtlasChars : undefined,
        placeholdersUsed: placeholdersUsed
      })
    };
  }

  // ============================================
  // Internal Rendering Helpers
  // ============================================
  // Get the advancement of the i-th character i.e. needed AFTER the i-th character
  // so that the i+1-th character is drawn at the right place
  // This depends on both the advancement specified by the glyph of the i-th character
  // AND by the kerning correction depending on the pair of the i-th and i+1-th characters

  static calculateAdvancement_CssPx(fontMetrics, fontProperties, char, nextChar, textProperties, characterMetrics = null) {
    if (!textProperties) {
      textProperties = new TextProperties();
    }
    if (!characterMetrics) {
      characterMetrics = fontMetrics.getCharacterMetrics(char);
    }
    let x_CssPx = 0;

    // LIMITATION: Only handles standard space (U+0020), not other Unicode space characters

    // Handle space first ------------------------------------------
    // You could add the space advancement as we got it from the browser
    // (remember that the space doesn't have the tightCanvasBox)
    // but since at small sizes we meddle with kerning quite a bit, we want
    // to also meddle with this to try to make the width of text
    // similar to what the browser paints normally.
    // console.log(characterMetrics.width + " " + x_CSS_Px);
    // deal with the size of the " " character
    if (char === " ") {
      const spaceAdvancementOverrideForSmallSizesInPx_CssPx = fontMetrics.getSpaceAdvancementOverride();
      if (spaceAdvancementOverrideForSmallSizesInPx_CssPx !== null) {
        x_CssPx += spaceAdvancementOverrideForSmallSizesInPx_CssPx;
      }
      else {
        x_CssPx += characterMetrics.width;
      }
    }
    // Non-space characters
    else {
      x_CssPx += characterMetrics.width;
    }

    // Apply kerning correction
    let kerningCorrection = BitmapText.#getKerningCorrection(fontMetrics, char, nextChar, textProperties);

    // Kerning adjustments are measured in 1/1000 em units (font-size relative).
    // We convert to pixels by multiplying font size by the kerning correction
    // and dividing by 1000. This keeps kerning proportional to font size while
    // maintaining precision in the stored kerning values.
    x_CssPx -= fontProperties.fontSize * kerningCorrection / BitmapText.KERNING_UNIT_DIVISOR;

    // since we might want to actually _place_ a glyph,
    // following this measurement, we want to return an
    // integer coordinate here
    return Math.round(x_CssPx);
  }

  static #getKerningCorrection(fontMetrics, char, nextChar, textProperties) {
    if (!textProperties) {
      textProperties = new TextProperties();
    }

    if (textProperties.isKerningEnabled && nextChar) {
      return fontMetrics.getKerningAdjustment(char, nextChar);
    }

    return 0;
  }

  /**
   * Calculate y-offset to convert from specified textBaseline to 'bottom' baseline
   *
   * INTERNAL REFERENCE: BitmapText uses 'bottom' baseline for all dy calculations.
   * All glyph dy offsets are pre-calculated assuming y is at the bottom of the em square.
   * This method converts user's chosen baseline to that internal reference.
   *
   * COORDINATE SYSTEM: y increases downward (Canvas convention)
   * All baseline distances are in CSS pixels and relative to alphabetic baseline (ab = 0)
   *
   * BASELINE GEOMETRY:
   * - top: At fontBoundingBoxAscent above alphabetic
   * - hanging: At hangingBaseline above alphabetic (Tibetan, Devanagari)
   * - middle: At (fontBoundingBoxAscent - fontBoundingBoxDescent) / 2 above alphabetic
   * - alphabetic: At 0 (reference point for Latin scripts)
   * - ideographic: At ideographicBaseline below alphabetic (CJK scripts, negative value)
   * - bottom: At fontBoundingBoxDescent below alphabetic
   *
   * @private
   * @param {string} textBaseline - User's chosen baseline ('top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom')
   * @param {Object} characterMetrics - Metrics containing baseline data (fba, fbd, hb, ab, ib)
   * @returns {number} Offset in CSS pixels to add to y coordinate to reach 'bottom' baseline
   */
  static #calculateBaselineOffsetToBottom(textBaseline, characterMetrics) {
    // Extract baseline measurements from character metrics
    // These values are captured from browser's TextMetrics during font generation
    const fba = characterMetrics.fontBoundingBoxAscent;    // Distance from alphabetic to top of em square (positive)
    const fbd = characterMetrics.fontBoundingBoxDescent;   // Distance from alphabetic to bottom of em square (positive, downward)
    const hb = characterMetrics.hangingBaseline;           // Distance from alphabetic to hanging baseline (positive, upward)
    const ib = characterMetrics.ideographicBaseline;       // Distance from alphabetic to ideographic baseline (negative, downward)

    // Convert from user's baseline to bottom baseline
    // Formulas derived from geometric relationships in em square coordinate system
    switch (textBaseline) {
      case 'top':
        // Top of em square → Bottom of em square
        // Move down by full em height: ascent + descent
        return fba + fbd;

      case 'hanging':
        // Hanging baseline → Bottom of em square
        // Hanging is hb above alphabetic, bottom is fbd below alphabetic
        // Total distance: hb (up to alphabetic) + fbd (down to bottom)
        return hb + fbd;

      case 'middle':
        // Middle of em square → Bottom of em square
        // Middle is halfway between top and bottom
        // Distance from middle to bottom: (ascent + descent) / 2
        return (fba + fbd) / 2;

      case 'alphabetic':
        // Alphabetic baseline → Bottom of em square
        // Alphabetic is fbd above bottom (standard for Latin text)
        return fbd;

      case 'ideographic':
        // Ideographic baseline → Bottom of em square
        // Ideographic is ib pixels relative to alphabetic (negative = below alphabetic)
        // Distance from ideographic to bottom: fbd + ib
        // Example: if fbd=4 and ib=-4.0264, offset = 4 + (-4.0264) = -0.0264
        // This small negative offset places ideographic just above bottom, matching native Canvas
        return fbd + ib;

      case 'bottom':
        // Already at bottom baseline - no offset needed
        return 0;

      default:
        // Unknown baseline value - warn and default to bottom
        console.warn(`BitmapText: Unknown textBaseline '${textBaseline}', defaulting to 'bottom'. Valid values: top, hanging, middle, alphabetic, ideographic, bottom`);
        return 0;
    }
  }

  /**
   * Calculate x-offset to convert from specified textAlign to 'left' alignment
   *
   * INTERNAL REFERENCE: BitmapText uses 'left' alignment for internal rendering.
   * All text rendering starts from the x-coordinate and advances rightward.
   * This method converts user's chosen alignment to that internal reference.
   *
   * COORDINATE SYSTEM: x increases rightward (Canvas convention)
   * All measurements are in CSS pixels
   *
   * ALIGNMENT GEOMETRY:
   * - left: x marks the start of the text (no offset needed)
   * - center: x marks the center of the text (offset by -width/2)
   * - right: x marks the end of the text (offset by -width)
   *
   * @private
   * @param {string} textAlign - User's chosen alignment ('left', 'center', 'right')
   * @param {number} textWidth_CssPx - Total width of the text in CSS pixels
   * @returns {number} Offset in CSS pixels to add to x coordinate to reach 'left' alignment
   */
  static #calculateAlignmentOffsetToLeft(textAlign, textWidth_CssPx) {
    // Convert from user's alignment to left alignment (internal reference)
    switch (textAlign) {
      case 'left':
        // Already at left alignment - no offset needed
        return 0;

      case 'center':
        // Center alignment → Left alignment
        // Text is centered at x, need to shift left by half width to get start position
        return -textWidth_CssPx / 2;

      case 'right':
        // Right alignment → Left alignment
        // Text ends at x, need to shift left by full width to get start position
        return -textWidth_CssPx;

      default:
        // Unknown alignment value - warn and default to left
        console.warn(`BitmapText: Unknown textAlign '${textAlign}', defaulting to 'left'. Valid values: left, center, right`);
        return 0;
    }
  }

  /**
   * Draw colored text using optimized batch rendering
   *
   * OPTIMIZATION: Instead of switching composite operations for EACH character:
   * 1. Measure total text extent ONCE
   * 2. Draw ALL glyphs to one scratch canvas (in original black form)
   * 3. Apply color transformation ONCE using composite operation
   * 4. Copy entire colored text block to main canvas ONCE
   *
   * This reduces expensive composite operation switches from N (per character) to 1 (per text string)
   * Expected performance improvement: 2-5x faster for colored text rendering
   *
   * @private
   * @param {CanvasRenderingContext2D} ctx - Main canvas context
   * @param {string} text - Full text string to render
   * @param {Array<string>} chars - Text split into characters
   * @param {Object} startPosition_PhysPx - Starting position in physical pixels {x, y}
   * @param {AtlasData} atlasData - Atlas data containing glyphs
   * @param {FontMetrics} fontMetrics - Font metrics for measurements
   * @param {FontProperties} fontProperties - Font configuration
   * @param {TextProperties} textProperties - Text rendering configuration
   * @returns {{missingAtlasChars: Set, placeholdersUsed: boolean}} Status information
   */
  static #drawColoredTextBatched(ctx, text, chars, startPosition_PhysPx, atlasData, fontMetrics, fontProperties, textProperties) {
    const missingAtlasChars = new Set();
    let placeholdersUsed = false;

    // Step 1: Measure text to determine bounding box for scratch canvas
    const measureResult = BitmapText.measureText(text, fontProperties, textProperties);
    if (measureResult.status.code !== 0 || !measureResult.metrics) {
      // Cannot measure - fallback to character-by-character rendering
      console.warn('BitmapText: Batch rendering failed (cannot measure text), falling back to per-character rendering');
      return { missingAtlasChars, placeholdersUsed };
    }

    const metrics = measureResult.metrics;

    // Calculate scratch canvas dimensions in physical pixels
    // CRITICAL: Use FONT bounding box (not actual text bounding box)
    // This ensures we have room for ALL characters in the font, not just those in this text
    // Example: "hello" has small actualBoundingBoxAscent (x-height only)
    //          but we need room for "HELLO" (cap-height) when rendering any text
    const textWidth_PhysPx = Math.ceil(metrics.width * fontProperties.pixelDensity);
    const textHeight_PhysPx = Math.ceil(
      (metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent) * fontProperties.pixelDensity
    );

    // Safety check: ensure dimensions are reasonable
    if (textWidth_PhysPx <= 0 || textHeight_PhysPx <= 0 || textWidth_PhysPx > 32000 || textHeight_PhysPx > 32000) {
      console.warn(`BitmapText: Invalid scratch canvas dimensions (${textWidth_PhysPx}x${textHeight_PhysPx}), falling back`);
      return { missingAtlasChars, placeholdersUsed };
    }

    // Step 2: Setup scratch canvas sized for entire text block
    BitmapText.#coloredGlyphCanvas.width = textWidth_PhysPx;
    BitmapText.#coloredGlyphCanvas.height = textHeight_PhysPx;
    BitmapText.#coloredGlyphCtx.clearRect(0, 0, textWidth_PhysPx, textHeight_PhysPx);

    // Step 3: Draw ALL glyphs to scratch canvas in their original black form
    // Position relative to scratch canvas origin (not main canvas)
    const position_PhysPx = {
      // Horizontal: Start at actualBoundingBoxLeft to account for glyphs that protrude left (e.g., italic 'f')
      x: metrics.actualBoundingBoxLeft * fontProperties.pixelDensity,
      // Vertical: Position bottom baseline at the bottom of the full em square within scratch canvas
      // This is fontBoundingBoxAscent + fontBoundingBoxDescent from the top (i.e., at the canvas bottom)
      // Glyphs will draw upward from here using their negative dy offsets
      y: (metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent) * fontProperties.pixelDensity
    };

    for (let i = 0; i < chars.length; i++) {
      const currentChar = chars[i];
      const nextChar = chars[i + 1];

      // Track missing characters
      if (currentChar !== ' ' && !atlasData.hasPositioning(currentChar)) {
        missingAtlasChars.add(currentChar);
        placeholdersUsed = true;
        // Advance position even for missing characters to maintain layout
        position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(
          fontMetrics, fontProperties, currentChar, nextChar, textProperties
        );
        continue;
      }

      // Draw glyph to scratch canvas (skip spaces, they have no visual)
      if (currentChar !== ' ' && atlasData.hasPositioning(currentChar)) {
        const atlasPositioning = atlasData.atlasPositioning.getPositioning(currentChar);
        const atlasImage = atlasData.atlasImage.image;
        const { xInAtlas, tightWidth, tightHeight, dx, dy } = atlasPositioning;

        // Draw original glyph (black) to scratch canvas at correct position
        BitmapText.#coloredGlyphCtx.drawImage(
          atlasImage,
          xInAtlas, 0,
          tightWidth, tightHeight,
          Math.round(position_PhysPx.x + dx),
          Math.round(position_PhysPx.y + dy),
          tightWidth, tightHeight
        );
      }

      // Advance position for next character
      position_PhysPx.x += BitmapText.#calculateCharacterAdvancement_PhysPx(
        fontMetrics, fontProperties, currentChar, nextChar, textProperties
      );
    }

    // Step 4: Apply color transformation ONCE to entire text
    // This is the key optimization - only ONE composite operation instead of N
    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-in';
    BitmapText.#coloredGlyphCtx.fillStyle = textProperties.textColor;
    BitmapText.#coloredGlyphCtx.fillRect(0, 0, textWidth_PhysPx, textHeight_PhysPx);

    // Reset composite operation for future use
    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-over';

    // Step 5: Copy entire colored text block to main canvas ONCE
    // POSITIONING GEOMETRY:
    // - Main canvas: startPosition_PhysPx.y is at the bottom baseline (textBaseline='bottom')
    // - Scratch canvas: bottom baseline is at y = textHeight_PhysPx (the canvas bottom)
    // - To align baselines: scratch canvas top = startPosition_PhysPx.y - textHeight_PhysPx
    // - Horizontal: account for actualBoundingBoxLeft offset (glyphs that protrude left)
    ctx.drawImage(
      BitmapText.#coloredGlyphCanvas,
      0, 0,
      textWidth_PhysPx, textHeight_PhysPx,
      Math.round(startPosition_PhysPx.x - metrics.actualBoundingBoxLeft * fontProperties.pixelDensity),
      Math.round(startPosition_PhysPx.y - textHeight_PhysPx),
      textWidth_PhysPx, textHeight_PhysPx
    );

    return { missingAtlasChars, placeholdersUsed };
  }

  // Rendering optimizations:
  // 1. ✓ IMPLEMENTED: Black text fast path (see #drawCharacterDirect for 2-3x speedup)
  // 2. ✓ IMPLEMENTED: Batch colored text rendering (single composite operation per text string)
  // 3. FUTURE: Cache colored glyphs in LRU cache to avoid re-coloring same characters
  static #drawCharacter(ctx, char, position_PhysPx, atlasData, fontMetrics, textColor) {
    // If atlasData is missing but metrics exist, draw simplified placeholder rectangle
    if (!BitmapText.#isValidAtlas(atlasData)) {
      const characterMetrics = fontMetrics.getCharacterMetrics(char);
      if (characterMetrics) {
        BitmapText.#drawPlaceholderRectangle(ctx, char, position_PhysPx, characterMetrics, textColor);
      }
      return;
    }

    // FAST PATH: Black text renders directly from atlas (2-3x faster)
    // Skips scratch canvas + composite operations when using default color
    if (textColor === BitmapText.#DEFAULT_TEXT_COLOR) {
      BitmapText.#drawCharacterDirect(ctx, char, position_PhysPx, atlasData, fontMetrics);
      return;
    }

    // NOTE: Colored text now uses batch rendering in drawTextFromAtlas
    // This method is kept for compatibility/fallback but should rarely be called for colored text
    // SLOW PATH: Colored text requires double-pass rendering
    // 1. Copy glyph from atlas to scratch canvas
    // 2. Apply color using composite operation
    // 3. Draw colored glyph to main canvas
    if (!atlasData.hasPositioning(char)) return;

    const atlasPositioning = atlasData.atlasPositioning.getPositioning(char);
    const atlasImage = atlasData.atlasImage.image;
    const coloredGlyphCanvas = BitmapText.#createColoredGlyph(atlasImage, atlasPositioning, textColor);
    BitmapText.#renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position_PhysPx, atlasPositioning);
  }

  static #createColoredGlyph(atlasImage, atlasPositioning, textColor) {
    const { xInAtlas, tightWidth, tightHeight } = atlasPositioning;

    // Setup temporary canvas, same size as the glyph
    BitmapText.#coloredGlyphCanvas.width = tightWidth;
    BitmapText.#coloredGlyphCanvas.height = tightHeight;
    BitmapText.#coloredGlyphCtx.clearRect(0, 0, tightWidth, tightHeight);

    // Draw original glyph
    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-over';
    BitmapText.#coloredGlyphCtx.drawImage(
      atlasImage,
      xInAtlas, 0,
      tightWidth, tightHeight,
      0, 0,
      tightWidth, tightHeight
    );

    // Apply color
    BitmapText.#coloredGlyphCtx.globalCompositeOperation = 'source-in';
    BitmapText.#coloredGlyphCtx.fillStyle = textColor;
    BitmapText.#coloredGlyphCtx.fillRect(0, 0, tightWidth, tightHeight);

    return BitmapText.#coloredGlyphCanvas;
  }

  static #renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position_PhysPx, atlasPositioning) {
    const { tightWidth, tightHeight, dx, dy } = atlasPositioning;

    // Round coordinates at draw stage for crisp, pixel-aligned rendering
    // Position tracking uses floats to avoid accumulation errors, but final
    // draw coordinates must be integers to prevent subpixel antialiasing
    // see https://stackoverflow.com/a/6061102
    ctx.drawImage(
      coloredGlyphCanvas,
      0, 0,
      tightWidth, tightHeight,
      Math.round(position_PhysPx.x + dx),
      Math.round(position_PhysPx.y + dy),
      tightWidth, tightHeight
    );
  }

  /**
   * Fast path: Draw character directly from atlas (black text only)
   * Skips scratch canvas and color composite operations for 2-3x faster rendering
   * @private
   */
  static #drawCharacterDirect(ctx, char, position_PhysPx, atlasData, fontMetrics) {
    if (!atlasData.hasPositioning(char)) return;

    const atlasPositioning = atlasData.atlasPositioning.getPositioning(char);
    const atlasImage = atlasData.atlasImage.image;
    const { xInAtlas, tightWidth, tightHeight, dx, dy } = atlasPositioning;

    // Single drawImage operation: atlas → main canvas
    // Round coordinates at draw stage for crisp, pixel-aligned rendering
    // Position tracking uses floats to avoid accumulation errors, but final
    // draw coordinates must be integers to prevent subpixel antialiasing
    ctx.drawImage(
      atlasImage,
      xInAtlas, 0,
      tightWidth, tightHeight,
      Math.round(position_PhysPx.x + dx),
      Math.round(position_PhysPx.y + dy),
      tightWidth, tightHeight
    );
  }

  static #drawPlaceholderRectangle(ctx, char, position_PhysPx, characterMetrics, textColor) {
    if (char === ' ') return;

    if (characterMetrics.actualBoundingBoxLeft === undefined ||
        characterMetrics.actualBoundingBoxRight === undefined ||
        characterMetrics.actualBoundingBoxAscent === undefined ||
        characterMetrics.actualBoundingBoxDescent === undefined) {
      console.warn(`Missing bounding box metrics for character '${char}'`);
      return;
    }

    const pixelDensity = characterMetrics.pixelDensity || 1;

    // Use CHARACTER-SPECIFIC actual bounding box (not font-wide fontBoundingBox)
    // This makes:
    // - 'a' shorter than 'A' (x-height vs cap-height)
    // - 'g' extends below baseline (shows descender)
    // - '.' very short (near baseline only)
    // Width: actualBoundingBoxLeft + actualBoundingBoxRight (CSS px) * pixelDensity → physical px
    // Height: actualBoundingBoxAscent + actualBoundingBoxDescent (CSS px) * pixelDensity → physical px
    const width_PhysPx = Math.round(
      characterMetrics.actualBoundingBoxLeft + characterMetrics.actualBoundingBoxRight
    ) * pixelDensity;


    const height_PhysPx = Math.round(
      characterMetrics.actualBoundingBoxAscent + characterMetrics.actualBoundingBoxDescent
    ) * pixelDensity;

    // X position: Account for actualBoundingBoxLeft (glyphs may protrude left, e.g., italic 'f')
    // This matches the dx offset calculation in atlas rendering (AtlasPositioningFAB.js:92)
    const rectX_PhysPx = position_PhysPx.x
      - Math.round(characterMetrics.actualBoundingBoxLeft) * pixelDensity;

    // Y position calculation:
    // - position_PhysPx.y is at em square BOTTOM (textBaseline='bottom')
    // - Em square bottom is fontBoundingBoxDescent below the alphabetic baseline
    // - So: alphabetic_baseline_y = position_PhysPx.y - fontBoundingBoxDescent * pixelDensity
    // - Character top = alphabetic_baseline_y - actualBoundingBoxAscent * pixelDensity
    // Result: rectY = position_PhysPx.y - fontBoundingBoxDescent * pixelDensity - actualBoundingBoxAscent * pixelDensity
    const rectY_PhysPx = position_PhysPx.y
      - characterMetrics.fontBoundingBoxDescent * pixelDensity
      - characterMetrics.actualBoundingBoxAscent * pixelDensity;

    const actualColor = textColor || 'black';

    // Draw character-specific rectangle
    // Round coordinates at draw stage for crisp, pixel-aligned rendering
    // Position tracking uses floats to avoid accumulation errors, but final
    // draw coordinates must be integers to prevent subpixel antialiasing
    ctx.fillStyle = actualColor;
    ctx.fillRect(
      Math.round(rectX_PhysPx),
      Math.round(rectY_PhysPx),
      Math.round(width_PhysPx),
      Math.round(height_PhysPx)
    );
  }

  static #calculateCharacterAdvancement_PhysPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties) {
    return this.calculateAdvancement_CssPx(fontMetrics, fontProperties, currentChar, nextChar, textProperties)
      * fontProperties.pixelDensity;
  }

  /**
   * Check if atlas data is valid and ready for rendering
   * @private
   * @param {*} atlasData - Potential AtlasData instance
   * @returns {boolean} True if atlasData is an AtlasData instance and is valid
   */
  static #isValidAtlas(atlasData) {
    if (!(atlasData instanceof AtlasData)) {
      return false;
    }
    return atlasData.isValid();
  }

  // ============================================
  // Loading API (Delegates to FontLoader)
  // ============================================

  /**
   * Load a single font
   * @param {string} idString - Font ID string
   * @param {Object} options - Loading options
   * @param {Function} [options.onProgress] - Progress callback (loaded, total)
   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol
   * @returns {Promise} Resolves when font is loaded
   */
  static async loadFont(idString, options = {}) {
    BitmapText.#ensureFontLoader();
    return BitmapText.#fontLoader.loadFont(idString, options, BitmapText);
  }

  /**
   * Load multiple fonts
   * @param {Array<string>} idStrings - Array of font ID strings
   * @param {Object} options - Loading options
   * @param {Function} [options.onProgress] - Progress callback (loaded, total)
   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol
   * @param {boolean} [options.loadMetrics] - Load metrics (default: true)
   * @param {boolean} [options.loadAtlases] - Load atlases (default: true)
   * @returns {Promise} Resolves when all fonts are loaded
   */
  static async loadFonts(idStrings, options = {}) {
    BitmapText.#ensureFontLoader();
    return BitmapText.#fontLoader.loadFonts(idStrings, options, BitmapText);
  }

  /**
   * Load only metrics for fonts
   * @param {Array<string>} idStrings - Array of font ID strings
   * @param {Object} options - Loading options
   * @returns {Promise} Resolves when metrics are loaded
   */
  static async loadMetrics(idStrings, options = {}) {
    BitmapText.#ensureFontLoader();
    return BitmapText.#fontLoader.loadMetrics(idStrings, options, BitmapText);
  }

  /**
   * Load only atlases for fonts (metrics must be loaded first)
   * @param {Array<string>} idStrings - Array of font ID strings
   * @param {Object} options - Loading options
   * @returns {Promise} Resolves when atlases are loaded
   */
  static async loadAtlases(idStrings, options = {}) {
    BitmapText.#ensureFontLoader();
    return BitmapText.#fontLoader.loadAtlases(idStrings, options, BitmapText);
  }

  // ============================================
  // Builder/Testing Tool API
  // ============================================

  /**
   * Set atlas data for a font (for builder/testing tools)
   * Public API - delegates to AtlasDataStore
   * @param {FontProperties} fontProperties - Font configuration
   * @param {AtlasData} atlasData - Atlas data to store
   */
  static setAtlasData(fontProperties, atlasData) {
    AtlasDataStore.setAtlasData(fontProperties, atlasData);
  }

  /**
   * Get atlas data for a font
   * Public API - delegates to AtlasDataStore
   * @param {FontProperties} fontProperties - Font configuration
   * @returns {AtlasData|undefined} Atlas data or undefined if not found
   */
  static getAtlasData(fontProperties) {
    return AtlasDataStore.getAtlasData(fontProperties);
  }

  /**
   * Delete atlas data for a font
   * Public API - delegates to AtlasDataStore
   * @param {FontProperties} fontProperties - Font configuration
   * @returns {boolean} True if atlas was deleted
   */
  static deleteAtlas(fontProperties) {
    return AtlasDataStore.deleteAtlas(fontProperties);
  }

  /**
   * Set font metrics for a font (for builder/testing tools)
   * Public API - delegates to FontMetricsStore
   * @param {FontProperties} fontProperties - Font configuration
   * @param {FontMetrics} fontMetrics - Font metrics to store
   */
  static setFontMetrics(fontProperties, fontMetrics) {
    FontMetricsStore.setFontMetrics(fontProperties, fontMetrics);
  }

  /**
   * Get font metrics for a font
   * Public API - delegates to FontMetricsStore
   * @param {FontProperties} fontProperties - Font configuration
   * @returns {FontMetrics|undefined} Font metrics or undefined if not found
   */
  static getFontMetrics(fontProperties) {
    return FontMetricsStore.getFontMetrics(fontProperties);
  }

  /**
   * Unload both metrics and atlas for a font
   * @param {string} idString - Font ID string
   */
  static unloadFont(idString) {
    const fontProperties = FontProperties.fromIDString(idString);
    FontMetricsStore.deleteFontMetrics(fontProperties);
    AtlasDataStore.deleteAtlas(fontProperties);
  }

  /**
   * Unload multiple fonts
   * @param {Array<string>} idStrings - Array of font ID strings
   */
  static unloadFonts(idStrings) {
    idStrings.forEach(id => this.unloadFont(id));
  }

  /**
   * Unload metrics (cascades to unload atlas)
   * @param {string} idString - Font ID string
   */
  static unloadMetrics(idString) {
    const fontProperties = FontProperties.fromIDString(idString);
    FontMetricsStore.deleteFontMetrics(fontProperties);
    AtlasDataStore.deleteAtlas(fontProperties); // Cascade: no metrics = no atlas
  }

  /**
   * Unload atlas only (keeps metrics)
   * @param {string} idString - Font ID string
   */
  static unloadAtlas(idString) {
    const fontProperties = FontProperties.fromIDString(idString);
    AtlasDataStore.deleteAtlas(fontProperties);
  }

  /**
   * Unload all fonts (both metrics and atlases)
   */
  static unloadAllFonts() {
    FontMetricsStore.clear();
    AtlasDataStore.clear();
  }

  /**
   * Unload all atlases (keep metrics)
   */
  static unloadAllAtlases() {
    AtlasDataStore.clear();
  }

  // ============================================
  // Query API
  // ============================================

  /**
   * Check if font is fully loaded (both metrics and atlas)
   * @param {string} idString - Font ID string
   * @returns {boolean} True if both metrics and atlas are loaded
   */
  static hasFont(idString) {
    return this.hasMetrics(idString) && this.hasAtlas(idString);
  }

  /**
   * Check if metrics are loaded for a font
   * @param {string} idString - Font ID string
   * @returns {boolean} True if metrics are loaded
   */
  static hasMetrics(idString) {
    const fontProperties = FontProperties.fromIDString(idString);
    return FontMetricsStore.hasFontMetrics(fontProperties);
  }

  /**
   * Check if atlas is loaded for a font
   * @param {string} idString - Font ID string
   * @returns {boolean} True if atlas is loaded
   */
  static hasAtlas(idString) {
    const fontProperties = FontProperties.fromIDString(idString);
    const atlasData = AtlasDataStore.getAtlasData(fontProperties);
    return atlasData && BitmapText.#isValidAtlas(atlasData);
  }

  /**
   * Get list of fully loaded fonts (both metrics and atlas)
   * @returns {Array<string>} Array of font ID strings
   */
  static getLoadedFonts() {
    const loaded = [];
    for (const key of FontMetricsStore.getAvailableFonts()) {
      const fontProperties = FontProperties.fromKey(key);
      const atlasData = AtlasDataStore.getAtlasData(fontProperties);
      if (atlasData && BitmapText.#isValidAtlas(atlasData)) {
        loaded.push(fontProperties.idString);
      }
    }
    return loaded;
  }

  /**
   * Get list of fonts with loaded metrics
   * @returns {Array<string>} Array of font ID strings
   */
  static getLoadedMetrics() {
    const loaded = [];
    for (const key of FontMetricsStore.getAvailableFonts()) {
      const fontProperties = FontProperties.fromKey(key);
      loaded.push(fontProperties.idString);
    }
    return loaded;
  }

  /**
   * Get list of fonts with loaded atlases
   * @returns {Array<string>} Array of font ID strings
   */
  static getLoadedAtlases() {
    const loaded = [];
    for (const key of AtlasDataStore.getAvailableFonts()) {
      const fontProperties = FontProperties.fromKey(key);
      const atlasData = AtlasDataStore.getAtlasData(fontProperties);
      if (BitmapText.#isValidAtlas(atlasData)) {
        loaded.push(fontProperties.idString);
      }
    }
    return loaded;
  }

  // ============================================
  // Testing Helpers
  // ============================================

  /**
   * Reset all state for testing
   * @private
   */
  static __resetForTesting() {
    FontMetricsStore.clear();
    AtlasDataStore.clear();
    // Clear FontLoader state
    if (FontLoaderBase._loadingPromises) {
      FontLoaderBase._loadingPromises.clear();
    }
    if (FontLoaderBase._tempAtlasPackages) {
      FontLoaderBase._tempAtlasPackages = {};
    }
    if (FontLoaderBase._pendingAtlases) {
      FontLoaderBase._pendingAtlases.clear();
    }
    // Reset FontLoader configuration
    if (FontLoaderBase.setFontDirectory) {
      FontLoaderBase.setFontDirectory(null);
    }
    BitmapText.#coloredGlyphCanvas = null;
    BitmapText.#coloredGlyphCtx = null;
    BitmapText.#canvasFactory = null;
    BitmapText.#fontLoader = null;
  }

  // ============================================
  // Character Set Generation
  // ============================================

  /**
   * Generate character set programmatically
   * Creates a sorted string of 204 characters including:
   * - ASCII printable (32-126): 95 characters
   * - Windows-1252 subset (128-159): 14 characters
   * - Latin-1 Supplement (161-255): 94 characters (excluding soft hyphen)
   * - Full Block character (█): 1 character
   * @private
   * @returns {string} Sorted character set string
   */
  static #generateCharacterSet() {
    const chars = [];

    // ASCII printable characters (32-126)
    // Includes space, numbers, letters, and common symbols
    for (let i = 32; i <= 126; i++) {
      chars.push(String.fromCharCode(i));
    }

    // A selection from Windows-1252 (CP-1252) printable characters.
    // This is the most standard definition of "extended ASCII codes" from 128 to 159
    // and many of these are common/useful symbols that people "expect to have".
    // However fromCharCode doesn't work on those as that range is not defined
    // in UTF-8/Unicode (modern web standard, so we want to include (some of) them but we have
    // to map them to specific Unicode code points, not the byte values themselves.
    // NOTE: we could likely shave some of these off, as they are not easily printable
    // in Javascript and some of them are fairly arcane/
    const cp1252PrintableChars = [
      8364, // € Euro sign (CP-1252: 128)
      //  8218, // ‚ Single low-9 quotation mark (CP-1252: 130)
      //  402,  // ƒ Latin small letter f with hook (CP-1252: 131)
      //  8222, // „ Double low-9 quotation mark (CP-1252: 132)
      8230, // … Horizontal ellipsis (CP-1252: 133)
      //  8224, // † Dagger (CP-1252: 134)
      //  8225, // ‡ Double dagger (CP-1252: 135)
      //  710,  // ˆ Modifier letter circumflex accent (CP-1252: 136)
      8240, // ‰ Per mille sign (CP-1252: 137)
      //  352,  // Š Latin capital letter S with caron (CP-1252: 138)
      8249, // ‹ Single left-pointing angle quotation (CP-1252: 139)
      //  338,  // Œ Latin capital ligature OE (CP-1252: 140)
      381,  // Ž Latin capital letter Z with caron (CP-1252: 142)
      //  8216, // ' Left single quotation mark (CP-1252: 145)

      // UNFORTUNATELY SOMETIMES USED INSTEAD OF APOSTROPHE
      8217, // ' ""curly apostrophe"" or "right single quotation mark" (CP-1252: 146)

      //  8220, // " Left double quotation mark (CP-1252: 147)
      //  8221, // " Right double quotation mark (CP-1252: 148)
      8226, // • Bullet (CP-1252: 149)
      //  8211, // – En dash (CP-1252: 150)
      8212, // — Em dash (CP-1252: 151)
      //  732,  // ˜ Small tilde (CP-1252: 152)
      8482, // ™ Trade mark sign (CP-1252: 153)
      353,  // š Latin small letter s with caron (CP-1252: 154)
      8250, // › Single right-pointing angle quotation mark (CP-1252: 155)
      339,  // œ Latin small ligature oe (CP-1252: 156)
      382,  // ž Latin small letter z with caron (CP-1252: 158)
      376   // Ÿ Latin capital letter Y with diaeresis (CP-1252: 159)
    ];

    for (const code of cp1252PrintableChars) {
      chars.push(String.fromCharCode(code));
    }

    // Latin-1 Supplement characters (161-255)
    // These are properly defined in UTF-8/Unicode
    // Exclude U+00AD (173) - soft hyphen, which has zero width
    for (let i = 161; i <= 255; i++) {
      if (i !== 173) { // Skip soft hyphen
        chars.push(String.fromCharCode(i));
      }
    }

    // Add Full Block character (allows us to see the maximum space taken by a glyph)
    chars.push('█');

    // Sort the character set (this is how it's used throughout the codebase)
    return chars.sort().join('');
  }
}

// TIER 6b OPTIMIZATION: Short aliases for registration methods (saves ~15 bytes per file)
BitmapText.r = BitmapText.registerMetrics;
BitmapText.a = BitmapText.registerAtlas;

// ============================================================================
// METRICS EXPANDER
// ============================================================================
// Static utility class for expanding minified font metrics data (runtime only)
// Converts compact format back to FontMetrics instances for use by the rendering engine
// NOTE: Requires BitmapText.js to be loaded first (uses BitmapText.CHARACTER_SET)

class MetricsExpander {
  // Private constructor - prevent instantiation following Effective Java patterns
  constructor() {
    throw new Error('MetricsExpander cannot be instantiated - use static methods');
  }

  /**
   * TIER 6c OPTIMIZATION: Decode base64 string to array of integers
   * Reverses the base64 byte encoding from MetricsMinifier
   *
   * @param {string} base64 - Base64 encoded string
   * @returns {Array<number>} Array of integers (0-255)
   */
  static #decodeFromBase64Bytes(base64) {
    // In browser: use atob
    // In Node.js: use Buffer
    let bytes;

    if (typeof Buffer !== 'undefined') {
      // Node.js environment
      bytes = Buffer.from(base64, 'base64');
    } else {
      // Browser environment
      const binary = atob(base64);
      bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
    }

    return Array.from(bytes);
  }

  /**
   * TIER 6c OPTIMIZATION: Decode varint+zigzag+base64 to signed integers
   * Reverses the VarInt encoding from MetricsMinifier
   *
   * @param {string} base64 - Base64 encoded varint bytes
   * @returns {Array<number>} Array of signed integers
   */
  static #decodeVarInts(base64) {
    const bytes = this.#decodeFromBase64Bytes(base64);
    const integers = [];
    let i = 0;

    while (i < bytes.length) {
      // Decode VarInt: 7 bits per byte, MSB indicates continuation
      let value = 0;
      let shift = 0;
      let byte;

      do {
        byte = bytes[i++];
        value |= (byte & 0x7F) << shift;
        shift += 7;
      } while (byte & 0x80);

      // Zigzag decoding: convert unsigned back to signed
      // 0→0, 1→-1, 2→1, 3→-2, 4→2, ...
      const signed = (value & 1) ? -(value + 1) / 2 : value / 2;
      integers.push(signed);
    }

    return integers;
  }

  /**
   * TIER 7 OPTIMIZATION: Decompress value lookup array from delta encoding + base64
   *
   * Reverses the compression:
   * 1. Decode base64 → varint → zigzag → deltas
   * 2. Reconstruct sorted values from deltas
   * 3. Return as unsorted array (order doesn't matter for lookup)
   *
   * @param {string} base64 - Base64 encoded delta-compressed string
   * @returns {Array<number>} Array of metric value integers
   */
  static #decompressValueArray(base64) {
    // Decode base64 → deltas
    const deltas = this.#decodeVarInts(base64);

    // Reconstruct sorted values from deltas
    const sorted = [deltas[0]]; // First value is absolute
    for (let i = 1; i < deltas.length; i++) {
      sorted.push(sorted[i - 1] + deltas[i]);
    }

    // Return as-is (order doesn't matter for value lookup)
    // The indices in tuplets refer to sorted positions
    return sorted;
  }

  /**
   * Expands minified metrics back to FontMetrics instance for runtime use
   * TIER 7 FORMAT (backward compatible with Tier 6c)
   *
   * @param {Array} minified - Minified metrics array [kv, k, b, v, t, g, s, cl]
   *   - v can be array (Tier 6c) or base64 string (Tier 7)
   * @returns {FontMetrics} FontMetrics instance with expanded data
   * @throws {Error} If invalid format detected
   */
  static expand(minified) {
    // Check if FontMetrics class is available
    if (typeof FontMetrics === 'undefined') {
      throw new Error('FontMetrics class not found. Please ensure FontMetrics.js is loaded before MetricsExpander.js');
    }

    // Validate Tier 6c format: 8-element array only
    if (!Array.isArray(minified) || minified.length !== 8) {
      throw new Error(
        `Invalid format - expected 8-element array (Tier 6c), got ${typeof minified === 'object' ? 'array' : typeof minified} with ${minified?.length || 0} elements.\n` +
        `Please regenerate font assets with the current version.`
      );
    }

    // Extract values from Tier 6c/7 array format
    let [kv, k, b, v, t, g, s, cl] = minified;

    // Convert integer values back to floats (divide by 10000)
    kv = this.#convertIntegersToValues(kv);

    // TIER 7: Handle value lookup array - can be array (Tier 6c) or base64 string (Tier 7)
    if (typeof v === 'string') {
      // Tier 7: Decompress from delta-encoded base64
      v = this.#decompressValueArray(v);
      v = this.#convertIntegersToValues(v);
    } else if (Array.isArray(v)) {
      // Tier 6c: Already an array of integers
      v = this.#convertIntegersToValues(v);
    } else {
      throw new Error('Invalid value lookup format - expected array or string');
    }

    // Unflatten baseline array to object
    b = this.#unflattenBaseline(b);

    // Decode base64-encoded binary data
    // t = VarInt+zigzag encoded flattened tuplets
    // g = byte-encoded tuplet indices
    t = this.#decodeVarInts(t);
    g = this.#decodeFromBase64Bytes(g);

    // Unflatten tuplet data from negative-delimiter format
    t = this.#unflattenTuplets(t);

    const expandedData = {
      kerningTable: this.#expandKerningTable(k, kv),
      characterMetrics: this.#expandCharacterMetrics(g, b, v, t, cl),
      spaceAdvancementOverrideForSmallSizesInPx: s
    };

    // Verify pixelDensity was preserved
    const firstChar = Object.keys(expandedData.characterMetrics)[0];
    const pixelDensity = expandedData.characterMetrics[firstChar]?.pixelDensity;
    console.debug(`🔍 MetricsExpander: Restored pixelDensity=${pixelDensity} for ${Object.keys(expandedData.characterMetrics).length} characters`);

    return new FontMetrics(expandedData);
  }
  
  /**
   * Expands kerning table with range notation support
   * TIER 3 OPTIMIZATION: Two-dimensional expansion (reverse order of compression)
   * TIER 4 OPTIMIZATION: Value indexing (looks up actual kerning values from indices)
   *   Pass 1 (left-side):  {"A-B":{"s":0}} → {"A":{"s":0},"B":{"s":0}}
   *   Pass 2 (right-side): {"A":{"0-1":0}} → {"A":{"0":0,"1":0}}
   *   Pass 3 (values):     {"A":{"s":0}} → {"A":{"s":20}} (lookup from kerningValueLookup[0])
   * Always uses BitmapText.CHARACTER_SET for range expansion
   * Later entries override earlier ones, allowing exceptions to ranges
   * @param {Object} minified - Minified kerning table with indexed values
   * @param {Array} kerningValueLookup - Value lookup table for kerning values
   * @private
   */
  static #expandKerningTable(minified, kerningValueLookup) {
    // PASS 1: Expand left side (characters that come before)
    const leftExpanded = this.#expandLeftSide(minified);

    // PASS 2: Expand right side (characters that follow)
    const rangeExpanded = {};
    for (const [leftChar, pairs] of Object.entries(leftExpanded)) {
      rangeExpanded[leftChar] = this.#expandKerningPairs(pairs);
    }

    // PASS 3 (TIER 4): Replace all indices with actual values from lookup table
    const expanded = {};
    for (const [leftChar, pairs] of Object.entries(rangeExpanded)) {
      expanded[leftChar] = {};
      for (const [rightChar, index] of Object.entries(pairs)) {
        expanded[leftChar][rightChar] = kerningValueLookup[index];
      }
    }

    return expanded;
  }

  /**
   * Expands left side of kerning table (characters that come before)
   * TIER 3 OPTIMIZATION: Two-dimensional expansion pass 1
   * Handles left-side range notation like "A-C":{"s":20} → {"A":{"s":20},"B":{"s":20},"C":{"s":20}}
   * Always uses BitmapText.CHARACTER_SET for range expansion
   * @param {Object} minified - Minified kerning table with potential left-side ranges
   * @returns {Object} Left-expanded kerning table
   * @private
   */
  static #expandLeftSide(minified) {
    const expanded = {};

    // Process entries in order so later entries can override earlier ones
    for (const [key, rightSideObj] of Object.entries(minified)) {
      if (key.includes('-') && key.length >= 3) {
        // Potential range notation (e.g., "A-Z" or "0-9")
        const hyphenIndex = key.indexOf('-');
        const startChar = key.substring(0, hyphenIndex);
        const endChar = key.substring(hyphenIndex + 1);

        // Check if both start and end are single characters in the character set
        if (startChar.length === 1 && endChar.length === 1) {
          const startIndex = BitmapText.CHARACTER_SET.indexOf(startChar);
          const endIndex = BitmapText.CHARACTER_SET.indexOf(endChar);

          if (startIndex !== -1 && endIndex !== -1 && startIndex <= endIndex) {
            // Valid range, expand it
            for (let i = startIndex; i <= endIndex; i++) {
              expanded[BitmapText.CHARACTER_SET[i]] = rightSideObj;
            }
            continue;
          }
        }
      }

      // Not a range, or invalid range - treat as literal character
      expanded[key] = rightSideObj;
    }

    return expanded;
  }

  /**
   * Expands kerning pairs from compact string notation to individual character pairs
   * TIER 6b OPTIMIZATION: Handles advanced compact notation with non-sequential grouping
   *
   * Parses compact strings like "-,.:;ac-egj-s" which means:
   * - Dash at START is literal
   * - Individual chars: comma, dot, colon, semicolon
   * - Ranges: a, c-e (c,d,e), g, j-s (j,k,l,m,n,o,p,q,r,s)
   *
   * Always uses BitmapText.CHARACTER_SET for range expansion
   * @param {Object} pairs - Compressed pairs like {"-,.:;ac-egj-s":20}
   * @returns {Object} Expanded pairs like {"-":20,",":20,".":20,...,"s":20}
   * @private
   */
  static #expandKerningPairs(pairs) {
    const expanded = {};

    // Process entries in order so later entries can override earlier ones
    for (const [key, value] of Object.entries(pairs)) {
      // Parse the compact string notation
      const chars = this.#parseCompactCharString(key);

      // Assign value to all parsed characters
      for (const char of chars) {
        expanded[char] = value;
      }
    }

    return expanded;
  }

  /**
   * Parses compact character string notation
   * TIER 6b OPTIMIZATION: Handles dash-at-start and range notation
   *
   * Format:
   * - First char is dash → literal dash character
   * - "a-z" → range from a to z
   * - "abc" → individual characters a, b, c
   * - "-,.:;ac-egj-s" → dash, comma, dot, colon, semicolon, a, c-e range, g, j-s range
   *
   * @param {string} compactStr - Compact string like "-,.:;ac-egj-s"
   * @returns {string[]} Array of individual characters
   * @private
   */
  static #parseCompactCharString(compactStr) {
    const chars = [];
    let i = 0;

    // Handle dash at start (literal)
    if (compactStr[0] === '-') {
      chars.push('-');
      i = 1;
    }

    // Parse rest of string
    while (i < compactStr.length) {
      const currentChar = compactStr[i];

      // Check if this is the start of a range pattern
      if (i + 2 < compactStr.length && compactStr[i + 1] === '-') {
        // Pattern: "X-Y" where X and Y are single characters
        const startChar = currentChar;
        const endChar = compactStr[i + 2];

        // Verify it's a valid range in BitmapText.CHARACTER_SET
        const startIndex = BitmapText.CHARACTER_SET.indexOf(startChar);
        const endIndex = BitmapText.CHARACTER_SET.indexOf(endChar);

        if (startIndex !== -1 && endIndex !== -1 && startIndex < endIndex) {
          // Valid range - expand it
          for (let j = startIndex; j <= endIndex; j++) {
            chars.push(BitmapText.CHARACTER_SET[j]);
          }
          i += 3; // Skip X, -, Y
        } else {
          // Not a valid range - treat as individual characters
          chars.push(currentChar);
          i++;
        }
      } else {
        // Individual character
        chars.push(currentChar);
        i++;
      }
    }

    return chars;
  }
  
  /**
   * Expands glyph metrics from arrays back to full objects
   * TIER 2 OPTIMIZATION: Reconstructs from array of arrays using BitmapText.CHARACTER_SET
   * TIER 4 OPTIMIZATION: Looks up actual values from indices using valueLookup table
   * TIER 5a OPTIMIZATION: Decompresses variable-length tuplets (2/3/4/5 elements)
   * TIER 5b OPTIMIZATION: Looks up tuplets from tuplet indices
   * TIER 6b OPTIMIZATION: 2-element tuplets using common left index
   *
   * Tuplet decompression (deterministic based on length):
   *   - Length 2: [w, a] → [w, CL, w, a, CL]  (w===r AND l===CL AND d===CL)
   *   - Length 3: [w, l, a] → [w, l, w, a, l]  (w===r AND l===d)
   *   - Length 4: [w, l, a, d] → [w, l, w, a, d]  (w===r only)
   *   - Length 5: [w, l, r, a, d] (no decompression)
   *
   * Reconstructs full TextMetrics-compatible objects from compact arrays
   * Always uses BitmapText.CHARACTER_SET for character order
   * @param {Array} tupletIndices - Array of tuplet indices (single integers)
   * @param {Object} metricsCommonToAllCharacters - Common metrics shared across all characters
   * @param {Array} valueLookup - Value lookup table mapping indices to actual values
   * @param {Array} tupletLookup - Tuplet lookup table mapping tuplet indices to index arrays
   * @param {number} [commonLeftIndex] - Common left bounding box index (Tier 6b, optional)
   * @private
   */
  static #expandCharacterMetrics(tupletIndices, metricsCommonToAllCharacters, valueLookup, tupletLookup, commonLeftIndex) {
    const expanded = {};

    // Convert BitmapText.CHARACTER_SET string to array of characters
    const chars = Array.from(BitmapText.CHARACTER_SET);

    // Reconstruct object by mapping array positions to characters
    chars.forEach((char, index) => {
      // TIER 5b: Look up tuplet from tuplet index
      const tupletIndex = tupletIndices[index];
      const compressed = tupletLookup[tupletIndex];

      let indices;

      // TIER 5+6b: Decompress tuplet based on length
      if (compressed.length === 2) {
        // Case D (TIER 6b): [w, a] → [w, CL, w, a, CL]
        // All three patterns: w===r AND l===CL AND d===CL
        if (commonLeftIndex === undefined) {
          throw new Error(
            `2-element tuplet found but no common left index provided.\n` +
            `Character "${char}" at index ${index}: [${compressed.join(',')}]\n` +
            `This indicates a corrupted Tier 6b font file. Please regenerate font assets.`
          );
        }
        indices = [
          compressed[0],    // width
          commonLeftIndex,  // left = common left
          compressed[0],    // right = width (pattern 1)
          compressed[1],    // ascent
          commonLeftIndex   // descent = common left (pattern 2)
        ];
      }
      else if (compressed.length === 3) {
        // Case C: [w, l, a] → [w, l, w, a, l]
        // Both w===r and l===d
        indices = [
          compressed[0],  // width
          compressed[1],  // left
          compressed[0],  // right = width (pattern 1)
          compressed[2],  // ascent
          compressed[1]   // descent = left (pattern 2)
        ];
      }
      else if (compressed.length === 4) {
        // Case B: [w, l, a, d] → [w, l, w, a, d]
        // Only w===r
        indices = [
          compressed[0],  // width
          compressed[1],  // left
          compressed[0],  // right = width (pattern 1)
          compressed[2],  // ascent
          compressed[3]   // descent
        ];
      }
      else if (compressed.length === 5) {
        // Case A: [w, l, r, a, d] - no decompression needed
        indices = compressed;
      }
      else {
        throw new Error(
          `Invalid glyph tuplet length for character "${char}" at index ${index}.\n` +
          `Expected 2, 3, 4, or 5 elements, got ${compressed.length}: [${compressed.join(',')}]\n` +
          `This indicates a corrupted font file. Please regenerate font assets.`
        );
      }

      // TIER 4: Look up actual values from indices
      const width = valueLookup[indices[0]];
      const actualBoundingBoxLeft = valueLookup[indices[1]];
      const actualBoundingBoxRight = valueLookup[indices[2]];
      const actualBoundingBoxAscent = valueLookup[indices[3]];
      const actualBoundingBoxDescent = valueLookup[indices[4]];

      expanded[char] = {
        // Glyph-specific metrics looked up from value table
        width,
        actualBoundingBoxLeft,
        actualBoundingBoxRight,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent,

        // Copy over the metrics common to all characters.
        // This is a bit of a waste of memory, however this object needs to
        // look as much as possible like a TextMetrics object, and this
        // is what it looks like.
        fontBoundingBoxAscent: metricsCommonToAllCharacters.fba,
        fontBoundingBoxDescent: metricsCommonToAllCharacters.fbd,
        emHeightAscent: metricsCommonToAllCharacters.fba,          // Same as fontBoundingBoxAscent
        emHeightDescent: metricsCommonToAllCharacters.fbd,         // Same as fontBoundingBoxDescent
        hangingBaseline: metricsCommonToAllCharacters.hb,
        alphabeticBaseline: metricsCommonToAllCharacters.ab,
        ideographicBaseline: metricsCommonToAllCharacters.ib,
        pixelDensity: metricsCommonToAllCharacters.pd              // pixelDensity (CRITICAL for atlas reconstruction)
      };
    });
    return expanded;
  }

  /**
   * Converts array of integer values back to floats by dividing by 10000
   * TIER 6 OPTIMIZATION: Integer to value conversion
   *
   * @param {number[]} integers - Array of integer values
   * @returns {number[]} Array of float values
   * @private
   */
  static #convertIntegersToValues(integers) {
    return integers.map(int => int / 10000);
  }

  /**
   * Unflattens baseline array back to object
   * TIER 6 OPTIMIZATION: Baseline array → object
   *
   * @param {number[]} baselineArray - Array [fba, fbd, hb, ab, ib, pd]
   * @returns {Object} Baseline object with {fba, fbd, hb, ab, ib, pd}
   * @private
   */
  static #unflattenBaseline(baselineArray) {
    if (!Array.isArray(baselineArray) || baselineArray.length !== 6) {
      throw new Error(
        `Invalid baseline array - expected 6 elements, got ${baselineArray?.length}.\n` +
        `This indicates a corrupted font file. Please regenerate font assets.`
      );
    }

    // Fixed order: fba, fbd, hb, ab, ib, pd
    return {
      fba: baselineArray[0],
      fbd: baselineArray[1],
      hb: baselineArray[2],
      ab: baselineArray[3],
      ib: baselineArray[4],
      pd: baselineArray[5]
    };
  }

  /**
   * Unflattens tuplet data from negative delimiter format
   * TIER 6b OPTIMIZATION: Tuplet array unflattening with negative delimiters
   *
   * Parses negative-delimited format and shifts back to 0-based indices.
   * Negative numbers mark the end of each tuplet.
   *
   * Converts: [3,2,-15,1,2,16,-8] → [[2,1,14],[0,1,15,7]]
   * Each tuplet ends with a negative number (1-based) which becomes last element (0-based)
   *
   * @param {number[]} flattened - Flattened array with negative delimiters (1-based indices)
   * @returns {Array<Array<number>>} Array of tuplet arrays (0-based indices)
   * @private
   */
  static #unflattenTuplets(flattened) {
    const tuplets = [];
    let currentTuplet = [];

    for (let i = 0; i < flattened.length; i++) {
      const value = flattened[i];

      if (value < 0) {
        // Negative marks end of tuplet
        // Negate back and subtract 1 to get 0-based index
        currentTuplet.push((-value) - 1);

        // Validate tuplet length
        if (currentTuplet.length < 2 || currentTuplet.length > 5) {
          throw new Error(
            `Invalid tuplet length ${currentTuplet.length} at position ${i}.\n` +
            `Expected 2, 3, 4, or 5. This indicates a corrupted font file.\n` +
            `Please regenerate font assets.`
          );
        }

        tuplets.push(currentTuplet);
        currentTuplet = [];
      } else {
        // Positive value: subtract 1 to get 0-based index
        currentTuplet.push(value - 1);
      }
    }

    // Check for incomplete tuplet at end
    if (currentTuplet.length > 0) {
      throw new Error(
        `Incomplete tuplet at end of data.\n` +
        `Found ${currentTuplet.length} elements without negative delimiter.\n` +
        `This indicates a corrupted font file. Please regenerate font assets.`
      );
    }

    return tuplets;
  }

}
// ============================================================================
// ATLAS POSITIONING CLASS
// ============================================================================
// AtlasPositioning - Core Runtime Class
//
// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).
// It encapsulates atlas positioning data for a single font configuration as an immutable domain object.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Extended by AtlasPositioningFAB for font assets building capabilities (if needed)
// - Contains only essential positioning data and accessor methods
// - No font generation, validation, or optimization code
//
// ARCHITECTURE:
// - Immutable object representing atlas positioning for ONE font configuration
// - Pre-computed lookups for optimal performance during glyph rendering
// - xInAtlas values are reconstructed from tightWidth during deserialization (not serialized)
// - Reconstruction happens once at load time, not per-character at render time
// - All positioning data stored in memory for O(1) access during rendering
// - Provides clean API for accessing glyph positioning within atlas
// - Follows same immutable pattern as FontProperties and FontMetrics
//
// SEPARATION RATIONALE:
// - Encapsulates related atlas positioning data together
// - Eliminates repeated parameter passing for positioning lookups
// - Serves as domain object for atlas positioning
// - Enables cleaner, more object-oriented API
//
class AtlasPositioning {
  constructor(data, options = {}) {
    // Validate input data structure
    if (!data || typeof data !== 'object') {
      throw new Error('AtlasPositioning constructor requires data object');
    }

    // Atlas positioning data for glyph rendering
    this._tightWidth = data.tightWidth || {};
    this._tightHeight = data.tightHeight || {};
    this._dx = data.dx || {};
    this._dy = data.dy || {};
    // NOTE: xInAtlas is reconstructed from tightWidth during deserialization (not serialized to reduce file size)
    // At build time: populated by AtlasPositioningFAB during atlas packing
    // At runtime: reconstructed by TightAtlasReconstructor during atlas loading
    this._xInAtlas = data.xInAtlas || {};

    // Freeze for immutability (safe to use as value object)
    // Skip freezing if this is for font assets building (FAB)
    if (!options.mutable) {
      Object.freeze(this._tightWidth);
      Object.freeze(this._tightHeight);
      Object.freeze(this._dx);
      Object.freeze(this._dy);
      Object.freeze(this._xInAtlas);
      Object.freeze(this);
    }
  }

  /**
   * Get positioning metrics for glyph rendering from atlas
   * @param {string} char - Character (code point) to get positioning for
   * @returns {Object} Object with xInAtlas, tightWidth, tightHeight, dx, dy
   */
  getPositioning(char) {
    return {
      xInAtlas: this._xInAtlas[char],
      tightWidth: this._tightWidth[char],
      tightHeight: this._tightHeight[char],
      dx: this._dx[char],
      dy: this._dy[char]
    };
  }

  /**
   * Check if positioning data exists for a character
   * @param {string} char - Character (code point) to check
   * @returns {boolean} True if positioning data exists
   */
  hasPositioning(char) {
    return this._xInAtlas[char] !== undefined &&
           this._tightWidth[char] !== undefined &&
           this._tightHeight[char] !== undefined;
  }

  /**
   * Check if atlas position (xInAtlas) exists for a character
   * @param {string} char - Character (code point) to check
   * @returns {boolean} True if atlas position exists
   */
  hasAtlasPosition(char) {
    return this._xInAtlas[char] !== undefined;
  }

  /**
   * Get all available characters in this atlas positioning
   * @returns {string[]} Array of available characters
   */
  getAvailableCharacters() {
    return Object.keys(this._xInAtlas);
  }

  /**
   * Get tight width for a character
   * @param {string} char - Character (code point) to get width for
   * @returns {number|undefined} Tight width or undefined if not found
   */
  getTightWidth(char) {
    return this._tightWidth[char];
  }

  /**
   * Get tight height for a character
   * @param {string} char - Character (code point) to get height for
   * @returns {number|undefined} Tight height or undefined if not found
   */
  getTightHeight(char) {
    return this._tightHeight[char];
  }

  /**
   * Get X position in atlas for a character
   * @param {string} char - Character (code point) to get X position for
   * @returns {number|undefined} X position in atlas or undefined if not found
   */
  getXInAtlas(char) {
    return this._xInAtlas[char];
  }

  /**
   * Get dx offset for a character
   * @param {string} char - Character (code point) to get dx for
   * @returns {number|undefined} dx offset or undefined if not found
   */
  getDx(char) {
    return this._dx[char];
  }

  /**
   * Get dy offset for a character
   * @param {string} char - Character (code point) to get dy for
   * @returns {number|undefined} dy offset or undefined if not found
   */
  getDy(char) {
    return this._dy[char];
  }

  /**
   * Generate a deterministic hash of the positioning data
   * Uses a simple but stable algorithm that works cross-browser/cross-platform
   * @returns {string} 6-character hex hash
   */
  getHash() {
    // Get sorted characters for deterministic ordering
    const chars = this.getAvailableCharacters().sort();

    // Build deterministic string representation
    const parts = [];
    for (const char of chars) {
      const pos = this.getPositioning(char);
      // Use fixed-precision to avoid floating point variations
      parts.push(
        `${char}:` +
        `w${pos.tightWidth}` +
        `h${pos.tightHeight}` +
        `x${pos.dx}` +
        `y${pos.dy}` +
        `a${pos.xInAtlas}`
      );
    }

    // Simple hash function (FNV-1a variant)
    const str = parts.join('|');
    let hash = 2166136261; // FNV offset basis
    for (let i = 0; i < str.length; i++) {
      hash ^= str.charCodeAt(i);
      hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    }

    // Return as 6-character hex (24 bits)
    return (hash >>> 0).toString(16).substring(0, 6).padStart(6, '0');
  }

}
// ============================================================================
// ATLAS IMAGE CLASS
// ============================================================================
// AtlasImage - Core Runtime Class
//
// This is a CORE RUNTIME class designed for minimal bundle size (~1-2KB).
// It encapsulates atlas image data as an immutable domain object.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Extended by AtlasImageFAB for font assets building capabilities
// - Contains only essential image data and accessor methods
// - No image generation, validation, or serialization code
//
// ARCHITECTURE:
// - Immutable object representing atlas image for ONE font configuration
// - Provides clean API for accessing image properties and validation
// - Follows same immutable pattern as FontProperties, TextProperties, FontMetrics, and AtlasPositioning
// - Establishes architectural symmetry: AtlasImage + AtlasPositioning = AtlasData
//
// SEPARATION RATIONALE:
// - Encapsulates image-related functionality in dedicated domain object
// - Eliminates raw Canvas/Image element handling throughout the codebase
// - Provides consistent interface for image validation and access
// - Enables cleaner, more object-oriented API design
//
// For font assets building capabilities, use AtlasImageFAB which extends this class.
class AtlasImage {
  constructor(image, options = {}) {
    // Validate input image
    if (!image) {
      throw new Error('AtlasImage constructor requires image (Canvas or Image element)');
    }

    if (typeof image !== 'object' || (image.width === undefined && image.naturalWidth === undefined)) {
      throw new Error('AtlasImage constructor requires Canvas or Image element with width property');
    }

    // Store image (Canvas or Image element) - public field (object is frozen)
    this.image = image;

    // Freeze for immutability (safe to use as value object)
    // Skip freezing if this is for font assets building (FAB)
    if (!options.mutable) {
      Object.freeze(this);
    }
  }

  /**
   * Get the width of the atlas image
   * @returns {number} Width in pixels
   */
  get width() {
    // Handle both Canvas (width) and Image (naturalWidth/width) elements
    return this.image.naturalWidth || this.image.width || 0;
  }

  /**
   * Get the height of the atlas image
   * @returns {number} Height in pixels
   */
  get height() {
    // Handle both Canvas (height) and Image (naturalHeight/height) elements
    return this.image.naturalHeight || this.image.height || 0;
  }

  /**
   * Check if this atlas image is valid for rendering
   * @returns {boolean} True if image has valid dimensions
   */
  isValid() {
    return this.image &&
           typeof this.image === 'object' &&
           this.width > 0 &&
           this.height > 0;
  }

  /**
   * Check if the image is ready for rendering operations
   * @returns {boolean} True if image can be used for drawing operations
   */
  canRender() {
    if (!this.isValid()) return false;

    // For Image elements, check if they're loaded
    if (this.image instanceof Image) {
      return this.image.complete && this.image.naturalWidth > 0;
    }

    // Canvas elements are always ready if they have valid dimensions
    return true;
  }

  /**
   * Get the type of the underlying image element
   * @returns {string} 'canvas' or 'image'
   */
  getImageType() {
    if (this.image instanceof HTMLCanvasElement ||
        (typeof OffscreenCanvas !== 'undefined' && this.image instanceof OffscreenCanvas)) {
      return 'canvas';
    }
    if (this.image instanceof Image || this.image instanceof HTMLImageElement) {
      return 'image';
    }
    return 'unknown';
  }

  /**
   * Get a canvas context for drawing operations (if image is a canvas)
   * @param {string} contextType - Context type (default: '2d')
   * @returns {CanvasRenderingContext2D|null} Canvas context or null if not a canvas
   */
  getContext(contextType = '2d') {
    if (this.getImageType() === 'canvas') {
      return this.image.getContext(contextType);
    }
    return null;
  }

  /**
   * Check if this atlas image equals another atlas image
   * @param {AtlasImage} other - Another AtlasImage instance
   * @returns {boolean} True if they reference the same image
   */
  equals(other) {
    if (!(other instanceof AtlasImage)) return false;
    return this.image === other.image;
  }

  /**
   * Get debug information about this atlas image
   * @returns {Object} Debug information
   */
  getDebugInfo() {
    return {
      type: this.getImageType(),
      width: this.width,
      height: this.height,
      isValid: this.isValid(),
      canRender: this.canRender()
    };
  }
}
// ============================================================================
// ATLAS DATA CLASS
// ============================================================================
// AtlasData - Core Runtime Class
//
// This is a CORE RUNTIME class designed for minimal bundle size (~2-3KB).
// It encapsulates both atlas image and positioning data for a font configuration.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Combines AtlasImage with AtlasPositioning data
// - Provides unified interface for atlas image and positioning access
// - Establishes architectural symmetry: AtlasImage + AtlasPositioning = AtlasData
//
// ARCHITECTURE:
// - Immutable object representing atlas image + positioning for ONE font configuration
// - Stores AtlasImage instance with AtlasPositioning instance
// - Provides clean API for accessing both image and positioning data
// - Validates atlas integrity for rendering safety
//
// SEPARATION RATIONALE:
// - Atlas positioning data moved from FontMetrics to be co-located with atlas images
// - Reduces metrics file sizes (positioning only loaded when atlas is loaded)
// - Better separation: metrics for measurement, atlas for rendering
// - Perfect symmetry: both image and positioning are encapsulated in domain objects
//
class AtlasData {
  constructor(atlasImage, atlasPositioning) {
    // Validate AtlasImage instance
    if (!(atlasImage instanceof AtlasImage)) {
      throw new Error('AtlasData constructor requires AtlasImage instance (not raw Canvas/Image)');
    }

    // Validate AtlasPositioning instance (optional but recommended)
    if (atlasPositioning && !(atlasPositioning instanceof AtlasPositioning)) {
      throw new Error('AtlasData constructor requires AtlasPositioning instance (not raw positioning object)');
    }

    // Store AtlasImage instance (public field - object is frozen)
    this.atlasImage = atlasImage;

    // Store AtlasPositioning instance (public field - object is frozen)
    this.atlasPositioning = atlasPositioning;

    // Freeze for immutability (safe to use as value object)
    Object.freeze(this);
  }

  /**
   * Check if positioning data exists for a character
   * Null-safe convenience method that delegates to the AtlasPositioning instance.
   * This demonstrates the delegation pattern: AtlasData wraps AtlasPositioning
   * and provides a simplified interface for checking character availability.
   * @param {string} char - Character (code point) to check
   * @returns {boolean} True if positioning data exists
   */
  hasPositioning(char) {
    if (!this.atlasPositioning) return false;

    // Delegate to AtlasPositioning instance
    return this.atlasPositioning.hasPositioning(char);
  }

  /**
   * Check if this atlas data is valid for rendering
   * @returns {boolean} True if atlas has valid image and dimensions
   */
  isValid() {
    return this.atlasImage?.isValid();
  }

  /**
   * Get all available characters in this atlas
   * @returns {string[]} Array of available characters
   */
  getAvailableCharacters() {
    if (!this.atlasPositioning) return [];

    // Delegate to AtlasPositioning instance
    return this.atlasPositioning.getAvailableCharacters();
  }

  /**
   * Get the width of the atlas image
   * @returns {number} Width in pixels
   */
  get width() {
    return this.atlasImage.width;
  }

  /**
   * Get the height of the atlas image
   * @returns {number} Height in pixels
   */
  get height() {
    return this.atlasImage.height;
  }

  /**
   * Check if the atlas can be rendered
   * @returns {boolean} True if atlas is ready for rendering operations
   */
  canRender() {
    return this.atlasImage?.canRender();
  }

  /**
   * Check if this atlas data equals another atlas data
   * @param {AtlasData} other - Another AtlasData instance
   * @returns {boolean} True if they reference the same image and positioning
   */
  equals(other) {
    if (!(other instanceof AtlasData)) return false;
    return this.atlasImage.equals(other.atlasImage) &&
           this.atlasPositioning === other.atlasPositioning;
  }

  /**
   * Get debug information about this atlas data
   * @returns {Object} Debug information
   */
  getDebugInfo() {
    return {
      atlasImage: this.atlasImage ? this.atlasImage.getDebugInfo() : null,
      atlasPositioning: this.atlasPositioning ? {
        availableCharacters: this.atlasPositioning.getAvailableCharacters().length,
        characters: this.atlasPositioning.getAvailableCharacters().slice(0, 10) // First 10 for brevity
      } : null,
      isValid: this.isValid(),
      canRender: this.canRender()
    };
  }
}
// ============================================================================
// ATLAS RECONSTRUCTION UTILITIES
// ============================================================================
// AtlasReconstructionUtils - Shared utility for image data extraction
// Used by TightAtlasReconstructor for atlas image processing
//
// ARCHITECTURAL DESIGN RATIONALE:
// This utility class provides cross-platform image data extraction that works
// in both browser and Node.js environments. It handles different image sources
// (HTMLImageElement, Canvas, AtlasImage wrapper) and creates temporary canvases
// as needed for pixel data access.
//
// By centralizing this logic here, we ensure:
// - Zero code duplication across different reconstruction contexts
// - Single source of truth for image data extraction
// - Consistent cross-platform behavior (browser vs Node.js)
// - Easy to unit test independently

class AtlasReconstructionUtils {
  // Private constructor - prevent instantiation following Effective Java patterns
  constructor() {
    throw new Error('AtlasReconstructionUtils cannot be instantiated - use static methods');
  }

  /**
   * Gets ImageData from various image sources
   * Handles: HTMLImageElement (PNG), Canvas (QOI), AtlasImage wrapper
   * @param {Image|Canvas|AtlasImage} image - Image source
   * @returns {ImageData} ImageData object with pixel data
   * @throws {Error} If image is not a valid source
   */
  static getImageData(image) {
    // Unwrap AtlasImage if needed
    const actualImage = image?.image ? image.image : image;

    if (!actualImage) {
      throw new Error('getImageData: Invalid image source (null or undefined)');
    }

    // If Canvas, directly get image data
    if (actualImage.getContext) {
      const ctx = actualImage.getContext('2d');
      return ctx.getImageData(0, 0, actualImage.width, actualImage.height);
    }

    // If Image element, draw to temporary canvas first
    if (actualImage.naturalWidth !== undefined || actualImage.width !== undefined) {
      // Create canvas using explicit double invocation
      const canvas = BitmapText.getCanvasFactory()();
      canvas.width = actualImage.naturalWidth || actualImage.width;
      canvas.height = actualImage.naturalHeight || actualImage.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(actualImage, 0, 0);
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    throw new Error('getImageData: Image source is not a Canvas or Image element');
  }
}

// ============================================================================
// ATLAS CELL DIMENSIONS
// ============================================================================
// AtlasCellDimensions - Utility for calculating atlas cell dimensions
//
// Provides centralized formulas for calculating cell dimensions from character metrics.
// These formulas MUST be consistent across AtlasBuilder and TightAtlasReconstructor.
//
// Cell dimensions follow the Atlas format (variable-width cells):
// - Cell width: actualBoundingBoxLeft + actualBoundingBoxRight (varies per character)
// - Cell height: fontBoundingBoxAscent + fontBoundingBoxDescent (constant per font)

class AtlasCellDimensions {
  // Private constructor - prevent instantiation
  constructor() {
    throw new Error('AtlasCellDimensions cannot be instantiated - use static methods');
  }

  /**
   * Calculate cell width for a character
   * CRITICAL: Must match GlyphFAB.js:155-160 which uses Math.round()
   * @param {Object} charMetrics - Character metrics from FontMetrics
   * @returns {number} Cell width in pixels (rounded, matching GlyphFAB canvas creation)
   */
  static getWidth(charMetrics) {
    return Math.round(
      charMetrics.actualBoundingBoxLeft +
      charMetrics.actualBoundingBoxRight
    );
  }

  /**
   * Calculate cell height for a font
   * CRITICAL: Must match GlyphFAB.js:170-175 which uses Math.round()
   * @param {Object} charMetrics - Character metrics (any character from the font)
   * @returns {number} Cell height in pixels (rounded, constant for entire font)
   */
  static getHeight(charMetrics) {
    return Math.round(
      charMetrics.fontBoundingBoxAscent +
      charMetrics.fontBoundingBoxDescent
    );
  }

  /**
   * Calculate both dimensions
   * @param {Object} charMetrics - Character metrics
   * @returns {{width: number, height: number}}
   */
  static getDimensions(charMetrics) {
    return {
      width: this.getWidth(charMetrics),
      height: this.getHeight(charMetrics)
    };
  }
}

// ============================================================================
// TIGHT ATLAS RECONSTRUCTOR
// ============================================================================
// TightAtlasReconstructor - Core Runtime Class
//
// This is a CORE RUNTIME class designed for reconstructing tight atlases from
// standard atlases via pixel scanning.
//
// DISTRIBUTION ROLE:
// - Used by font-assets-builder.html and also by the runtime to reconstruct tight
//   atlases for display and storage
// - Reconstructs tight atlas + positioning data from atlas image
//
// ARCHITECTURE:
// - Takes atlas image (variable-width cells) and FontMetrics
// - Scans each character cell to find tight bounding box
// - Repacks into tight atlas
// - Calculates positioning data (dx, dy) using EXACT formulas from AtlasPositioningFAB
//
// CRITICAL REQUIREMENTS:
// - MUST use sorted character order (same as AtlasBuilder)
// - dx/dy formulas MUST match AtlasPositioningFAB.js:87-88 exactly
// - MUST handle multi-part glyphs (i, j with dots) correctly
// - MUST use 4-step optimized tight bounds detection algorithm
//
class TightAtlasReconstructor {
  // Private constructor - prevent instantiation following Effective Java patterns
  constructor() {
    throw new Error('TightAtlasReconstructor cannot be instantiated - use static methods');
  }

  /**
   * Main entry point - reconstructs tight atlas from standard atlas
   *
   * PARAMETER ORDER: Standardized to (fontMetrics, data) for API consistency
   *
   * @param {FontMetrics} fontMetrics - Font metrics for cell dimensions (CSS pixels) and positioning
   * @param {Image|Canvas|AtlasImage} atlasImage - Atlas image (variable-width cells, already at physical pixels)
   * @returns {{atlasImage: AtlasImage, atlasPositioning: AtlasPositioning}}
   */
  static reconstructFromAtlas(fontMetrics, atlasImage) {
    // 1. Get ImageData from atlas for pixel scanning
    const imageData = AtlasReconstructionUtils.getImageData(atlasImage);

    // 2. Get SORTED character list (CRITICAL for determinism)
    // Must match the order used in AtlasBuilder
    const characters = fontMetrics.getAvailableCharacters().sort();

    if (characters.length === 0) {
      throw new Error('TightAtlasReconstructor: No characters found in FontMetrics');
    }

    console.debug(`TightAtlasReconstructor: Processing ${characters.length} characters`);

    // 3. Calculate cell dimensions from font metrics
    // Cell height is constant across all characters in this font
    // Character metrics contain CSS pixel values, but we need to infer physical pixel dimensions
    // from the actual atlas image by detecting pixelDensity from the ratio
    const firstChar = characters[0];
    const firstMetrics = fontMetrics.getCharacterMetrics(firstChar);

    // Infer pixelDensity from first character's metrics vs atlas dimensions
    // This works because: physical_pixels = CSS_pixels * pixelDensity
    const height_CssPx = AtlasCellDimensions.getHeight(firstMetrics);
    const pixelDensity = firstMetrics.pixelDensity || 1; // Use pixelDensity from metrics if available
    const cellHeight_PhysPx = Math.round(height_CssPx * pixelDensity);

    console.debug(`🔍 TightAtlasReconstructor: pixelDensity=${pixelDensity}, height_CssPx=${height_CssPx}, cellHeight_PhysPx=${cellHeight_PhysPx}`);

    // 4. Scan each cell to find tight bounds within the atlas cell
    let cellX_PhysPx = 0;
    const tightBounds = {};
    const cellDebugInfo = []; // Track first 5 chars for debugging

    for (const char of characters) {
      const charMetrics = fontMetrics.getCharacterMetrics(char);

      // Cell width is variable per character (scale CSS pixels to physical pixels)
      const width_CssPx = AtlasCellDimensions.getWidth(charMetrics);
      const cellWidth_PhysPx = Math.round(width_CssPx * pixelDensity);

      // Debug first few characters
      if (cellDebugInfo.length < 5) {
        cellDebugInfo.push(`${char}:css=${width_CssPx},phys=${cellWidth_PhysPx},x=${cellX_PhysPx}`);
      }

      // Find tight bounds within this cell using 4-step optimized algorithm
      const bounds = this.findTightBounds(
        imageData,
        cellX_PhysPx,
        0,
        cellWidth_PhysPx,
        cellHeight_PhysPx
      );

      if (bounds) {
        tightBounds[char] = bounds;
      }

      cellX_PhysPx += cellWidth_PhysPx;
    }

    console.debug(`🔍 Cell dimensions (first 5): ${cellDebugInfo.join(', ')}`);

    // 5. Repack into tight atlas with positioning data
    return this.packTightAtlas(
      fontMetrics,
      tightBounds,
      characters,
      atlasImage,
      pixelDensity,
      cellHeight_PhysPx
    );
  }

  /**
   * Find tight bounds within a cell using 4-step optimized algorithm
   * This scans for the minimal bounding box of non-transparent pixels
   *
   * @param {ImageData} imageData - Image data from original atlas
   * @param {number} cellX_PhysPx - X position of cell in atlas (physical pixels)
   * @param {number} cellY_PhysPx - Y position of cell in atlas (physical pixels, always 0)
   * @param {number} cellWidth_PhysPx - Width of this character's cell (physical pixels)
   * @param {number} cellHeight_PhysPx - Height of cell (physical pixels, constant for font)
   * @returns {{left, top, width, height} | null} - Tight bounds relative to cell origin, or null if empty
   */
  static findTightBounds(imageData, cellX_PhysPx, cellY_PhysPx, cellWidth_PhysPx, cellHeight_PhysPx) {
    const pixels = imageData.data;
    const atlasWidth_PhysPx = imageData.width;

    // Helper to get alpha value at position
    // Optimized: pre-calculate stride and use bit shift for x*4
    const stride = atlasWidth_PhysPx * 4;
    const getAlpha = (x, y) => pixels[y * stride + (x << 2) + 3];

    // STEP 1: Find bottom edge (scan UP from bottom) - early exit
    // This finds the bottommost row with any non-transparent pixel
    let bottom_PhysPx = -1;
    for (let y = cellY_PhysPx + cellHeight_PhysPx - 1; y >= cellY_PhysPx && bottom_PhysPx === -1; y--) {
      for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx && bottom_PhysPx === -1; x++) {
        if (getAlpha(x, y) > 0) {
          bottom_PhysPx = y;
        }
      }
    }

    // Empty cell (no visible pixels)
    if (bottom_PhysPx === -1) return null;

    // STEP 2: Find top edge (scan DOWN, only to bottom) - early exit
    // This finds the topmost row with any non-transparent pixel
    let top_PhysPx = cellY_PhysPx;
    for (let y = cellY_PhysPx; y <= bottom_PhysPx; y++) {
      let found = false;
      for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx; x++) {
        if (getAlpha(x, y) > 0) {
          top_PhysPx = y;
          found = true;
          break;
        }
      }
      if (found) break;
    }

    // STEP 3: Find left edge (scan columns, only vertical range found above) - early exit
    // This finds the leftmost column with any non-transparent pixel
    let left_PhysPx = cellX_PhysPx;
    for (let x = cellX_PhysPx; x < cellX_PhysPx + cellWidth_PhysPx; x++) {
      let found = false;
      for (let y = top_PhysPx; y <= bottom_PhysPx; y++) {
        if (getAlpha(x, y) > 0) {
          left_PhysPx = x;
          found = true;
          break;
        }
      }
      if (found) break;
    }

    // STEP 4: Find right edge (scan right→left, only vertical range) - early exit
    // This finds the rightmost column with any non-transparent pixel
    let right_PhysPx = cellX_PhysPx + cellWidth_PhysPx - 1;
    for (let x = cellX_PhysPx + cellWidth_PhysPx - 1; x >= cellX_PhysPx; x--) {
      let found = false;
      for (let y = top_PhysPx; y <= bottom_PhysPx; y++) {
        if (getAlpha(x, y) > 0) {
          right_PhysPx = x;
          found = true;
          break;
        }
      }
      if (found) break;
    }

    // Return bounds relative to cell origin (not absolute atlas coordinates)
    return {
      left: left_PhysPx - cellX_PhysPx,        // Relative to cell left edge (physical pixels)
      top: top_PhysPx - cellY_PhysPx,          // Relative to cell top edge (physical pixels)
      width: right_PhysPx - left_PhysPx + 1,   // Inclusive width (physical pixels)
      height: bottom_PhysPx - top_PhysPx + 1   // Inclusive height (physical pixels)
    };
  }

  /**
   * Pack tight glyphs and calculate positioning data
   *
   * PARAMETER ORDER: Standardized to (fontMetrics, data, options) for API consistency
   *
   * @param {FontMetrics} fontMetrics - Font metrics for positioning calculations
   * @param {Object} tightBounds - Map of char → {left, top, width, height} within cells
   * @param {Array<string>} characters - Sorted array of characters
   * @param {Image|Canvas} sourceAtlasImage - Source Atlas image for extraction
   * @param {number} pixelDensity - Pixel density multiplier for positioning calculations
   * @param {number} cellHeight_PhysPx - Cell height in physical pixels (for distanceBetweenBottomAndBottomOfCanvas calculation)
   * @returns {{atlasImage: AtlasImage, atlasPositioning: AtlasPositioning}}
   */
  static packTightAtlas(fontMetrics, tightBounds, characters, sourceAtlasImage, pixelDensity, cellHeight_PhysPx) {
    // Calculate tight atlas dimensions (all in physical pixels)
    let totalWidth_PhysPx = 0;
    let maxHeight_PhysPx = 0;

    for (const char of characters) {
      if (tightBounds[char]) {
        totalWidth_PhysPx += tightBounds[char].width;
        maxHeight_PhysPx = Math.max(maxHeight_PhysPx, tightBounds[char].height);
      }
    }

    // Create tight atlas canvas (explicit double invocation: get factory, call factory)
    const tightCanvas = BitmapText.getCanvasFactory()();
    tightCanvas.width = totalWidth_PhysPx;
    tightCanvas.height = maxHeight_PhysPx;
    const ctx = tightCanvas.getContext('2d');

    // Initialize positioning data structure
    let xInTightAtlas_PhysPx = 0;
    const positioning = {
      tightWidth: {},
      tightHeight: {},
      dx: {},
      dy: {},
      xInAtlas: {}
    };

    // Extract and pack each tight glyph
    let cellX_PhysPx = 0;

    for (const char of characters) {
      const charMetrics = fontMetrics.getCharacterMetrics(char);

      // Calculate cell width in physical pixels (CSS pixels * pixelDensity)
      // MUST be calculated for ALL characters to track cellX_PhysPx correctly
      const width_CssPx = AtlasCellDimensions.getWidth(charMetrics);
      const cellWidth_PhysPx = Math.round(width_CssPx * pixelDensity);
      // cellHeight_PhysPx is passed as parameter (already in physical pixels)

      const bounds = tightBounds[char];
      if (!bounds) {
        // No visible pixels, but still need to advance cellX_PhysPx for next character
        cellX_PhysPx += cellWidth_PhysPx;
        continue;
      }

      // Extract tight glyph from original atlas
      const tempCanvas = BitmapText.getCanvasFactory()();
      tempCanvas.width = bounds.width;
      tempCanvas.height = bounds.height;
      const tempCtx = tempCanvas.getContext('2d');

      // Copy tight region from atlas to temp canvas
      const srcX_PhysPx = Math.floor(cellX_PhysPx + bounds.left);
      const srcY_PhysPx = Math.floor(bounds.top);
      const srcWidth_PhysPx = Math.floor(bounds.width);
      const srcHeight_PhysPx = Math.floor(bounds.height);

      tempCtx.drawImage(
        sourceAtlasImage,
        srcX_PhysPx, srcY_PhysPx,      // Source position in atlas (physical pixels)
        srcWidth_PhysPx, srcHeight_PhysPx,  // Source dimensions (physical pixels)
        0, 0,                           // Dest position in temp canvas
        srcWidth_PhysPx, srcHeight_PhysPx   // Dest dimensions (physical pixels)
      );

      // Draw to tight atlas at sequential position
      ctx.drawImage(tempCanvas, xInTightAtlas_PhysPx, 0);

      // ═══════════════════════════════════════════════════════════════════════
      // POSITIONING CALCULATION
      // ═══════════════════════════════════════════════════════════════════════
      //
      // We need to calculate dx/dy offsets for rendering the tight glyph.
      // These formulas MUST match AtlasPositioningFAB.js:91-92 exactly.
      //
      // Coordinate System Overview:
      //
      //   Atlas Cell (variable-width):        Tight Bounds:
      //   ┌──────────────────────────┐
      //   │ actualBoundingBox        │        ┌──────────┐
      //   │ ┌──────────────────┐     │        │  ████    │  ← Minimal box
      //   │ │                  │     │   →    │  ████    │     around pixels
      //   │ │    ████          │     │        └──────────┘
      //   │ │    ████          │     │
      //   │ └──────────────────┘     │        dx = horizontal offset to align
      //   │ fontBoundingBox          │        dy = vertical offset from baseline
      //   └──────────────────────────┘
      //     ↑                          ↑
      //     cellX_PhysPx             cellX_PhysPx + cellWidth_PhysPx
      //
      // dx: Horizontal offset from rendering position to tight glyph position
      //     Components:
      //     - actualBoundingBoxLeft: Distance from text baseline to left edge of actual glyph
      //     - bounds.left: Left edge of tight bounds within cell
      //     Formula: -actualBoundingBoxLeft * pixelDensity + bounds.left
      //
      // dy: Vertical offset from baseline to top of tight glyph
      //     Components:
      //     - bounds.height: Height of tight glyph
      //     - distanceBetweenBottomAndBottomOfCanvas: Gap below glyph (accounts for descenders)
      //     - pixelDensity: Scale factor for high-DPI displays
      //     Formula: -bounds.height - distanceBetweenBottomAndBottomOfCanvas + pixelDensity
      //
      //     The distanceBetweenBottomAndBottomOfCanvas accounts for descenders (like 'g', 'y')
      //     and ensures proper vertical alignment relative to the text baseline.
      //
      // Note: pixelDensity is passed as a parameter (charMetrics only contains CSS pixel measurements)

      // Calculate distance from bottom of tight bounds to bottom of character canvas
      // This is used in the dy calculation
      // Note: bounds.top + bounds.height - 1 gives the Y coordinate of the bottom pixel (like bottomRightCorner.y)
      const distanceBetweenBottomAndBottomOfCanvas_PhysPx =
        cellHeight_PhysPx - (bounds.top + bounds.height - 1) - 1;

      // Store positioning data (all in physical pixels)
      positioning.tightWidth[char] = bounds.width;    // Physical pixels
      positioning.tightHeight[char] = bounds.height;  // Physical pixels
      positioning.xInAtlas[char] = xInTightAtlas_PhysPx;  // Physical pixels

      // EXACT dx formula from AtlasPositioningFAB.js:91 (physical pixels)
      positioning.dx[char] =
        - Math.round(charMetrics.actualBoundingBoxLeft) * pixelDensity
        + bounds.left;

      // EXACT dy formula from AtlasPositioningFAB.js:92 (physical pixels)
      positioning.dy[char] =
        - bounds.height
        - distanceBetweenBottomAndBottomOfCanvas_PhysPx
        + 1 * pixelDensity;

      xInTightAtlas_PhysPx += bounds.width;
      cellX_PhysPx += cellWidth_PhysPx;
    }

    // Create domain objects
    const tightAtlasImage = new AtlasImage(tightCanvas);
    const atlasPositioning = new AtlasPositioning(positioning);

    console.debug(`TightAtlasReconstructor: Packed ${Object.keys(positioning.xInAtlas).length} glyphs into ${totalWidth_PhysPx}×${maxHeight_PhysPx} atlas`);

    return { atlasImage: tightAtlasImage, atlasPositioning };
  }
}

// ============================================================================
// QOI DECODER
// ============================================================================
/**
 * Decode a QOI file given as an ArrayBuffer.
 *
 * @param {ArrayBuffer} arrayBuffer ArrayBuffer containing the QOI file.
 * @param {int|null} [byteOffset] Offset to the start of the QOI file in arrayBuffer
 * @param {int|null} [byteLength] Length of the QOI file in bytes
 * @param {int|null} [outputChannels] Number of channels to include in the decoded array
 *
 * @returns {{channels: number, data: Uint8Array, colorspace: number, width: number, error: boolean, height: number}}
 */
function QOIDecode (arrayBuffer, byteOffset, byteLength, outputChannels) {
    if (typeof byteOffset === 'undefined' || byteOffset === null) {
        byteOffset = 0;
    }

    if (typeof byteLength === 'undefined' || byteLength === null) {
        byteLength = arrayBuffer.byteLength - byteOffset;
    }

    const uint8 = new Uint8Array(arrayBuffer, byteOffset, byteLength);

    const magic1 = uint8[0];
    const magic2 = uint8[1];
    const magic3 = uint8[2];
    const magic4 = uint8[3];

    const width = ((uint8[4] << 24) | (uint8[5] << 16) | (uint8[6] << 8) | uint8[7]) >>> 0;
    const height = ((uint8[8] << 24) | (uint8[9] << 16) | (uint8[10] << 8) | uint8[11]) >>> 0;

    const channels = uint8[12];
    const colorspace = uint8[13];

    if (typeof outputChannels === 'undefined' || outputChannels === null) {
        outputChannels = channels;
    }

    if (magic1 !== 0x71 || magic2 !== 0x6F || magic3 !== 0x69 || magic4 !== 0x66) {
        throw new Error('QOI.decode: The signature of the QOI file is invalid');
    }

    if (channels < 3 || channels > 4) {
        throw new Error('QOI.decode: The number of channels declared in the file is invalid');
    }

    if (colorspace > 1) {
        throw new Error('QOI.decode: The colorspace declared in the file is invalid');
    }

    if (outputChannels < 3 || outputChannels > 4) {
        throw new Error('QOI.decode: The number of channels for the output is invalid');
    }

    const pixelLength = width * height * outputChannels;
    const result = new Uint8Array(pixelLength);

    let arrayPosition = 14;

    const index = new Uint8Array(64 * 4);
    let indexPosition = 0;

    let red = 0;
    let green = 0;
    let blue = 0;
    let alpha = 255;

    const chunksLength = byteLength - 8;

    let run = 0;
    let pixelPosition = 0;

    for (; pixelPosition < pixelLength && arrayPosition < byteLength - 4; pixelPosition += outputChannels) {
        if (run > 0) {
            run--;
        } else if (arrayPosition < chunksLength) {
            const byte1 = uint8[arrayPosition++];

            if (byte1 === 0b11111110) { // QOI_OP_RGB
                red = uint8[arrayPosition++];
                green = uint8[arrayPosition++];
                blue = uint8[arrayPosition++];
            } else if (byte1 === 0b11111111) { // QOI_OP_RGBA
                red = uint8[arrayPosition++];
                green = uint8[arrayPosition++];
                blue = uint8[arrayPosition++];
                alpha = uint8[arrayPosition++];
            } else if ((byte1 & 0b11000000) === 0b00000000) { // QOI_OP_INDEX
                red = index[byte1 * 4];
                green = index[byte1 * 4 + 1];
                blue = index[byte1 * 4 + 2];
                alpha = index[byte1 * 4 + 3];
            } else if ((byte1 & 0b11000000) === 0b01000000) { // QOI_OP_DIFF
                red += ((byte1 >> 4) & 0b00000011) - 2;
                green += ((byte1 >> 2) & 0b00000011) - 2;
                blue += (byte1 & 0b00000011) - 2;

                // handle wraparound
                red = (red + 256) % 256;
                green = (green + 256) % 256;
                blue = (blue + 256) % 256;
            } else if ((byte1 & 0b11000000) === 0b10000000) { // QOI_OP_LUMA
                const byte2 = uint8[arrayPosition++];
                const greenDiff = (byte1 & 0b00111111) - 32;
                const redDiff = greenDiff + ((byte2 >> 4) & 0b00001111) - 8;
                const blueDiff = greenDiff + (byte2 & 0b00001111) - 8;

                // handle wraparound
                red = (red + redDiff + 256) % 256;
                green = (green + greenDiff + 256) % 256;
                blue = (blue + blueDiff + 256) % 256;
            } else if ((byte1 & 0b11000000) === 0b11000000) { // QOI_OP_RUN
                run = byte1 & 0b00111111;
            }

            indexPosition = ((red * 3 + green * 5 + blue * 7 + alpha * 11) % 64) * 4;
            index[indexPosition] = red;
            index[indexPosition + 1] = green;
            index[indexPosition + 2] = blue;
            index[indexPosition + 3] = alpha;
        }

        if (outputChannels === 4) { // RGBA
            result[pixelPosition] = red;
            result[pixelPosition + 1] = green;
            result[pixelPosition + 2] = blue;
            result[pixelPosition + 3] = alpha;
        } else { // RGB
            result[pixelPosition] = red;
            result[pixelPosition + 1] = green;
            result[pixelPosition + 2] = blue;
        }
    }

    if (pixelPosition < pixelLength) {
        throw new Error('QOI.decode: Incomplete image');
    }

    // checking the 00000001 padding is not required, as per specs

    return {
        width: width,
        height: height,
        colorspace: colorspace,
        channels: outputChannels,
        data: result
    };
}
// ============================================================================
// ATLAS DATA STORE
// ============================================================================
// AtlasDataStore - Core Runtime Static Class
//
// This is a CORE RUNTIME static class designed for minimal bundle size (~2-3KB).
// It provides essential atlas data storage and retrieval for text rendering.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Extended by AtlasDataStoreFAB for font assets building and generation
// - Contains only atlas data structures and accessors needed at runtime
// - No font generation, validation, or optimization code
//
// ARCHITECTURE:
// - Static class with private storage for AtlasData objects
// - Uses Map-based storage for O(1) atlas lookups by font properties
// - Provides the minimal atlas interface needed by BitmapText for glyph rendering
// - Optimized for fast atlas access during text drawing
// - Separate from FontMetricsStore to enable independent loading strategies
//
// SEPARATION RATIONALE:
// - Atlas data contains both large binary images and positioning data loaded from atlas-*.js files
// - Can be lazy-loaded on demand to optimize memory usage
// - Independent of font metrics which are small and loaded upfront
// - Aligns with file structure: atlas-*.js vs metrics-*.js
//
// For font assets building and generation capabilities, use AtlasDataStoreFAB.
class AtlasDataStore {
  // Private static storage
  // Keys are FontProperties.key strings for O(1) lookup
  static #atlases = new Map(); // fontProperties.key → AtlasData

  static getAtlasData(fontProperties) {
    return AtlasDataStore.#atlases.get(fontProperties.key);
  }

  static setAtlasData(fontProperties, atlasData) {
    // Only accept AtlasData instances
    if (!(atlasData instanceof AtlasData)) {
      throw new Error('AtlasDataStore.setAtlasData requires AtlasData instance (not raw images)');
    }
    AtlasDataStore.#atlases.set(fontProperties.key, atlasData);
  }

  // Helper method to check if an atlas is valid for rendering
  static isValidAtlas(atlas) {
    // Only work with AtlasData instances
    if (!(atlas instanceof AtlasData)) {
      return false;
    }
    return atlas.isValid();
  }

  // Get all available font properties keys
  static getAvailableFonts() {
    return Array.from(AtlasDataStore.#atlases.keys());
  }

  // Check if atlas exists for font properties
  static hasAtlas(fontProperties) {
    return AtlasDataStore.#atlases.has(fontProperties.key);
  }

  // Remove atlas for font properties
  static deleteAtlas(fontProperties) {
    return AtlasDataStore.#atlases.delete(fontProperties.key);
  }

  // Clear all atlases
  static clear() {
    AtlasDataStore.#atlases.clear();
  }

  // Get count of stored atlases
  static size() {
    return AtlasDataStore.#atlases.size;
  }
}

// ============================================================================
// FONT METRICS STORE
// ============================================================================
// FontMetricsStore - Core Runtime Static Class
//
// This is a CORE RUNTIME static class designed for minimal bundle size (~2-3KB).
// It provides essential font metrics storage and retrieval as a repository of FontMetrics instances.
//
// DISTRIBUTION ROLE:
// - Part of "runtime-only" distribution for production applications
// - Extended by FontMetricsStoreFAB for font assets building and generation
// - Contains only FontMetrics instance storage and retrieval
// - No font generation, validation, or optimization code
//
// ARCHITECTURE:
// - Static class with private storage for FontMetrics instances
// - Stores FontMetrics instances for fast O(1) lookup by font properties
// - Simple repository pattern with get/set/has operations
// - FontMetrics instances encapsulate all metrics data and behavior
// - Separate from AtlasDataStore to enable independent loading strategies
//
// SEPARATION RATIONALE:
// - Font metrics are small data loaded from metrics-*.js files
// - Can be loaded upfront for immediate text measurement capabilities
// - Independent of atlas images which are larger and can be lazy-loaded
// - FontMetrics instances provide clean API without fontProperties parameter passing
//
// For font assets building and generation capabilities, use FontMetricsStoreFAB.
class FontMetricsStore {
  // Private static storage
  // Keys are FontProperties.key strings for O(1) FontMetrics instance lookup
  static #fontMetrics = new Map(); // fontProperties.key → FontMetrics instance

  /**
   * Get FontMetrics instance for a font configuration
   * @param {FontProperties} fontProperties - Font configuration
   * @returns {FontMetrics|undefined} FontMetrics instance or undefined if not found
   */
  static getFontMetrics(fontProperties) {
    return FontMetricsStore.#fontMetrics.get(fontProperties.key);
  }

  /**
   * Set FontMetrics instance for a font configuration
   * @param {FontProperties} fontProperties - Font configuration
   * @param {FontMetrics} fontMetrics - FontMetrics instance to store
   */
  static setFontMetrics(fontProperties, fontMetrics) {
    FontMetricsStore.#fontMetrics.set(fontProperties.key, fontMetrics);
  }

  /**
   * Check if FontMetrics exists for a font configuration
   * @param {FontProperties} fontProperties - Font configuration
   * @returns {boolean} True if FontMetrics instance exists
   */
  static hasFontMetrics(fontProperties) {
    return FontMetricsStore.#fontMetrics.has(fontProperties.key);
  }

  /**
   * Remove FontMetrics for a font configuration
   * @param {FontProperties} fontProperties - Font configuration
   * @returns {boolean} True if FontMetrics was removed
   */
  static deleteFontMetrics(fontProperties) {
    return FontMetricsStore.#fontMetrics.delete(fontProperties.key);
  }

  /**
   * Get all available font configurations
   * @returns {string[]} Array of fontProperties.key strings
   */
  static getAvailableFonts() {
    return Array.from(FontMetricsStore.#fontMetrics.keys());
  }

  /**
   * Clear all stored FontMetrics instances
   */
  static clear() {
    FontMetricsStore.#fontMetrics.clear();
  }

  /**
   * Get count of stored FontMetrics instances
   * @returns {number} Number of stored font configurations
   */
  static size() {
    return FontMetricsStore.#fontMetrics.size;
  }
}

// ============================================================================
// FONT LOADER BASE
// ============================================================================
// FontLoaderBase - Abstract Static Base Class for Font Loading
//
// This abstract static class provides the core font loading infrastructure
// for BitmapText. It defines the public API and shared logic for font loading,
// while platform-specific implementations (browser, Node.js) extend this class.
//
// DISTRIBUTION ROLE:
// - Used by both browser and Node.js distributions
// - Defines abstract methods implemented by platform-specific loaders
// - Contains shared loading orchestration and atlas reconstruction logic
//
// ARCHITECTURE:
// - Abstract static class (not instantiated)
// - Extended by FontLoaderBrowser and FontLoaderNode
// - Owns fontDirectory configuration (#fontDirectory private field)
// - Works with BitmapText's internal stores (#fontMetrics, #atlasData)
// - Uses Template Method Pattern for platform-specific operations
// - BitmapText delegates fontDirectory get/set to FontLoader (this class owns what it uses)
//
// LOADING FLOW:
// 1. loadFonts() orchestrates loading of multiple fonts
// 2. loadMetricsFile() loads metrics (platform-specific)
// 3. loadAtlasFile() loads atlas image (platform-specific)
// 4. loadAtlasFromPackage() reconstructs atlas from image (shared)
// 5. processPendingAtlas() handles async atlas/metrics loading (shared)

class FontLoaderBase {
  // ============================================
  // Shared Static Storage
  // ============================================

  // Temporary storage for atlas packages before reconstruction
  static _tempAtlasPackages = {};

  // Pending atlases waiting for metrics
  static _pendingAtlases = new Map();

  // Loading promises to prevent duplicate loads
  static _loadingPromises = new Map();

  // ============================================
  // Configuration
  // ============================================

  /**
   * Default font directory for all platforms
   * @constant {string}
   */
  static DEFAULT_FONT_DIRECTORY = './font-assets/';

  /**
   * User-configured font directory override (null = use default)
   * @private
   */
  static #fontDirectory = null;

  /**
   * Set font directory (overrides default)
   * @param {string} path - Path to font assets directory
   */
  static setFontDirectory(path) {
    FontLoaderBase.#fontDirectory = path;
  }

  /**
   * Get font directory (returns override or default)
   * @returns {string} Font directory path
   */
  static getFontDirectory() {
    return FontLoaderBase.#fontDirectory ?? FontLoaderBase.DEFAULT_FONT_DIRECTORY;
  }

  /**
   * Get default font directory (shared across all platforms)
   * @deprecated Use getFontDirectory() instead
   * @returns {string} Font directory path
   */
  static getDefaultFontDirectory() {
    return FontLoaderBase.DEFAULT_FONT_DIRECTORY;
  }

  // ============================================
  // Registration API (called by asset files)
  // ============================================

  /**
   * Register font metrics from metrics-*.js file
   * Called by self-registering metrics files
   * @param {string} idString - Font ID string
   * @param {Object} compactedData - Compacted metrics data
   * @param {Object} bitmapTextClass - BitmapText class reference (for backward compatibility)
   */
  static registerMetrics(idString, compactedData, bitmapTextClass) {
    if (typeof idString !== 'string') {
      console.warn('FontLoader.registerMetrics: Invalid idString - must be string');
      return;
    }

    if (typeof MetricsExpander === 'undefined') {
      console.warn('FontLoader.registerMetrics: MetricsExpander not available');
      return;
    }

    if (typeof FontProperties === 'undefined') {
      console.warn('FontLoader.registerMetrics: FontProperties not available');
      return;
    }

    const fontProperties = FontProperties.fromIDString(idString);
    const fontMetrics = MetricsExpander.expand(compactedData);

    // Store metrics directly in FontMetricsStore
    FontMetricsStore.setFontMetrics(fontProperties, fontMetrics);

    // Process any pending atlases that were waiting for these metrics
    FontLoaderBase._processPendingAtlas(idString);
  }

  /**
   * Register atlas from atlas-*.js file (base64 only, positioning reconstructed later)
   * Called by self-registering atlas files
   * @param {string} idString - Font ID string
   * @param {string} base64Data - Base64-encoded atlas data
   */
  static registerAtlas(idString, base64Data) {
    if (typeof idString !== 'string' || typeof base64Data !== 'string') {
      console.warn('FontLoader.registerAtlas: Invalid arguments - idString and base64Data must be strings');
      return;
    }

    FontLoaderBase._tempAtlasPackages[idString] = { base64Data };
  }

  // ============================================
  // Public Loading API
  // ============================================

  /**
   * Load a single font
   * @param {string} idString - Font ID string
   * @param {Object} options - Loading options
   * @param {Function} [options.onProgress] - Progress callback (loaded, total)
   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {Promise} Resolves when font is loaded
   */
  static async loadFont(idString, options, bitmapTextClass) {
    return this.loadFonts([idString], options, bitmapTextClass);
  }

  /**
   * Load multiple fonts
   * @param {Array<string>} idStrings - Array of font ID strings
   * @param {Object} options - Loading options
   * @param {Function} [options.onProgress] - Progress callback (loaded, total)
   * @param {boolean} [options.isFileProtocol] - Whether using file:// protocol
   * @param {boolean} [options.loadMetrics] - Load metrics (default: true)
   * @param {boolean} [options.loadAtlases] - Load atlases (default: true)
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {Promise} Resolves when all fonts are loaded
   */
  static async loadFonts(idStrings, options = {}, bitmapTextClass) {
    const {
      onProgress = null,
      isFileProtocol = false,
      loadMetrics = true,
      loadAtlases = true
    } = options;

    const filesPerFont = (loadMetrics ? 1 : 0) + (loadAtlases ? 1 : 0);
    const totalFiles = idStrings.length * filesPerFont;
    let loadedFiles = 0;

    const reportProgress = () => {
      if (onProgress) onProgress(loadedFiles, totalFiles);
    };

    for (const idString of idStrings) {
      // Check if already loading
      if (FontLoaderBase._loadingPromises.has(idString)) {
        await FontLoaderBase._loadingPromises.get(idString);
        continue;
      }

      const loadPromise = (async () => {
        try {
          if (loadMetrics) {
            await this.loadMetricsFile(idString, bitmapTextClass);
            loadedFiles++;
            reportProgress();
          }

          if (loadAtlases) {
            await this.loadAtlasFile(idString, isFileProtocol, bitmapTextClass);
            loadedFiles++;
            reportProgress();
          }
        } finally {
          FontLoaderBase._loadingPromises.delete(idString);
        }
      })();

      FontLoaderBase._loadingPromises.set(idString, loadPromise);
      await loadPromise;
    }
  }

  /**
   * Load only metrics for fonts
   * @param {Array<string>} idStrings - Array of font ID strings
   * @param {Object} options - Loading options
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {Promise} Resolves when metrics are loaded
   */
  static async loadMetrics(idStrings, options, bitmapTextClass) {
    return this.loadFonts(idStrings, { ...options, loadAtlases: false }, bitmapTextClass);
  }

  /**
   * Load only atlases for fonts (metrics must be loaded first)
   * @param {Array<string>} idStrings - Array of font ID strings
   * @param {Object} options - Loading options
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {Promise} Resolves when atlases are loaded
   */
  static async loadAtlases(idStrings, options, bitmapTextClass) {
    return this.loadFonts(idStrings, { ...options, loadMetrics: false }, bitmapTextClass);
  }

  // ============================================
  // Platform-Specific Loading (Abstract Methods)
  // ============================================

  /**
   * Load metrics file for a font
   * @abstract Must be implemented by derived classes
   * @param {string} idString - Font ID string
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {Promise} Resolves when metrics are loaded
   */
  static async loadMetricsFile(idString, bitmapTextClass) {
    throw new Error('FontLoaderBase.loadMetricsFile() must be implemented by derived class');
  }

  /**
   * Load atlas file for a font
   * @abstract Must be implemented by derived classes
   * @param {string} idString - Font ID string
   * @param {boolean} isFileProtocol - Whether using file:// protocol
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {Promise} Resolves when atlas is loaded
   */
  static async loadAtlasFile(idString, isFileProtocol, bitmapTextClass) {
    throw new Error('FontLoaderBase.loadAtlasFile() must be implemented by derived class');
  }

  // ============================================
  // Shared Atlas Reconstruction Logic
  // ============================================

  /**
   * Load atlas from package (image + metrics) and reconstruct positioning
   * @param {string} idString - Font ID string
   * @param {HTMLImageElement|HTMLCanvasElement} atlasImage - Atlas source image
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {boolean} True if atlas was reconstructed, false if pending metrics
   */
  static _loadAtlasFromPackage(idString, atlasImage, bitmapTextClass) {
    const fontProperties = FontProperties.fromIDString(idString);

    // Clean up temporary package storage
    delete FontLoaderBase._tempAtlasPackages[idString];

    // Get font metrics (required for reconstruction)
    const fontMetrics = FontMetricsStore.getFontMetrics(fontProperties);

    if (!fontMetrics) {
      // Store atlas for later reconstruction when metrics become available
      FontLoaderBase._pendingAtlases.set(idString, {atlasImage, bitmapTextClass});
      return false;
    }

    // Check if TightAtlasReconstructor is available
    if (typeof TightAtlasReconstructor === 'undefined') {
      throw new Error(`FontLoader: TightAtlasReconstructor required for font loading - not available for ${idString}`);
    }

    // Reconstruct tight atlas + positioning from Atlas image
    const { atlasImage: tightAtlasImage, atlasPositioning } =
      TightAtlasReconstructor.reconstructFromAtlas(fontMetrics, atlasImage);

    // Create AtlasData instance
    const atlasData = new AtlasData(tightAtlasImage, atlasPositioning);

    // Store directly in AtlasDataStore
    AtlasDataStore.setAtlasData(fontProperties, atlasData);

    return true;
  }

  /**
   * Process pending atlas that was waiting for metrics
   * @param {string} idString - Font ID string
   */
  static _processPendingAtlas(idString) {
    // Check if there's a pending atlas waiting for these metrics
    if (!FontLoaderBase._pendingAtlases.has(idString)) {
      return;
    }

    const {atlasImage, bitmapTextClass} = FontLoaderBase._pendingAtlases.get(idString);
    FontLoaderBase._pendingAtlases.delete(idString);

    // Try to load the atlas now that metrics are available
    FontLoaderBase._loadAtlasFromPackage(idString, atlasImage, bitmapTextClass);
  }
}

// ============================================================================
// FONT LOADER - NODE.JS
// ============================================================================
// FontLoader - Node.js-Specific Font Loader
//
// This static class extends FontLoaderBase to provide Node.js-specific
// font loading implementation using Node.js APIs (fs, path, require).
//
// DISTRIBUTION ROLE:
// - Only included in Node.js distributions
// - Excluded from browser bundles via build scripts
// - Uses Node.js-specific APIs (fs, path, eval)
//
// ARCHITECTURE:
// - Static class extending FontLoaderBase
// - Implements abstract methods for Node.js environment
// - Uses fs.readFileSync for metrics and atlas loading
// - Uses eval() to execute metrics registration code
// - Uses QOIDecode for atlas decompression
//
// LOADING STRATEGIES:
// - Metrics: fs.readFileSync + eval()
// - Atlas: fs.readFileSync QOI file + QOIDecode + canvas creation

class FontLoader extends FontLoaderBase {

  // ============================================
  // File Name Constants (from BitmapText)
  // ============================================

  static METRICS_PREFIX = 'metrics-';
  static ATLAS_PREFIX = 'atlas-';
  static JS_EXTENSION = '.js';

  // ============================================
  // Node.js-Specific Loading Implementation
  // ============================================

  /**
   * Load metrics file via fs.readFileSync + eval
   * @param {string} idString - Font ID string
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {Promise} Resolves when metrics are loaded
   */
  static async loadMetricsFile(idString, bitmapTextClass) {
    if (typeof require === 'undefined') {
      throw new Error('FontLoader.loadMetricsFile requires Node.js environment');
    }

    const fs = require('fs');
    const path = require('path');

    const fontDirectory = FontLoaderBase.getFontDirectory();
    const metricsPath = path.resolve(fontDirectory, `${FontLoader.METRICS_PREFIX}${idString}${FontLoader.JS_EXTENSION}`);

    try {
      const metricsCode = fs.readFileSync(metricsPath, 'utf8');
      // Execute with BitmapText in scope
      // The metrics file will call BitmapText.registerMetrics()
      eval(metricsCode);
    } catch (error) {
      console.warn(`Metrics file not found: ${metricsPath}`);
      throw error;
    }
  }

  /**
   * Load atlas file via fs.readFileSync + QOIDecode
   * @param {string} idString - Font ID string
   * @param {boolean} isFileProtocol - Not used in Node.js
   * @param {Object} bitmapTextClass - BitmapText class reference
   * @returns {Promise} Resolves when atlas is loaded
   */
  static async loadAtlasFile(idString, isFileProtocol, bitmapTextClass) {
    if (typeof require === 'undefined') {
      throw new Error('FontLoader.loadAtlasFile requires Node.js environment');
    }

    const fs = require('fs');
    const path = require('path');

    const fontDirectory = FontLoaderBase.getFontDirectory();
    const atlasPath = path.resolve(fontDirectory, `${FontLoader.ATLAS_PREFIX}${idString}-qoi${FontLoader.JS_EXTENSION}`);

    try {
      const atlasCode = fs.readFileSync(atlasPath, 'utf8');
      // Execute with BitmapText in scope to call registerAtlas
      // The atlas file will call BitmapText.registerAtlas()
      eval(atlasCode);

      // Now reconstruct the atlas
      const pkg = FontLoaderBase._tempAtlasPackages[idString];
      if (pkg && pkg.base64Data) {
        // Decode QOI
        if (typeof QOIDecode === 'undefined') {
          throw new Error('FontLoader: QOIDecode not available - required for atlas loading');
        }

        const qoiData = Uint8Array.from(atob(pkg.base64Data), c => c.charCodeAt(0));
        const decoded = QOIDecode(qoiData.buffer);

        // Create canvas and draw (explicit double invocation: get factory, call factory)
        const canvas = bitmapTextClass.getCanvasFactory()();
        canvas.width = decoded.width;
        canvas.height = decoded.height;
        const ctx = canvas.getContext('2d');
        const imageData = ctx.createImageData(decoded.width, decoded.height);
        imageData.data.set(decoded.data);
        ctx.putImageData(imageData, 0, 0);

        // Reconstruct atlas
        FontLoaderBase._loadAtlasFromPackage(idString, canvas, bitmapTextClass);
      }
    } catch (error) {
      console.warn(`Atlas loading error for ${atlasPath}: ${error.message}`);
      console.warn('Will use placeholder rectangles');
    }
  }
}

// ============================================================================
// TEST DATA
// ============================================================================
/**
 * Shared test data for performance benchmarking
 * Multi-line text blocks for realistic rendering scenarios
 */

// 5-line pangram block for testing
const TEST_BLOCK_5_LINES = [
  "The quick brown fox jumps over the lazy dog",
  "Pack my box with five dozen liquor jugs",
  "How vexingly quick daft zebras jump",
  "Sphinx of black quartz, judge my vow",
  "Two driven jocks help fax my big quiz"
];

// 10-line extended test block
const TEST_BLOCK_10_LINES = [
  "The quick brown fox jumps over the lazy dog",
  "Pack my box with five dozen liquor jugs",
  "How vexingly quick daft zebras jump",
  "Sphinx of black quartz, judge my vow",
  "Two driven jocks help fax my big quiz",
  "Amazingly few discotheques provide jukeboxes",
  "The five boxing wizards jump quickly",
  "Jackdaws love my big sphinx of quartz",
  "Bright vixens jump; dozy fowl quack",
  "Quick zephyrs blow, vexing daft Jim"
];

// Single long line for stress testing
const TEST_LONG_LINE = "The quick brown fox jumps over the lazy dog. Pack my box with five dozen liquor jugs. How vexingly quick daft zebras jump. Sphinx of black quartz, judge my vow. Two driven jocks help fax my big quiz. The five boxing wizards jump quickly.";

// Export for both browser and Node.js environments
if (typeof module !== 'undefined' && module.exports) {
  // Node.js
  module.exports = {
    TEST_BLOCK_5_LINES,
    TEST_BLOCK_10_LINES,
    TEST_LONG_LINE
  };
}
// Browser globals will be available via script tag

// ============================================================================
// BENCHMARK LOGIC
// ============================================================================

/**
 * BitmapText.js Measurement Performance Benchmark (Unbundled Version)
 *
 * Tests measureText() performance with adaptive timing.
 * This is the unbundled standalone version - all dependencies concatenated.
 *
 * Usage: node measurement-benchmark-unbundled.bundle.js
 * Output: JSON results to stdout
 */

// ============================================================
// Performance Measurement Functions
// ============================================================

/**
 * Measure execution time with high iteration count
 */
function measurePerformance(fn, iterations = 10000) {
  // Warm up (avoid JIT compilation effects)
  for (let i = 0; i < 100; i++) fn();

  // Actual measurement
  const start = performance.now();
  for (let i = 0; i < iterations; i++) {
    fn();
  }
  const elapsed = performance.now() - start;

  return {
    totalTime: elapsed,
    avgTime: elapsed / iterations,
    opsPerSec: (1000 * iterations) / elapsed,
    iterations
  };
}

// ============================================================
// Main Benchmark Function
// ============================================================

async function main() {
  console.log('🚀 BitmapText.js Measurement Performance Benchmark (UNBUNDLED)');
  console.log(`Platform: ${process.platform}`);
  console.log(`Node version: ${process.version}`);
  console.log(`Architecture: ${process.arch}`);
  console.log('');

  // Configure BitmapText
  const path = require('path');
  const fontDirectory = path.resolve(__dirname, '../../../font-assets/');

  BitmapText.configure({
    fontDirectory: fontDirectory,
    canvasFactory: () => new Canvas()
  });

  // Create font properties
  const fontProperties = new FontProperties(1, 'Arial', 'normal', 'normal', 19);

  // Load font
  console.log('⏳ Loading font...');
  const loadStart = performance.now();
  await BitmapText.loadFont(fontProperties.idString);
  const loadTime = performance.now() - loadStart;
  console.log(`✅ Font loaded in ${loadTime.toFixed(2)}ms`);
  console.log('');

  const results = {
    version: 'unbundled',
    platform: {
      os: process.platform,
      nodeVersion: process.version,
      arch: process.arch
    },
    timestamp: new Date().toISOString(),
    fontLoading: {
      loadTime,
      fontId: fontProperties.idString
    },
    tests: []
  };

  const textPropsKerning = new TextProperties({ isKerningEnabled: true });
  const textPropsNoKerning = new TextProperties({ isKerningEnabled: false });

  // Test 1: Text Length Scaling
  console.log('📊 Test 1/3: Text length scaling');
  const lengths = [5, 10, 25, 50, 100, 250, 500];

  lengths.forEach(length => {
    const text = TEST_LONG_LINE.substring(0, length);
    const result = measurePerformance(() => {
      BitmapText.measureText(text, fontProperties, textPropsKerning);
    });

    console.log(`   ${length} chars: ${(result.avgTime * 1000).toFixed(3)}μs avg, ${result.opsPerSec.toFixed(0)} ops/sec`);

    results.tests.push({
      category: 'Text Length Scaling',
      test: `${length} characters`,
      textLength: length,
      ...result
    });
  });
  console.log('');

  // Test 2: Kerning Overhead
  console.log('📊 Test 2/3: Kerning overhead');
  const testText = TEST_LONG_LINE.substring(0, 50);

  const kerningOn = measurePerformance(() => {
    BitmapText.measureText(testText, fontProperties, textPropsKerning);
  });

  const kerningOff = measurePerformance(() => {
    BitmapText.measureText(testText, fontProperties, textPropsNoKerning);
  });

  const overhead = ((kerningOn.avgTime - kerningOff.avgTime) / kerningOff.avgTime * 100).toFixed(1);

  console.log(`   Kerning ON:  ${(kerningOn.avgTime * 1000).toFixed(3)}μs avg`);
  console.log(`   Kerning OFF: ${(kerningOff.avgTime * 1000).toFixed(3)}μs avg`);
  console.log(`   Overhead: ${overhead}%`);
  console.log('');

  results.tests.push({
    category: 'Kerning Overhead',
    test: 'Kerning ON',
    textLength: 50,
    ...kerningOn
  });

  results.tests.push({
    category: 'Kerning Overhead',
    test: 'Kerning OFF',
    textLength: 50,
    ...kerningOff
  });

  // Test 3: Repeated Measurements (60fps pattern)
  console.log('📊 Test 3/3: Repeated measurements (60fps pattern)');
  const repeatText = "Hello World";

  const repeated60x = measurePerformance(() => {
    for (let i = 0; i < 60; i++) {
      BitmapText.measureText(repeatText, fontProperties, textPropsKerning);
    }
  }, 1000);  // Lower outer iterations since we're doing 60 inside

  const perFrame = repeated60x.avgTime;
  const perMeasurement = repeated60x.avgTime / 60;

  console.log(`   Per frame (60 measurements): ${perFrame.toFixed(3)}ms`);
  console.log(`   Per measurement: ${(perMeasurement * 1000).toFixed(3)}μs`);
  console.log(`   Frames per second: ${(1000 / perFrame).toFixed(1)} fps`);
  console.log('');

  results.tests.push({
    category: 'Repeated Measurements',
    test: '60 measurements per frame',
    textLength: repeatText.length,
    totalTime: repeated60x.totalTime,
    avgTime: repeated60x.avgTime,
    opsPerSec: repeated60x.opsPerSec / 60,  // Per batch
    iterations: repeated60x.iterations,
    perMeasurement: perMeasurement,
    framesPerSecond: 1000 / perFrame
  });

  // Output JSON to stdout
  console.log('JSON_RESULTS_START');
  console.log(JSON.stringify(results, null, 2));
  console.log('JSON_RESULTS_END');

  console.log('✅ Benchmark complete');
}

// Run main function
main().catch(error => {
  console.error('❌ Benchmark error:', error);
  process.exit(1);
});
