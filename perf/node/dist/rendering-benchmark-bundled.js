#!/usr/bin/env node

/**
 * ‚ö†Ô∏è  THIS IS A BUNDLED/BUILT FILE - DO NOT EDIT ‚ö†Ô∏è
 *
 * BitmapText.js Performance Benchmark - Bundled Version
 *
 * This version uses the production runtime bundle.
 *
 * Usage:
 *   node perf/node/dist/rendering-benchmark-bundled.js
 *
 * Output:
 *   JSON results to stdout
 *
 * Generated by: scripts/build-rendering-benchmark.sh
 */

// ============================================================================
// USER-PROVIDED DEPENDENCIES
// ============================================================================

// Canvas Mock - Minimal HTML Canvas API Implementation
//
// This module provides a lightweight Canvas API implementation for Node.js
// environments where node-canvas is not available or desired. It implements
// only the subset of Canvas API methods required by BitmapText.js.
//
// DISTRIBUTION ROLE:
// - Only included in Node.js distributions
// - Excluded from browser bundles via build scripts
// - Used as fallback when node-canvas is unavailable
//
// ARCHITECTURE:
// - Three classes: Canvas, Context2D, and Image
// - Pure JavaScript pixel manipulation using Uint8ClampedArray
// - No external dependencies (no node-canvas, no Sharp, no Jimp)
// - Implements minimal Canvas API surface needed for font rendering
//
// SUPPORTED CANVAS API SUBSET:
// - Canvas: width, height properties, getContext('2d')
// - Context2D: fillStyle, globalCompositeOperation, fillRect, clearRect,
//   drawImage, createImageData, putImageData, getImageData
// - Image: width, height, data properties
//
// LIMITATIONS COMPARED TO REAL CANVAS:
// - No anti-aliasing or bilinear filtering (nearest-neighbor only)
// - Limited color format support (hex colors and named 'black'/'white')
// - No text rendering (fillText is stub)
// - No path operations (moveTo, lineTo, stroke, etc.)
// - No gradients or patterns
// - Only 'source-over' and 'source-in' composite operations
// - No image format encoding (no PNG/JPEG output)
// - drawImage supports only 3-argument, 5-argument, and 9-argument forms
//
// PERFORMANCE CONSIDERATIONS:
// - Pure JavaScript pixel operations are slower than native implementations
// - Best suited for small images and simple operations
// - For production Node.js use, prefer node-canvas when available

// ============================================
// Canvas Class - Minimal Canvas Element Mock
// ============================================

/**
 * Canvas - Minimal HTML Canvas element implementation
 *
 * Provides a basic canvas with width/height properties and pixel buffer.
 * The pixel buffer is a Uint8ClampedArray in RGBA format (4 bytes per pixel).
 *
 * @class Canvas
 */
class Canvas {
  constructor() {
    this._width = 0;
    this._height = 0;
    this.data = null;
  }
  
  get width() { return this._width; }
  set width(w) {
    this._width = w;
    this._updateBuffer();
  }
  
  get height() { return this._height; }
  set height(h) {
    this._height = h;
    this._updateBuffer();
  }
  
  /**
   * Update internal pixel buffer when dimensions change
   * @private
   */
  _updateBuffer() {
    if (this._width > 0 && this._height > 0) {
      this.data = new Uint8ClampedArray(this._width * this._height * 4);
    }
  }

  /**
   * Get rendering context (only '2d' is supported)
   * @param {string} type - Context type ('2d' is the only supported value)
   * @returns {Context2D|null} 2D rendering context or null if unsupported type
   */
  getContext(type) {
    if (type === '2d') {
      return new Context2D(this);
    }
    return null;
  }
}

// ============================================
// Context2D Class - Canvas 2D Rendering Context
// ============================================

/**
 * Context2D - Minimal CanvasRenderingContext2D implementation
 *
 * Provides basic 2D drawing operations for font rendering. Supports
 * rectangular operations, image drawing, and pixel data manipulation.
 * Does not support paths, text rendering, or advanced compositing.
 *
 * @class Context2D
 */
class Context2D {
  constructor(canvas) {
    this.canvas = canvas;
    this.fillStyle = '#000000';
    this.globalCompositeOperation = 'source-over';

    // Transform stack for save/restore (minimal implementation)
    this._stateStack = [];
  }

  // ============================================
  // Transform Operations (Minimal Implementation)
  // ============================================

  /**
   * Save current context state
   *
   * In full Canvas API, this saves transform, fill style, etc.
   * For canvas-mock, we only save fillStyle and globalCompositeOperation
   * since we don't actually use transforms for drawing.
   */
  save() {
    this._stateStack.push({
      fillStyle: this.fillStyle,
      globalCompositeOperation: this.globalCompositeOperation
    });
  }

  /**
   * Restore previously saved context state
   *
   * Restores the most recently saved state from the stack.
   */
  restore() {
    if (this._stateStack.length > 0) {
      const state = this._stateStack.pop();
      this.fillStyle = state.fillStyle;
      this.globalCompositeOperation = state.globalCompositeOperation;
    }
  }

  /**
   * Set transform matrix (no-op in canvas-mock)
   *
   * Canvas-mock uses direct pixel coordinate operations without transforms.
   * This method exists for API compatibility with BitmapText's transform reset,
   * but does not actually modify drawing behavior.
   *
   * @param {number} a - Transform matrix parameter (ignored)
   * @param {number} b - Transform matrix parameter (ignored)
   * @param {number} c - Transform matrix parameter (ignored)
   * @param {number} d - Transform matrix parameter (ignored)
   * @param {number} e - Transform matrix parameter (ignored)
   * @param {number} f - Transform matrix parameter (ignored)
   */
  setTransform(a, b, c, d, e, f) {
    // No-op: canvas-mock doesn't implement transforms
    // Drawing operations use direct pixel coordinates regardless of transform state
  }

  // ============================================
  // Rectangle Operations
  // ============================================

  /**
   * Clear a rectangular area to transparent black
   * @param {number} x - X coordinate of rectangle top-left corner
   * @param {number} y - Y coordinate of rectangle top-left corner
   * @param {number} w - Rectangle width
   * @param {number} h - Rectangle height
   */
  clearRect(x, y, w, h) {
    if (!this.canvas.data) return;
    
    const data = this.canvas.data;
    const canvasWidth = this.canvas.width;
    
    for (let py = Math.max(0, y); py < Math.min(this.canvas.height, y + h); py++) {
      for (let px = Math.max(0, x); px < Math.min(canvasWidth, x + w); px++) {
        const i = (py * canvasWidth + px) * 4;
        data[i] = data[i+1] = data[i+2] = data[i+3] = 0;
      }
    }
  }

  /**
   * Fill a rectangular area with the current fillStyle
   *
   * Supports two composite operations:
   * - 'source-over': Normal fill (replaces pixels with fillStyle)
   * - 'source-in': Preserve alpha channel, only change RGB channels
   *                (used for colorizing glyph masks)
   *
   * @param {number} x - X coordinate of rectangle top-left corner
   * @param {number} y - Y coordinate of rectangle top-left corner
   * @param {number} w - Rectangle width
   * @param {number} h - Rectangle height
   */
  fillRect(x, y, w, h) {
    if (!this.canvas.data) return;

    const data = this.canvas.data;
    const canvasWidth = this.canvas.width;
    const [r, g, b] = this._parseColor(this.fillStyle);

    // Canvas coordinates must be integers (callers should round before calling)
    // Clamp to canvas bounds
    const x0 = Math.max(0, x);
    const y0 = Math.max(0, y);
    const x1 = Math.min(canvasWidth, x + w);
    const y1 = Math.min(this.canvas.height, y + h);

    for (let py = y0; py < y1; py++) {
      for (let px = x0; px < x1; px++) {
        const i = (py * canvasWidth + px) * 4;

        if (this.globalCompositeOperation === 'source-in') {
          // 'source-in' composite operation: Only fill where destination alpha > 0
          // This preserves the alpha channel (glyph shape) while changing the color.
          // Used by BitmapText to colorize white glyph masks with desired text color.
          if (data[i+3] > 0) {
            data[i] = r;
            data[i+1] = g;
            data[i+2] = b;
            // Keep existing alpha value (don't modify data[i+3])
          }
        } else {
          // 'source-over': Normal fill operation (default)
          data[i] = r;
          data[i+1] = g;
          data[i+2] = b;
          data[i+3] = 255;
        }
      }
    }
  }

  // ============================================
  // Composite Operation Property
  // ============================================

  /**
   * Set global composite operation (getter/setter handled by direct property access)
   *
   * Supported operations:
   * - 'source-over': Default - new pixels replace old pixels
   * - 'source-in': New pixels only drawn where destination alpha > 0,
   *                preserving destination alpha (used for colorization)
   *
   * @type {string}
   */
  // Note: globalCompositeOperation is set directly as a property in constructor

  // ============================================
  // Image Drawing
  // ============================================

  /**
   * Draw an image onto the canvas with optional scaling and clipping
   *
   * Supports three call signatures:
   * 1. drawImage(image, dx, dy) - Draw at position without scaling
   * 2. drawImage(image, dx, dy, dw, dh) - Draw scaled to fit rectangle
   * 3. drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) - Draw clipped source region
   *
   * Uses nearest-neighbor sampling for scaling (no bilinear filtering).
   * This is faster but produces pixelated results when scaling.
   * Sufficient for bitmap font rendering where glyphs are drawn at original size.
   *
   * @param {Image|Canvas} image - Source image or canvas
   * @param {number} sx - Source X (or dx in 3-arg form)
   * @param {number} sy - Source Y (or dy in 3-arg form)
   * @param {number} sw - Source width (or dw in 5-arg form)
   * @param {number} sh - Source height (or dh in 5-arg form)
   * @param {number} dx - Destination X
   * @param {number} dy - Destination Y
   * @param {number} dw - Destination width
   * @param {number} dh - Destination height
   */
  drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (!this.canvas.data || !image.data) return;
    
    // Handle different call signatures by reassigning parameters
    // JavaScript allows flexible parameter handling through arguments.length
    if (arguments.length === 5) {
      // 5-argument form: drawImage(image, dx, dy, dw, dh)
      // Parameters are shifted: sx->dw, sy->dh, sw->dx, sh->dy
      dw = sx; dh = sy; dx = sw; dy = sh;
      sx = 0; sy = 0; sw = image.width; sh = image.height;
    } else if (arguments.length === 3) {
      // 3-argument form: drawImage(image, dx, dy)
      // Parameters are shifted: sx->dx, sy->dy
      dx = sx; dy = sy;
      sx = 0; sy = 0; sw = image.width; sh = image.height;
      dw = sw; dh = sh;
    }
    // 9-argument form uses parameters as-is (no reassignment needed)
    
    const destData = this.canvas.data;
    const srcData = image.data;
    const destWidth = this.canvas.width;
    const srcWidth = image.width;

    // Nearest-neighbor sampling (no bilinear filtering)
    // This is the simplest scaling algorithm: for each destination pixel,
    // find the closest source pixel and copy its color. Fast but produces
    // pixelated results when scaling up. For bitmap fonts, glyphs are typically
    // drawn at original size, so scaling artifacts are rarely visible.
    for (let y = 0; y < dh; y++) {
      for (let x = 0; x < dw; x++) {
        const srcX = Math.floor(sx + (x * sw / dw));
        const srcY = Math.floor(sy + (y * sh / dh));
        const destX = dx + x;
        const destY = dy + y;
        
        if (srcX >= 0 && srcX < image.width && srcY >= 0 && srcY < image.height &&
            destX >= 0 && destX < this.canvas.width && destY >= 0 && destY < this.canvas.height) {
          
          const srcI = (srcY * srcWidth + srcX) * 4;
          const destI = (destY * destWidth + destX) * 4;
          
          if (srcData[srcI + 3] > 0) {  // Only copy non-transparent pixels
            destData[destI] = srcData[srcI];     // R
            destData[destI + 1] = srcData[srcI + 1]; // G
            destData[destI + 2] = srcData[srcI + 2]; // B
            destData[destI + 3] = srcData[srcI + 3]; // A
          }
        }
      }
    }
  }

  // ============================================
  // Image Data Operations
  // ============================================

  /**
   * Create a new ImageData object with specified dimensions
   * @param {number} w - Width in pixels
   * @param {number} h - Height in pixels
   * @returns {Object} ImageData object with width, height, and data properties
   */
  createImageData(w, h) {
    return {
      width: w,
      height: h,
      data: new Uint8ClampedArray(w * h * 4)
    };
  }

  /**
   * Write ImageData directly to canvas at specified position
   *
   * Copies pixel data from ImageData object to canvas buffer.
   * Ignores composite operations and alpha blending - raw pixel copy.
   *
   * @param {Object} imageData - ImageData object with width, height, and data
   * @param {number} dx - Destination X coordinate
   * @param {number} dy - Destination Y coordinate
   */
  putImageData(imageData, dx, dy) {
    if (!this.canvas.data) return;

    const canvasData = this.canvas.data;
    const canvasWidth = this.canvas.width;
    const canvasHeight = this.canvas.height;
    const srcData = imageData.data;
    const srcWidth = imageData.width;
    const srcHeight = imageData.height;

    for (let y = 0; y < srcHeight; y++) {
      for (let x = 0; x < srcWidth; x++) {
        const destX = dx + x;
        const destY = dy + y;

        if (destX >= 0 && destX < canvasWidth && destY >= 0 && destY < canvasHeight) {
          const srcI = (y * srcWidth + x) * 4;
          const destI = (destY * canvasWidth + destX) * 4;

          canvasData[destI] = srcData[srcI];
          canvasData[destI + 1] = srcData[srcI + 1];
          canvasData[destI + 2] = srcData[srcI + 2];
          canvasData[destI + 3] = srcData[srcI + 3];
        }
      }
    }
  }

  /**
   * Extract pixel data from canvas as ImageData object
   *
   * Reads a rectangular region from the canvas and returns it as an
   * ImageData object. Pixels outside canvas bounds are transparent black.
   *
   * @param {number} x - Source X coordinate
   * @param {number} y - Source Y coordinate
   * @param {number} w - Width of region to extract
   * @param {number} h - Height of region to extract
   * @returns {Object} ImageData object containing the extracted pixels
   */
  getImageData(x, y, w, h) {
    if (!this.canvas.data) {
      return {
        width: w,
        height: h,
        data: new Uint8ClampedArray(w * h * 4)
      };
    }

    const canvasWidth = this.canvas.width;
    const canvasHeight = this.canvas.height;
    const canvasData = this.canvas.data;
    const imageData = new Uint8ClampedArray(w * h * 4);

    for (let py = 0; py < h; py++) {
      for (let px = 0; px < w; px++) {
        const srcX = x + px;
        const srcY = y + py;

        if (srcX >= 0 && srcX < canvasWidth && srcY >= 0 && srcY < canvasHeight) {
          const srcI = (srcY * canvasWidth + srcX) * 4;
          const destI = (py * w + px) * 4;

          imageData[destI] = canvasData[srcI];
          imageData[destI + 1] = canvasData[srcI + 1];
          imageData[destI + 2] = canvasData[srcI + 2];
          imageData[destI + 3] = canvasData[srcI + 3];
        }
      }
    }

    return {
      width: w,
      height: h,
      data: imageData
    };
  }

  // ============================================
  // Color Parsing Utilities
  // ============================================

  /**
   * Parse color string to RGB values
   *
   * Supports limited color format subset:
   * - Named colors: 'white', 'black'
   * - Hex colors: '#RRGGBB' (6-digit hex)
   * - Unsupported formats default to black
   *
   * Does not support:
   * - Short hex (#RGB)
   * - rgba() or rgb() functions
   * - hsl() colors
   * - Other named colors
   *
   * @private
   * @param {string} color - Color string to parse
   * @returns {number[]} RGB values as [r, g, b] array (0-255 range)
   */
  _parseColor(color) {
    if (color === 'white') return [255, 255, 255];
    if (color === 'black' || color === '#000000') return [0, 0, 0];

    // Simple hex parsing
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      if (hex.length === 6) {
        return [
          parseInt(hex.slice(0, 2), 16),
          parseInt(hex.slice(2, 4), 16),
          parseInt(hex.slice(4, 6), 16)
        ];
      }
    }

    return [0, 0, 0]; // Default to black
  }
}

// ============================================
// Image Class - Decoded Image Container
// ============================================

/**
 * Image - Simple container for decoded image pixel data
 *
 * Holds decoded image data in RGBA format. Unlike browser Image objects,
 * this does not support loading from URLs or file paths - pixel data
 * must be provided directly during construction.
 *
 * @class Image
 */
class Image {
  /**
   * Create a new Image with pixel data
   * @param {number} width - Image width in pixels
   * @param {number} height - Image height in pixels
   * @param {Uint8ClampedArray} data - Pixel data in RGBA format (4 bytes per pixel)
   */
  constructor(width, height, data) {
    this.width = width;
    this.height = height;
    this.data = data;
  }
}

/**
 * PngEncodingOptions class for SWCanvas PngEncoder
 * 
 * Provides configuration options for PNG encoding operations.
 * Follows immutable object-oriented design principles per Joshua Bloch's Effective Java.
 * 
 * Key Features:
 * - Immutable options objects prevent accidental modification
 * - Static factory methods provide clear API
 * - Extensible design allows for future encoding options
 * - Type-safe configuration prevents parameter confusion
 * - Simpler than BitmapEncodingOptions since PNG supports transparency natively
 */
class PngEncodingOptions {
    /**
     * Create PngEncodingOptions instance
     * @param {Object} config - Configuration object
     * @param {boolean} config.preserveTransparency - Whether to preserve transparency (default: true)
     * @param {number} config.compressionLevel - Future placeholder for compression (0 = none, currently unused)
     */
    constructor(config = {}) {
        // Set defaults
        const {
            preserveTransparency = true,
            compressionLevel = 0  // 0 = no compression (stored blocks)
        } = config;
        
        // Validate parameters
        if (typeof preserveTransparency !== 'boolean') {
            throw new Error('preserveTransparency must be a boolean');
        }
        
        if (typeof compressionLevel !== 'number' || compressionLevel < 0 || compressionLevel > 9) {
            throw new Error('compressionLevel must be a number between 0-9');
        }
        
        // Currently only support compression level 0 (stored blocks)
        if (compressionLevel !== 0) {
            throw new Error('Only compression level 0 (no compression) is currently supported');
        }
        
        // Store immutable configuration
        this._config = Object.freeze({
            preserveTransparency,
            compressionLevel
        });
        
        // Make this instance immutable
        Object.freeze(this);
    }
    
    /**
     * Get whether transparency should be preserved
     * @returns {boolean} True if transparency is preserved
     */
    get preserveTransparency() {
        return this._config.preserveTransparency;
    }
    
    /**
     * Get compression level
     * @returns {number} Compression level (0-9, currently only 0 supported)
     */
    get compressionLevel() {
        return this._config.compressionLevel;
    }
    
    /**
     * Create default options (transparency preserved, no compression)
     * @returns {PngEncodingOptions} Default options instance
     */
    static withDefaults() {
        return new PngEncodingOptions();
    }
    
    /**
     * Create options with transparency preserved (default behavior)
     * @returns {PngEncodingOptions} Options with transparency preserved
     */
    static withTransparency() {
        return new PngEncodingOptions({ preserveTransparency: true });
    }
    
    /**
     * Create options for opaque images (transparency ignored)
     * Note: This doesn't affect the PNG format (still RGBA), but may be useful for future optimizations
     * @returns {PngEncodingOptions} Options for opaque images
     */
    static withoutTransparency() {
        return new PngEncodingOptions({ preserveTransparency: false });
    }
    
    /**
     * Create options with specific compression level (future extensibility)
     * @param {number} level - Compression level (0-9, currently only 0 supported)
     * @returns {PngEncodingOptions} Options with specified compression level
     */
    static withCompressionLevel(level) {
        return new PngEncodingOptions({ compressionLevel: level });
    }
    
    /**
     * Create options for lossless (no compression, preserve transparency)
     * @returns {PngEncodingOptions} Lossless options
     */
    static forMaximumCompatibility() {
        return new PngEncodingOptions({
            preserveTransparency: true,
            compressionLevel: 0
        });
    }
    
    /**
     * Check if two options instances are equal
     * @param {PngEncodingOptions} other - Other options to compare
     * @returns {boolean} True if options are equivalent
     */
    equals(other) {
        if (!(other instanceof PngEncodingOptions)) {
            return false;
        }
        
        const config1 = this._config;
        const config2 = other._config;
        
        return config1.preserveTransparency === config2.preserveTransparency &&
               config1.compressionLevel === config2.compressionLevel;
    }
    
    /**
     * Get string representation for debugging
     * @returns {string} String representation
     */
    toString() {
        const config = this._config;
        return `PngEncodingOptions(transparency: ${config.preserveTransparency}, compression: ${config.compressionLevel})`;
    }
    
    /**
     * Create a new options instance with modified transparency setting
     * @param {boolean} preserveTransparency - Whether to preserve transparency
     * @returns {PngEncodingOptions} New options instance
     */
    withTransparency(preserveTransparency) {
        return new PngEncodingOptions({
            preserveTransparency,
            compressionLevel: this._config.compressionLevel
        });
    }
    
    /**
     * Create a new options instance with modified compression level
     * @param {number} compressionLevel - Compression level (0-9, currently only 0 supported)
     * @returns {PngEncodingOptions} New options instance
     */
    withCompression(compressionLevel) {
        return new PngEncodingOptions({
            preserveTransparency: this._config.preserveTransparency,
            compressionLevel
        });
    }
}

// Default options instance - preserve transparency, no compression (maintains simplicity)
PngEncodingOptions.DEFAULT = new PngEncodingOptions();

/**
 * PngEncoder class for SWCanvas
 * 
 * Handles encoding of Surface data to minimal PNG format with transparency support.
 * Uses uncompressed DEFLATE blocks for simplicity while maintaining PNG compliance.
 * Provides static methods for encoding with proper alpha handling.
 * 
 * Following OO best practices:
 * - Static methods for stateless encoding operations
 * - Clear separation of PNG chunk generation and pixel processing
 * - Proper error handling and validation
 * - Support for transparency (unlike BMP format)
 */
class PngEncoder {
    /**
     * Encode a surface to PNG format
     * @param {Surface} surface - Surface to encode  
     * @param {PngEncodingOptions} [options=PngEncodingOptions.DEFAULT] - Encoding options
     * @returns {ArrayBuffer} PNG file data
     */
    static encode(surface, options = PngEncodingOptions.DEFAULT) {
        if (!surface || typeof surface !== 'object') {
            throw new Error('Surface must be a valid Surface object');
        }
        
        if (!surface.width || !surface.height || !surface.data) {
            throw new Error('Surface must have width, height, and data properties');
        }
        
        const width = surface.width;
        const height = surface.height;
        const data = surface.data;
        
        // Validate surface data
        const expectedSize = width * height * 4;
        if (data.length !== expectedSize) {
            throw new Error(`Surface data size mismatch. Expected ${expectedSize}, got ${data.length}`);
        }
        
        // Validate dimensions
        if (width <= 0 || height <= 0) {
            throw new Error('Surface dimensions must be positive');
        }
        
        if (width > PngEncoder.MAX_DIMENSION || height > PngEncoder.MAX_DIMENSION) {
            throw new Error(`Surface dimensions must be ‚â§ ${PngEncoder.MAX_DIMENSION}x${PngEncoder.MAX_DIMENSION}`);
        }
        
        // Create scanlines with filter bytes (filter 0 = None)
        const scanlines = PngEncoder._createScanlines(width, height, data);
        
        // Create compressed data using stored DEFLATE blocks
        const zlibData = PngEncoder._createZlibData(scanlines);
        
        // Build PNG chunks
        const signature = PngEncoder._createSignature();
        const ihdrChunk = PngEncoder._createIHDRChunk(width, height);
        const idatChunk = PngEncoder._createIDATChunk(zlibData);
        const iendChunk = PngEncoder._createIENDChunk();
        
        // Concatenate all parts
        const totalLength = signature.length + ihdrChunk.length + idatChunk.length + iendChunk.length;
        const result = new Uint8Array(totalLength);
        
        let offset = 0;
        result.set(signature, offset);
        offset += signature.length;
        result.set(ihdrChunk, offset);
        offset += ihdrChunk.length;
        result.set(idatChunk, offset);
        offset += idatChunk.length;
        result.set(iendChunk, offset);
        
        return result.buffer;
    }
    
    /**
     * Create PNG signature (8 bytes)
     * @returns {Uint8Array} PNG signature
     * @private
     */
    static _createSignature() {
        return new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
    }
    
    /**
     * Create scanlines with filter bytes
     * @param {number} width - Image width
     * @param {number} height - Image height  
     * @param {Uint8ClampedArray} data - RGBA pixel data (non-premultiplied)
     * @returns {Uint8Array} Scanlines with filter bytes
     * @private
     */
    static _createScanlines(width, height, data) {
        const bytesPerPixel = 4; // RGBA
        const stride = width * bytesPerPixel;
        const scanlineLength = stride + 1; // +1 for filter byte
        const result = new Uint8Array(scanlineLength * height);
        
        let srcOffset = 0;
        let destOffset = 0;
        
        for (let y = 0; y < height; y++) {
            // Filter type 0 (None)
            result[destOffset++] = 0;
            
            // Copy scanline (RGBA order, already non-premultiplied)
            for (let x = 0; x < width; x++) {
                result[destOffset++] = data[srcOffset++]; // R
                result[destOffset++] = data[srcOffset++]; // G  
                result[destOffset++] = data[srcOffset++]; // B
                result[destOffset++] = data[srcOffset++]; // A
            }
        }
        
        return result;
    }
    
    /**
     * Create zlib data with stored DEFLATE blocks
     * @param {Uint8Array} uncompressed - Uncompressed scanline data
     * @returns {Uint8Array} Zlib-wrapped data
     * @private
     */
    static _createZlibData(uncompressed) {
        // Zlib header (CMF=0x78, FLG=0x01 for stored blocks)
        const header = new Uint8Array([0x78, 0x01]);
        
        // Split into DEFLATE stored blocks (max 65535 bytes per block)
        const blocks = [];
        const maxBlockSize = 65535;
        let offset = 0;
        
        while (offset < uncompressed.length) {
            const remaining = uncompressed.length - offset;
            const blockSize = Math.min(maxBlockSize, remaining);
            const isLastBlock = (offset + blockSize === uncompressed.length);
            
            // Block header: BFINAL (1 bit) + BTYPE (2 bits, 00 = stored)
            const bfinal = isLastBlock ? 1 : 0;
            const blockHeader = new Uint8Array(5);
            blockHeader[0] = bfinal; // BFINAL=1 if last, BTYPE=00
            
            // LEN (little-endian)
            blockHeader[1] = blockSize & 0xFF;
            blockHeader[2] = (blockSize >>> 8) & 0xFF;
            
            // NLEN (bitwise NOT of LEN, little-endian)
            const nlen = (~blockSize) & 0xFFFF;
            blockHeader[3] = nlen & 0xFF;
            blockHeader[4] = (nlen >>> 8) & 0xFF;
            
            blocks.push(blockHeader);
            blocks.push(uncompressed.subarray(offset, offset + blockSize));
            
            offset += blockSize;
        }
        
        // Calculate Adler-32 checksum
        const adler32 = PngEncoder._calculateAdler32(uncompressed);
        const trailer = PngEncoder._u32be(adler32);
        
        // Concatenate all parts
        let totalLength = header.length + trailer.length;
        for (const block of blocks) {
            totalLength += block.length;
        }
        
        const result = new Uint8Array(totalLength);
        let resultOffset = 0;
        
        result.set(header, resultOffset);
        resultOffset += header.length;
        
        for (const block of blocks) {
            result.set(block, resultOffset);
            resultOffset += block.length;
        }
        
        result.set(trailer, resultOffset);
        
        return result;
    }
    
    /**
     * Create IHDR chunk (image header)
     * @param {number} width - Image width
     * @param {number} height - Image height
     * @returns {Uint8Array} IHDR chunk
     * @private
     */
    static _createIHDRChunk(width, height) {
        const data = new Uint8Array(13);
        
        // Width (4 bytes, big-endian)
        const widthBytes = PngEncoder._u32be(width);
        data.set(widthBytes, 0);
        
        // Height (4 bytes, big-endian)  
        const heightBytes = PngEncoder._u32be(height);
        data.set(heightBytes, 4);
        
        // Bit depth: 8 bits per channel
        data[8] = 8;
        
        // Color type: 6 = RGBA (RGB + alpha)
        data[9] = 6;
        
        // Compression method: 0 = DEFLATE
        data[10] = 0;
        
        // Filter method: 0 = basic 5-filter set
        data[11] = 0;
        
        // Interlace method: 0 = none
        data[12] = 0;
        
        return PngEncoder._createChunk('IHDR', data);
    }
    
    /**
     * Create IDAT chunk (image data)  
     * @param {Uint8Array} zlibData - Zlib-compressed image data
     * @returns {Uint8Array} IDAT chunk
     * @private
     */
    static _createIDATChunk(zlibData) {
        return PngEncoder._createChunk('IDAT', zlibData);
    }
    
    /**
     * Create IEND chunk (end marker)
     * @returns {Uint8Array} IEND chunk
     * @private
     */
    static _createIENDChunk() {
        return PngEncoder._createChunk('IEND', new Uint8Array(0));
    }
    
    /**
     * Create a PNG chunk with length, type, data, and CRC
     * @param {string} type - 4-character chunk type
     * @param {Uint8Array} data - Chunk data
     * @returns {Uint8Array} Complete chunk
     * @private
     */
    static _createChunk(type, data) {
        if (type.length !== 4) {
            throw new Error('Chunk type must be exactly 4 characters');
        }
        
        const typeBytes = new TextEncoder().encode(type);
        const length = data.length;
        const lengthBytes = PngEncoder._u32be(length);
        
        // Calculate CRC over type + data
        const crcInput = new Uint8Array(typeBytes.length + data.length);
        crcInput.set(typeBytes, 0);
        crcInput.set(data, typeBytes.length);
        const crc = PngEncoder._calculateCRC32(crcInput);
        const crcBytes = PngEncoder._u32be(crc);
        
        // Assemble chunk: length + type + data + crc
        const chunk = new Uint8Array(4 + 4 + length + 4);
        let offset = 0;
        
        chunk.set(lengthBytes, offset);
        offset += lengthBytes.length;
        chunk.set(typeBytes, offset);
        offset += typeBytes.length;
        chunk.set(data, offset);
        offset += data.length;
        chunk.set(crcBytes, offset);
        
        return chunk;
    }
    
    /**
     * Convert 32-bit unsigned integer to big-endian bytes
     * @param {number} value - Value to convert
     * @returns {Uint8Array} 4-byte big-endian representation
     * @private
     */
    static _u32be(value) {
        const bytes = new Uint8Array(4);
        bytes[0] = (value >>> 24) & 0xFF;
        bytes[1] = (value >>> 16) & 0xFF;
        bytes[2] = (value >>> 8) & 0xFF;
        bytes[3] = value & 0xFF;
        return bytes;
    }
    
    /**
     * Calculate CRC-32 checksum
     * @param {Uint8Array} data - Data to checksum
     * @returns {number} CRC-32 value
     * @private
     */
    static _calculateCRC32(data) {
        let crc = 0xFFFFFFFF;
        
        for (let i = 0; i < data.length; i++) {
            crc ^= data[i];
            
            for (let j = 0; j < 8; j++) {
                crc = (crc >>> 1) ^ (0xEDB88320 & -(crc & 1));
            }
        }
        
        return (crc ^ 0xFFFFFFFF) >>> 0;
    }
    
    /**
     * Calculate Adler-32 checksum
     * @param {Uint8Array} data - Data to checksum
     * @returns {number} Adler-32 value  
     * @private
     */
    static _calculateAdler32(data) {
        let s1 = 1;
        let s2 = 0;
        const MOD_ADLER = 65521;
        
        for (let i = 0; i < data.length; i++) {
            s1 = (s1 + data[i]) % MOD_ADLER;
            s2 = (s2 + s1) % MOD_ADLER;
        }
        
        return ((s2 << 16) | s1) >>> 0;
    }
    
    /**
     * Get PNG file information without encoding (for debugging/info)
     * @param {Surface} surface - Surface to analyze
     * @returns {Object} PNG file information
     */
    static getPNGInfo(surface) {
        if (!surface || !surface.width || !surface.height) {
            throw new Error('Invalid surface');
        }
        
        const scanlineBytes = (surface.width * 4 + 1) * surface.height; // +1 for filter bytes
        const approximateFileSize = scanlineBytes + 200; // PNG headers + zlib overhead
        
        return {
            width: surface.width,
            height: surface.height,
            colorType: 'RGBA (6)',
            bitDepth: 8,
            compression: 'DEFLATE (stored blocks)',
            filter: 'None (0)',
            interlace: 'None (0)',
            approximateFileSize: approximateFileSize,
            scanlineBytes: scanlineBytes
        };
    }
    
    /**
     * Validate that a surface can be encoded to PNG
     * @param {Surface} surface - Surface to validate
     * @returns {boolean} True if surface can be encoded
     */
    static canEncode(surface) {
        try {
            if (!surface || typeof surface !== 'object') return false;
            if (!surface.width || !surface.height || !surface.data) return false;
            if (surface.width <= 0 || surface.height <= 0) return false;
            if (surface.width > PngEncoder.MAX_DIMENSION || 
                surface.height > PngEncoder.MAX_DIMENSION) return false;
                
            const expectedSize = surface.width * surface.height * 4;
            return surface.data.length === expectedSize;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Calculate memory usage for PNG encoding
     * @param {number} width - Image width
     * @param {number} height - Image height  
     * @returns {number} Approximate memory usage in bytes
     */
    static calculateMemoryUsage(width, height) {
        if (width <= 0 || height <= 0) return 0;
        
        // Scanlines + PNG overhead
        return (width * height * 4) + (height * 1) + 200;
    }
}

// Class constants
PngEncoder.MAX_DIMENSION = 65535; // PNG supports up to 2^31-1, but this is reasonable limit

// ============================================================================
// LIBRARY RUNTIME BUNDLE
// ============================================================================

require('../../../dist/bitmaptext-node.min.js');

// ============================================================================
// NODE.JS BUILT-IN MODULES
// ============================================================================

const fs = require('fs');
const path = require('path');

// ============================================================================
// TEST DATA
// ============================================================================
/**
 * Shared test data for performance benchmarking
 * Multi-line text blocks for realistic rendering scenarios
 */

// 5-line pangram block for testing
const TEST_BLOCK_5_LINES = [
  "The quick brown fox jumps over the lazy dog",
  "Pack my box with five dozen liquor jugs",
  "How vexingly quick daft zebras jump",
  "Sphinx of black quartz, judge my vow",
  "Two driven jocks help fax my big quiz"
];

// 10-line extended test block
const TEST_BLOCK_10_LINES = [
  "The quick brown fox jumps over the lazy dog",
  "Pack my box with five dozen liquor jugs",
  "How vexingly quick daft zebras jump",
  "Sphinx of black quartz, judge my vow",
  "Two driven jocks help fax my big quiz",
  "Amazingly few discotheques provide jukeboxes",
  "The five boxing wizards jump quickly",
  "Jackdaws love my big sphinx of quartz",
  "Bright vixens jump; dozy fowl quack",
  "Quick zephyrs blow, vexing daft Jim"
];

// Single long line for stress testing
const TEST_LONG_LINE = "The quick brown fox jumps over the lazy dog. Pack my box with five dozen liquor jugs. How vexingly quick daft zebras jump. Sphinx of black quartz, judge my vow. Two driven jocks help fax my big quiz. The five boxing wizards jump quickly.";

// Export for both browser and Node.js environments
if (typeof module !== 'undefined' && module.exports) {
  // Node.js
  module.exports = {
    TEST_BLOCK_5_LINES,
    TEST_BLOCK_10_LINES,
    TEST_LONG_LINE
  };
}
// Browser globals will be available via script tag

// ============================================================================
// BENCHMARK LOGIC
// ============================================================================


// Node.js built-in modules

// LIBRARY RUNTIME BUNDLE (Production)

// Import BitmapText runtime bundle (contains all rendering classes)

// TEST DATA

// Test data will be concatenated from test-data.js

// BENCHMARK LOGIC

/**
 * Measure execution time with adaptive iteration count
 */
function measureTime(fn, minDuration = 100) {
  let iterations = 1;
  let duration = 0;

  // Find appropriate iteration count
  while (duration < minDuration && iterations < 10000) {
    const start = performance.now();
    for (let i = 0; i < iterations; i++) {
      fn();
    }
    duration = performance.now() - start;

    if (duration < minDuration) {
      iterations *= 10;
    }
  }

  // Perform final measurement
  const start = performance.now();
  for (let i = 0; i < iterations; i++) {
    fn();
  }
  const totalTime = performance.now() - start;
  const avgTime = totalTime / iterations;

  return {
    iterations,
    totalTime,
    avgTime,
    opsPerSecond: 1000 / avgTime
  };
}

/**
 * Test BitmapText rendering
 */
function testBitmapText(blockCount, textColor) {
  return () => {
    const canvas = new Canvas();
    canvas.width = 1200;
    canvas.height = 800;
    const ctx = canvas.getContext('2d');

    // Clear canvas
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Create properties
    const fontProperties = new FontProperties(1, 'Arial', 'normal', 'normal', 19);
    const textProperties = new TextProperties({
      textColor: textColor,
      textBaseline: 'top',
      textAlign: 'left',
      kerning: true
    });

    // Render blocks
    let yOffset = 10;
    const lineHeight = 25;
    const blockHeight = TEST_BLOCK_5_LINES.length * lineHeight;

    for (let i = 0; i < blockCount; i++) {
      TEST_BLOCK_5_LINES.forEach((line, lineIndex) => {
        const y = yOffset + (lineIndex * lineHeight);
        BitmapText.drawTextFromAtlas(ctx, line, 10, y, fontProperties, textProperties);
      });

      yOffset += blockHeight + 10;

      if (yOffset > canvas.height - blockHeight) {
        yOffset = 10;
      }
    }
  };
}

// Main Benchmark Function

async function main() {
  console.log('üöÄ BitmapText.js Performance Benchmark (BUNDLED)');
  console.log(`Platform: ${process.platform}`);
  console.log(`Node version: ${process.version}`);
  console.log(`Architecture: ${process.arch}`);
  console.log('');

  // Configure BitmapText
  // path module already imported at top of file
  // When built, this file is in perf/node/dist/, so go up 3 levels to project root
  const fontDirectory = path.resolve(__dirname, '../../../font-assets/');

  BitmapText.configure({
    fontDirectory: fontDirectory,
    canvasFactory: () => new Canvas()
  });

  // Create font properties
  const fontProperties = new FontProperties(1, 'Arial', 'normal', 'normal', 19);

  // Load font
  console.log('‚è≥ Loading font...');
  const loadStart = performance.now();
  await BitmapText.loadFont(fontProperties.idString);
  const loadTime = performance.now() - loadStart;
  console.log(`‚úÖ Font loaded in ${loadTime.toFixed(2)}ms`);
  console.log('');

  const results = {
    version: 'bundled',
    platform: {
      os: process.platform,
      nodeVersion: process.version,
      arch: process.arch
    },
    timestamp: new Date().toISOString(),
    fontLoading: {
      loadTime,
      fontId: fontProperties.idString
    },
    tests: []
  };

  // Test cases
  const testCases = [
    { name: 'Single block (black)', color: '#000000', blockCount: 1 },
    { name: 'Single block (colored)', color: '#0000FF', blockCount: 1 },
    { name: '10 blocks (black)', color: '#000000', blockCount: 10 },
    { name: '10 blocks (colored)', color: '#0000FF', blockCount: 10 },
    { name: '50 blocks (black)', color: '#000000', blockCount: 50 },
    { name: '50 blocks (colored)', color: '#0000FF', blockCount: 50 }
  ];

  for (const testCase of testCases) {
    console.log(`üìä Testing: ${testCase.name}`);

    const result = measureTime(
      testBitmapText(testCase.blockCount, testCase.color),
      100 // minimum 100ms test duration
    );

    console.log(`   Iterations: ${result.iterations}`);
    console.log(`   Average time: ${result.avgTime.toFixed(3)}ms`);
    console.log(`   Operations/sec: ${result.opsPerSecond.toFixed(0)}`);
    console.log('');

    results.tests.push({
      name: testCase.name,
      color: testCase.color,
      blockCount: testCase.blockCount,
      ...result
    });
  }

  // Output JSON to stdout
  console.log('JSON_RESULTS_START');
  console.log(JSON.stringify(results, null, 2));
  console.log('JSON_RESULTS_END');

  console.log('‚úÖ Benchmark complete');
}

// Run main function
main().catch(error => {
  console.error('‚ùå Benchmark error:', error);
  process.exit(1);
});
