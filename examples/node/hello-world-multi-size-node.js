#!/usr/bin/env node

/**
 * BitmapText.js Node.js Multi-Size Demo
 * 
 * Renders "Hello World" at three font sizes (18, 18.5, 19) using bitmap fonts,
 * loads QOI glyph sheets (with fallback to placeholder rectangles), and exports
 * as uncompressed PNG. Single file with all dependencies.
 * 
 * This demonstrates:
 * - Multi-size font loading and rendering
 * - Graceful handling of missing glyph sheets (placeholder rectangles)
 * - Loading from both main directory and removed-for-testing directory
 * 
 * Usage:
 *   node examples/node/hello-world-multi-size-node.js
 * 
 * Output:
 *   hello-world-multi-size-output.png (in current directory)
 * 
 * This file is automatically generated by scripts/build-node-multi-size-demo.sh
 * Do not edit directly - edit source files instead and rebuild.
 */

// ============================================================================
// MINIMAL CANVAS MOCK - Only what BitmapText.js needs
// ============================================================================


class Canvas {
  constructor() {
    this._width = 0;
    this._height = 0;
    this.data = null;
  }
  
  get width() { return this._width; }
  set width(w) {
    this._width = w;
    this._updateBuffer();
  }
  
  get height() { return this._height; }
  set height(h) {
    this._height = h;
    this._updateBuffer();
  }
  
  _updateBuffer() {
    if (this._width > 0 && this._height > 0) {
      this.data = new Uint8ClampedArray(this._width * this._height * 4);
    }
  }
  
  getContext(type) {
    if (type === '2d') {
      return new Context2D(this);
    }
    return null;
  }
}

class Context2D {
  constructor(canvas) {
    this.canvas = canvas;
    this.fillStyle = '#000000';
    this.globalCompositeOperation = 'source-over';
  }
  
  clearRect(x, y, w, h) {
    if (!this.canvas.data) return;
    
    const data = this.canvas.data;
    const canvasWidth = this.canvas.width;
    
    for (let py = Math.max(0, y); py < Math.min(this.canvas.height, y + h); py++) {
      for (let px = Math.max(0, x); px < Math.min(canvasWidth, x + w); px++) {
        const i = (py * canvasWidth + px) * 4;
        data[i] = data[i+1] = data[i+2] = data[i+3] = 0;
      }
    }
  }
  
  fillRect(x, y, w, h) {
    if (!this.canvas.data) return;
    
    const data = this.canvas.data;
    const canvasWidth = this.canvas.width;
    const [r, g, b] = this._parseColor(this.fillStyle);
    
    for (let py = Math.max(0, y); py < Math.min(this.canvas.height, y + h); py++) {
      for (let px = Math.max(0, x); px < Math.min(canvasWidth, x + w); px++) {
        const i = (py * canvasWidth + px) * 4;
        
        if (this.globalCompositeOperation === 'source-in') {
          // Only fill where alpha > 0 (preserve alpha, change color)
          if (data[i+3] > 0) {
            data[i] = r;
            data[i+1] = g;
            data[i+2] = b;
            // Keep existing alpha value
          }
        } else {
          // source-over: normal fill
          data[i] = r;
          data[i+1] = g;
          data[i+2] = b;
          data[i+3] = 255;
        }
      }
    }
  }
  
  drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh) {
    if (!this.canvas.data || !image.data) return;
    
    // Handle different call signatures
    if (arguments.length === 5) {
      // drawImage(image, dx, dy, dw, dh) - scale to fit
      dw = sx; dh = sy; dx = sw; dy = sh;
      sx = 0; sy = 0; sw = image.width; sh = image.height;
    } else if (arguments.length === 3) {
      // drawImage(image, dx, dy) - no scaling
      dx = sx; dy = sy;
      sx = 0; sy = 0; sw = image.width; sh = image.height;
      dw = sw; dh = sh;
    }
    
    const destData = this.canvas.data;
    const srcData = image.data;
    const destWidth = this.canvas.width;
    const srcWidth = image.width;
    
    // Simple nearest-neighbor sampling
    for (let y = 0; y < dh; y++) {
      for (let x = 0; x < dw; x++) {
        const srcX = Math.floor(sx + (x * sw / dw));
        const srcY = Math.floor(sy + (y * sh / dh));
        const destX = dx + x;
        const destY = dy + y;
        
        if (srcX >= 0 && srcX < image.width && srcY >= 0 && srcY < image.height &&
            destX >= 0 && destX < this.canvas.width && destY >= 0 && destY < this.canvas.height) {
          
          const srcI = (srcY * srcWidth + srcX) * 4;
          const destI = (destY * destWidth + destX) * 4;
          
          if (srcData[srcI + 3] > 0) {  // Only copy non-transparent pixels
            destData[destI] = srcData[srcI];     // R
            destData[destI + 1] = srcData[srcI + 1]; // G
            destData[destI + 2] = srcData[srcI + 2]; // B
            destData[destI + 3] = srcData[srcI + 3]; // A
          }
        }
      }
    }
  }
  
  _parseColor(color) {
    if (color === 'white') return [255, 255, 255];
    if (color === 'black' || color === '#000000') return [0, 0, 0];
    
    // Simple hex parsing
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      if (hex.length === 6) {
        return [
          parseInt(hex.slice(0, 2), 16),
          parseInt(hex.slice(2, 4), 16),
          parseInt(hex.slice(4, 6), 16)
        ];
      }
    }
    
    return [0, 0, 0]; // Default to black
  }
}

// Simple Image class for holding decoded data
class Image {
  constructor(width, height, data) {
    this.width = width;
    this.height = height;
    this.data = data;
  }
}
// ============================================================================
// UTILITY FUNCTIONS - nested-properties.js
// ============================================================================

function checkNestedPropertiesExist(obj, properties) {
    let current = obj;
    for (let prop of properties) {
        if (current[prop] === undefined) {
            return false;
        }
        current = current[prop];
    }
    return true;
}

function setNestedProperty(obj, properties, value) {
    let current = obj;
    for (let i = 0; i < properties.length; i++) {
        const prop = properties[i];
        if (i === properties.length - 1) {
            current[prop] = value;
        }
        else {
            if (!current[prop]) {
                current[prop] = {};
            }
            current = current[prop];
        }
    }
}

function getNestedProperty(obj, properties) {
    let current = obj;
    for (let prop of properties) {
        if (current[prop] === undefined) {
            return null;
        }
        current = current[prop];
    }
    return current;
}

function ensureNestedPropertiesExist(obj, properties) {
    let current = obj;
    for (const element of properties) {
        const prop = element;
        if (current[prop] === undefined) {
            current[prop] = {};
        }
        current = current[prop];
    }
}

// ============================================================================
// EXPANSION UTILITY - MetricsExpander.js
// ============================================================================

// Static utility class for expanding minified font metrics data (runtime only)
// Converts compact format back to full object structures for use by the rendering engine

// Standalone function for backwards compatibility and Node.js support
function decompressFontMetrics(minified) {
  return MetricsExpander.expand(minified);
}

class MetricsExpander {
  // Private constructor - prevent instantiation following Effective Java patterns
  constructor() {
    throw new Error('MetricsExpander cannot be instantiated - use static methods');
  }
  
  /**
   * Expands minified metrics back to full format for runtime use
   * @param {Object} minified - Minified metrics object with shortened keys
   * @returns {Object} Full metrics object with complete property names
   */
  static expand(minified) {
    return {
      kerningTable: this.#expandKerningTable(minified.k),
      glyphsTextMetrics: this.#expandGlyphMetrics(minified.g, minified.b),
      spaceAdvancementOverrideForSmallSizesInPx: minified.s,
      glyphSheetsMetrics: this.#expandTightMetrics(minified.t)
    };
  }
  
  /**
   * Expands kerning table (currently a direct copy, but kept for consistency)
   * @private
   */
  static #expandKerningTable(minified) {
    return { ...minified };
  }
  
  /**
   * Expands glyph metrics from arrays back to full objects
   * Reconstructs full TextMetrics-compatible objects from compact arrays
   * @private
   */
  static #expandGlyphMetrics(minifiedGlyphs, baseMetrics) {
    const expanded = {};
    Object.entries(minifiedGlyphs).forEach(([char, metrics]) => {
      expanded[char] = {
        // Glyph-specific metrics from the array
        width: metrics[0],
        actualBoundingBoxLeft: metrics[1],
        actualBoundingBoxRight: metrics[2],
        actualBoundingBoxAscent: metrics[3],
        actualBoundingBoxDescent: metrics[4],
        
        // Common metrics restored from base metrics
        fontBoundingBoxAscent: baseMetrics.fba,
        fontBoundingBoxDescent: baseMetrics.fbd,
        emHeightAscent: baseMetrics.fba,          // Same as fontBoundingBoxAscent
        emHeightDescent: baseMetrics.fbd,         // Same as fontBoundingBoxDescent
        hangingBaseline: baseMetrics.hb,
        alphabeticBaseline: baseMetrics.ab,
        ideographicBaseline: baseMetrics.ib
      };
    });
    return expanded;
  }
  
  /**
   * Expands tight metrics from shortened property names
   * @private
   */
  static #expandTightMetrics(minified) {
    return {
      tightWidth: minified.w,           // w -> tightWidth
      tightHeight: minified.h,          // h -> tightHeight
      dx: minified.dx,                  // dx unchanged
      dy: minified.dy,                  // dy unchanged
      xInGlyphSheet: minified.x         // x -> xInGlyphSheet
    };
  }
}
// ============================================================================
// QOI DECODER LIBRARY
// ============================================================================

/**
 * Decode a QOI file given as an ArrayBuffer.
 *
 * @param {ArrayBuffer} arrayBuffer ArrayBuffer containing the QOI file.
 * @param {int|null} [byteOffset] Offset to the start of the QOI file in arrayBuffer
 * @param {int|null} [byteLength] Length of the QOI file in bytes
 * @param {int|null} [outputChannels] Number of channels to include in the decoded array
 *
 * @returns {{channels: number, data: Uint8Array, colorspace: number, width: number, error: boolean, height: number}}
 */
function QOIDecode (arrayBuffer, byteOffset, byteLength, outputChannels) {
    if (typeof byteOffset === 'undefined' || byteOffset === null) {
        byteOffset = 0;
    }

    if (typeof byteLength === 'undefined' || byteLength === null) {
        byteLength = arrayBuffer.byteLength - byteOffset;
    }

    const uint8 = new Uint8Array(arrayBuffer, byteOffset, byteLength);

    const magic1 = uint8[0];
    const magic2 = uint8[1];
    const magic3 = uint8[2];
    const magic4 = uint8[3];

    const width = ((uint8[4] << 24) | (uint8[5] << 16) | (uint8[6] << 8) | uint8[7]) >>> 0;
    const height = ((uint8[8] << 24) | (uint8[9] << 16) | (uint8[10] << 8) | uint8[11]) >>> 0;

    const channels = uint8[12];
    const colorspace = uint8[13];

    if (typeof outputChannels === 'undefined' || outputChannels === null) {
        outputChannels = channels;
    }

    if (magic1 !== 0x71 || magic2 !== 0x6F || magic3 !== 0x69 || magic4 !== 0x66) {
        throw new Error('QOI.decode: The signature of the QOI file is invalid');
    }

    if (channels < 3 || channels > 4) {
        throw new Error('QOI.decode: The number of channels declared in the file is invalid');
    }

    if (colorspace > 1) {
        throw new Error('QOI.decode: The colorspace declared in the file is invalid');
    }

    if (outputChannels < 3 || outputChannels > 4) {
        throw new Error('QOI.decode: The number of channels for the output is invalid');
    }

    const pixelLength = width * height * outputChannels;
    const result = new Uint8Array(pixelLength);

    let arrayPosition = 14;

    const index = new Uint8Array(64 * 4);
    let indexPosition = 0;

    let red = 0;
    let green = 0;
    let blue = 0;
    let alpha = 255;

    const chunksLength = byteLength - 8;

    let run = 0;
    let pixelPosition = 0;

    for (; pixelPosition < pixelLength && arrayPosition < byteLength - 4; pixelPosition += outputChannels) {
        if (run > 0) {
            run--;
        } else if (arrayPosition < chunksLength) {
            const byte1 = uint8[arrayPosition++];

            if (byte1 === 0b11111110) { // QOI_OP_RGB
                red = uint8[arrayPosition++];
                green = uint8[arrayPosition++];
                blue = uint8[arrayPosition++];
            } else if (byte1 === 0b11111111) { // QOI_OP_RGBA
                red = uint8[arrayPosition++];
                green = uint8[arrayPosition++];
                blue = uint8[arrayPosition++];
                alpha = uint8[arrayPosition++];
            } else if ((byte1 & 0b11000000) === 0b00000000) { // QOI_OP_INDEX
                red = index[byte1 * 4];
                green = index[byte1 * 4 + 1];
                blue = index[byte1 * 4 + 2];
                alpha = index[byte1 * 4 + 3];
            } else if ((byte1 & 0b11000000) === 0b01000000) { // QOI_OP_DIFF
                red += ((byte1 >> 4) & 0b00000011) - 2;
                green += ((byte1 >> 2) & 0b00000011) - 2;
                blue += (byte1 & 0b00000011) - 2;

                // handle wraparound
                red = (red + 256) % 256;
                green = (green + 256) % 256;
                blue = (blue + 256) % 256;
            } else if ((byte1 & 0b11000000) === 0b10000000) { // QOI_OP_LUMA
                const byte2 = uint8[arrayPosition++];
                const greenDiff = (byte1 & 0b00111111) - 32;
                const redDiff = greenDiff + ((byte2 >> 4) & 0b00001111) - 8;
                const blueDiff = greenDiff + (byte2 & 0b00001111) - 8;

                // handle wraparound
                red = (red + redDiff + 256) % 256;
                green = (green + greenDiff + 256) % 256;
                blue = (blue + blueDiff + 256) % 256;
            } else if ((byte1 & 0b11000000) === 0b11000000) { // QOI_OP_RUN
                run = byte1 & 0b00111111;
            }

            indexPosition = ((red * 3 + green * 5 + blue * 7 + alpha * 11) % 64) * 4;
            index[indexPosition] = red;
            index[indexPosition + 1] = green;
            index[indexPosition + 2] = blue;
            index[indexPosition + 3] = alpha;
        }

        if (outputChannels === 4) { // RGBA
            result[pixelPosition] = red;
            result[pixelPosition + 1] = green;
            result[pixelPosition + 2] = blue;
            result[pixelPosition + 3] = alpha;
        } else { // RGB
            result[pixelPosition] = red;
            result[pixelPosition + 1] = green;
            result[pixelPosition + 2] = blue;
        }
    }

    if (pixelPosition < pixelLength) {
        throw new Error('QOI.decode: Incomplete image');
    }

    // checking the 00000001 padding is not required, as per specs

    return {
        width: width,
        height: height,
        colorspace: colorspace,
        channels: outputChannels,
        data: result
    };
}
// ============================================================================
// PNG ENCODING OPTIONS
// ============================================================================

/**
 * PngEncodingOptions class for SWCanvas PngEncoder
 * 
 * Provides configuration options for PNG encoding operations.
 * Follows immutable object-oriented design principles per Joshua Bloch's Effective Java.
 * 
 * Key Features:
 * - Immutable options objects prevent accidental modification
 * - Static factory methods provide clear API
 * - Extensible design allows for future encoding options
 * - Type-safe configuration prevents parameter confusion
 * - Simpler than BitmapEncodingOptions since PNG supports transparency natively
 */
class PngEncodingOptions {
    /**
     * Create PngEncodingOptions instance
     * @param {Object} config - Configuration object
     * @param {boolean} config.preserveTransparency - Whether to preserve transparency (default: true)
     * @param {number} config.compressionLevel - Future placeholder for compression (0 = none, currently unused)
     */
    constructor(config = {}) {
        // Set defaults
        const {
            preserveTransparency = true,
            compressionLevel = 0  // 0 = no compression (stored blocks)
        } = config;
        
        // Validate parameters
        if (typeof preserveTransparency !== 'boolean') {
            throw new Error('preserveTransparency must be a boolean');
        }
        
        if (typeof compressionLevel !== 'number' || compressionLevel < 0 || compressionLevel > 9) {
            throw new Error('compressionLevel must be a number between 0-9');
        }
        
        // Currently only support compression level 0 (stored blocks)
        if (compressionLevel !== 0) {
            throw new Error('Only compression level 0 (no compression) is currently supported');
        }
        
        // Store immutable configuration
        this._config = Object.freeze({
            preserveTransparency,
            compressionLevel
        });
        
        // Make this instance immutable
        Object.freeze(this);
    }
    
    /**
     * Get whether transparency should be preserved
     * @returns {boolean} True if transparency is preserved
     */
    get preserveTransparency() {
        return this._config.preserveTransparency;
    }
    
    /**
     * Get compression level
     * @returns {number} Compression level (0-9, currently only 0 supported)
     */
    get compressionLevel() {
        return this._config.compressionLevel;
    }
    
    /**
     * Create default options (transparency preserved, no compression)
     * @returns {PngEncodingOptions} Default options instance
     */
    static withDefaults() {
        return new PngEncodingOptions();
    }
    
    /**
     * Create options with transparency preserved (default behavior)
     * @returns {PngEncodingOptions} Options with transparency preserved
     */
    static withTransparency() {
        return new PngEncodingOptions({ preserveTransparency: true });
    }
    
    /**
     * Create options for opaque images (transparency ignored)
     * Note: This doesn't affect the PNG format (still RGBA), but may be useful for future optimizations
     * @returns {PngEncodingOptions} Options for opaque images
     */
    static withoutTransparency() {
        return new PngEncodingOptions({ preserveTransparency: false });
    }
    
    /**
     * Create options with specific compression level (future extensibility)
     * @param {number} level - Compression level (0-9, currently only 0 supported)
     * @returns {PngEncodingOptions} Options with specified compression level
     */
    static withCompressionLevel(level) {
        return new PngEncodingOptions({ compressionLevel: level });
    }
    
    /**
     * Create options for maximum compatibility (no compression, preserve transparency)
     * @returns {PngEncodingOptions} Maximum compatibility options
     */
    static forMaximumCompatibility() {
        return new PngEncodingOptions({
            preserveTransparency: true,
            compressionLevel: 0
        });
    }
    
    /**
     * Check if two options instances are equal
     * @param {PngEncodingOptions} other - Other options to compare
     * @returns {boolean} True if options are equivalent
     */
    equals(other) {
        if (!(other instanceof PngEncodingOptions)) {
            return false;
        }
        
        const config1 = this._config;
        const config2 = other._config;
        
        return config1.preserveTransparency === config2.preserveTransparency &&
               config1.compressionLevel === config2.compressionLevel;
    }
    
    /**
     * Get string representation for debugging
     * @returns {string} String representation
     */
    toString() {
        const config = this._config;
        return `PngEncodingOptions(transparency: ${config.preserveTransparency}, compression: ${config.compressionLevel})`;
    }
    
    /**
     * Create a new options instance with modified transparency setting
     * @param {boolean} preserveTransparency - Whether to preserve transparency
     * @returns {PngEncodingOptions} New options instance
     */
    withTransparency(preserveTransparency) {
        return new PngEncodingOptions({
            preserveTransparency,
            compressionLevel: this._config.compressionLevel
        });
    }
    
    /**
     * Create a new options instance with modified compression level
     * @param {number} compressionLevel - Compression level (0-9, currently only 0 supported)
     * @returns {PngEncodingOptions} New options instance
     */
    withCompression(compressionLevel) {
        return new PngEncodingOptions({
            preserveTransparency: this._config.preserveTransparency,
            compressionLevel
        });
    }
}

// Default options instance - preserve transparency, no compression (maintains simplicity)
PngEncodingOptions.DEFAULT = new PngEncodingOptions();
// ============================================================================
// PNG ENCODER
// ============================================================================

/**
 * PngEncoder class for SWCanvas
 * 
 * Handles encoding of Surface data to minimal PNG format with transparency support.
 * Uses uncompressed DEFLATE blocks for simplicity while maintaining PNG compliance.
 * Provides static methods for encoding with proper alpha handling.
 * 
 * Following OO best practices:
 * - Static methods for stateless encoding operations
 * - Clear separation of PNG chunk generation and pixel processing
 * - Proper error handling and validation
 * - Support for transparency (unlike BMP format)
 */
class PngEncoder {
    /**
     * Encode a surface to PNG format
     * @param {Surface} surface - Surface to encode  
     * @param {PngEncodingOptions} [options=PngEncodingOptions.DEFAULT] - Encoding options
     * @returns {ArrayBuffer} PNG file data
     */
    static encode(surface, options = PngEncodingOptions.DEFAULT) {
        if (!surface || typeof surface !== 'object') {
            throw new Error('Surface must be a valid Surface object');
        }
        
        if (!surface.width || !surface.height || !surface.data) {
            throw new Error('Surface must have width, height, and data properties');
        }
        
        const width = surface.width;
        const height = surface.height;
        const data = surface.data;
        
        // Validate surface data
        const expectedSize = width * height * 4;
        if (data.length !== expectedSize) {
            throw new Error(`Surface data size mismatch. Expected ${expectedSize}, got ${data.length}`);
        }
        
        // Validate dimensions
        if (width <= 0 || height <= 0) {
            throw new Error('Surface dimensions must be positive');
        }
        
        if (width > PngEncoder.MAX_DIMENSION || height > PngEncoder.MAX_DIMENSION) {
            throw new Error(`Surface dimensions must be â‰¤ ${PngEncoder.MAX_DIMENSION}x${PngEncoder.MAX_DIMENSION}`);
        }
        
        // Create scanlines with filter bytes (filter 0 = None)
        const scanlines = PngEncoder._createScanlines(width, height, data);
        
        // Create compressed data using stored DEFLATE blocks
        const zlibData = PngEncoder._createZlibData(scanlines);
        
        // Build PNG chunks
        const signature = PngEncoder._createSignature();
        const ihdrChunk = PngEncoder._createIHDRChunk(width, height);
        const idatChunk = PngEncoder._createIDATChunk(zlibData);
        const iendChunk = PngEncoder._createIENDChunk();
        
        // Concatenate all parts
        const totalLength = signature.length + ihdrChunk.length + idatChunk.length + iendChunk.length;
        const result = new Uint8Array(totalLength);
        
        let offset = 0;
        result.set(signature, offset);
        offset += signature.length;
        result.set(ihdrChunk, offset);
        offset += ihdrChunk.length;
        result.set(idatChunk, offset);
        offset += idatChunk.length;
        result.set(iendChunk, offset);
        
        return result.buffer;
    }
    
    /**
     * Create PNG signature (8 bytes)
     * @returns {Uint8Array} PNG signature
     * @private
     */
    static _createSignature() {
        return new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]);
    }
    
    /**
     * Create scanlines with filter bytes
     * @param {number} width - Image width
     * @param {number} height - Image height  
     * @param {Uint8ClampedArray} data - RGBA pixel data (non-premultiplied)
     * @returns {Uint8Array} Scanlines with filter bytes
     * @private
     */
    static _createScanlines(width, height, data) {
        const bytesPerPixel = 4; // RGBA
        const stride = width * bytesPerPixel;
        const scanlineLength = stride + 1; // +1 for filter byte
        const result = new Uint8Array(scanlineLength * height);
        
        let srcOffset = 0;
        let destOffset = 0;
        
        for (let y = 0; y < height; y++) {
            // Filter type 0 (None)
            result[destOffset++] = 0;
            
            // Copy scanline (RGBA order, already non-premultiplied)
            for (let x = 0; x < width; x++) {
                result[destOffset++] = data[srcOffset++]; // R
                result[destOffset++] = data[srcOffset++]; // G  
                result[destOffset++] = data[srcOffset++]; // B
                result[destOffset++] = data[srcOffset++]; // A
            }
        }
        
        return result;
    }
    
    /**
     * Create zlib data with stored DEFLATE blocks
     * @param {Uint8Array} uncompressed - Uncompressed scanline data
     * @returns {Uint8Array} Zlib-wrapped data
     * @private
     */
    static _createZlibData(uncompressed) {
        // Zlib header (CMF=0x78, FLG=0x01 for stored blocks)
        const header = new Uint8Array([0x78, 0x01]);
        
        // Split into DEFLATE stored blocks (max 65535 bytes per block)
        const blocks = [];
        const maxBlockSize = 65535;
        let offset = 0;
        
        while (offset < uncompressed.length) {
            const remaining = uncompressed.length - offset;
            const blockSize = Math.min(maxBlockSize, remaining);
            const isLastBlock = (offset + blockSize === uncompressed.length);
            
            // Block header: BFINAL (1 bit) + BTYPE (2 bits, 00 = stored)
            const bfinal = isLastBlock ? 1 : 0;
            const blockHeader = new Uint8Array(5);
            blockHeader[0] = bfinal; // BFINAL=1 if last, BTYPE=00
            
            // LEN (little-endian)
            blockHeader[1] = blockSize & 0xFF;
            blockHeader[2] = (blockSize >>> 8) & 0xFF;
            
            // NLEN (bitwise NOT of LEN, little-endian)
            const nlen = (~blockSize) & 0xFFFF;
            blockHeader[3] = nlen & 0xFF;
            blockHeader[4] = (nlen >>> 8) & 0xFF;
            
            blocks.push(blockHeader);
            blocks.push(uncompressed.subarray(offset, offset + blockSize));
            
            offset += blockSize;
        }
        
        // Calculate Adler-32 checksum
        const adler32 = PngEncoder._calculateAdler32(uncompressed);
        const trailer = PngEncoder._u32be(adler32);
        
        // Concatenate all parts
        let totalLength = header.length + trailer.length;
        for (const block of blocks) {
            totalLength += block.length;
        }
        
        const result = new Uint8Array(totalLength);
        let resultOffset = 0;
        
        result.set(header, resultOffset);
        resultOffset += header.length;
        
        for (const block of blocks) {
            result.set(block, resultOffset);
            resultOffset += block.length;
        }
        
        result.set(trailer, resultOffset);
        
        return result;
    }
    
    /**
     * Create IHDR chunk (image header)
     * @param {number} width - Image width
     * @param {number} height - Image height
     * @returns {Uint8Array} IHDR chunk
     * @private
     */
    static _createIHDRChunk(width, height) {
        const data = new Uint8Array(13);
        
        // Width (4 bytes, big-endian)
        const widthBytes = PngEncoder._u32be(width);
        data.set(widthBytes, 0);
        
        // Height (4 bytes, big-endian)  
        const heightBytes = PngEncoder._u32be(height);
        data.set(heightBytes, 4);
        
        // Bit depth: 8 bits per channel
        data[8] = 8;
        
        // Color type: 6 = RGBA (RGB + alpha)
        data[9] = 6;
        
        // Compression method: 0 = DEFLATE
        data[10] = 0;
        
        // Filter method: 0 = basic 5-filter set
        data[11] = 0;
        
        // Interlace method: 0 = none
        data[12] = 0;
        
        return PngEncoder._createChunk('IHDR', data);
    }
    
    /**
     * Create IDAT chunk (image data)  
     * @param {Uint8Array} zlibData - Zlib-compressed image data
     * @returns {Uint8Array} IDAT chunk
     * @private
     */
    static _createIDATChunk(zlibData) {
        return PngEncoder._createChunk('IDAT', zlibData);
    }
    
    /**
     * Create IEND chunk (end marker)
     * @returns {Uint8Array} IEND chunk
     * @private
     */
    static _createIENDChunk() {
        return PngEncoder._createChunk('IEND', new Uint8Array(0));
    }
    
    /**
     * Create a PNG chunk with length, type, data, and CRC
     * @param {string} type - 4-character chunk type
     * @param {Uint8Array} data - Chunk data
     * @returns {Uint8Array} Complete chunk
     * @private
     */
    static _createChunk(type, data) {
        if (type.length !== 4) {
            throw new Error('Chunk type must be exactly 4 characters');
        }
        
        const typeBytes = new TextEncoder().encode(type);
        const length = data.length;
        const lengthBytes = PngEncoder._u32be(length);
        
        // Calculate CRC over type + data
        const crcInput = new Uint8Array(typeBytes.length + data.length);
        crcInput.set(typeBytes, 0);
        crcInput.set(data, typeBytes.length);
        const crc = PngEncoder._calculateCRC32(crcInput);
        const crcBytes = PngEncoder._u32be(crc);
        
        // Assemble chunk: length + type + data + crc
        const chunk = new Uint8Array(4 + 4 + length + 4);
        let offset = 0;
        
        chunk.set(lengthBytes, offset);
        offset += lengthBytes.length;
        chunk.set(typeBytes, offset);
        offset += typeBytes.length;
        chunk.set(data, offset);
        offset += data.length;
        chunk.set(crcBytes, offset);
        
        return chunk;
    }
    
    /**
     * Convert 32-bit unsigned integer to big-endian bytes
     * @param {number} value - Value to convert
     * @returns {Uint8Array} 4-byte big-endian representation
     * @private
     */
    static _u32be(value) {
        const bytes = new Uint8Array(4);
        bytes[0] = (value >>> 24) & 0xFF;
        bytes[1] = (value >>> 16) & 0xFF;
        bytes[2] = (value >>> 8) & 0xFF;
        bytes[3] = value & 0xFF;
        return bytes;
    }
    
    /**
     * Calculate CRC-32 checksum
     * @param {Uint8Array} data - Data to checksum
     * @returns {number} CRC-32 value
     * @private
     */
    static _calculateCRC32(data) {
        let crc = 0xFFFFFFFF;
        
        for (let i = 0; i < data.length; i++) {
            crc ^= data[i];
            
            for (let j = 0; j < 8; j++) {
                crc = (crc >>> 1) ^ (0xEDB88320 & -(crc & 1));
            }
        }
        
        return (crc ^ 0xFFFFFFFF) >>> 0;
    }
    
    /**
     * Calculate Adler-32 checksum
     * @param {Uint8Array} data - Data to checksum
     * @returns {number} Adler-32 value  
     * @private
     */
    static _calculateAdler32(data) {
        let s1 = 1;
        let s2 = 0;
        const MOD_ADLER = 65521;
        
        for (let i = 0; i < data.length; i++) {
            s1 = (s1 + data[i]) % MOD_ADLER;
            s2 = (s2 + s1) % MOD_ADLER;
        }
        
        return ((s2 << 16) | s1) >>> 0;
    }
    
    /**
     * Get PNG file information without encoding (for debugging/info)
     * @param {Surface} surface - Surface to analyze
     * @returns {Object} PNG file information
     */
    static getPNGInfo(surface) {
        if (!surface || !surface.width || !surface.height) {
            throw new Error('Invalid surface');
        }
        
        const scanlineBytes = (surface.width * 4 + 1) * surface.height; // +1 for filter bytes
        const approximateFileSize = scanlineBytes + 200; // PNG headers + zlib overhead
        
        return {
            width: surface.width,
            height: surface.height,
            colorType: 'RGBA (6)',
            bitDepth: 8,
            compression: 'DEFLATE (stored blocks)',
            filter: 'None (0)',
            interlace: 'None (0)',
            approximateFileSize: approximateFileSize,
            scanlineBytes: scanlineBytes
        };
    }
    
    /**
     * Validate that a surface can be encoded to PNG
     * @param {Surface} surface - Surface to validate
     * @returns {boolean} True if surface can be encoded
     */
    static canEncode(surface) {
        try {
            if (!surface || typeof surface !== 'object') return false;
            if (!surface.width || !surface.height || !surface.data) return false;
            if (surface.width <= 0 || surface.height <= 0) return false;
            if (surface.width > PngEncoder.MAX_DIMENSION || 
                surface.height > PngEncoder.MAX_DIMENSION) return false;
                
            const expectedSize = surface.width * surface.height * 4;
            return surface.data.length === expectedSize;
        } catch (error) {
            return false;
        }
    }
    
    /**
     * Calculate memory usage for PNG encoding
     * @param {number} width - Image width
     * @param {number} height - Image height  
     * @returns {number} Approximate memory usage in bytes
     */
    static calculateMemoryUsage(width, height) {
        if (width <= 0 || height <= 0) return 0;
        
        // Scanlines + PNG overhead
        return (width * height * 4) + (height * 1) + 200;
    }
}

// Class constants
PngEncoder.MAX_DIMENSION = 65535; // PNG supports up to 2^31-1, but this is reasonable limit
// ============================================================================
// BITMAP GLYPH STORE
// ============================================================================

// A class to store all the glyph sheets and kerning tables
// and the minimal set of info necessary to draw text.
class BitmapGlyphStore {
  constructor() {
    // Only use these three "compact" data structures in the measuring and drawing methods
    // "compact" means that they are the final data structures that are used to measure
    // text and draw the glyphs/text. (As opposed to the other data structures that contain
    // all kinds of other intermediate data useful for construction/inspection)

    // These three are needed to measure text and place each glyph one after the other with the correct advancement
    this.kerningTables = {}; // [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize]
    this.glyphsTextMetrics = {}; // [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize, letter]
    this.spaceAdvancementOverrideForSmallSizesInPx = {}; // [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize]

    // These two are needed to precisely paint a glyph from the sheet into the destination canvas
    this.glyphSheets = {}; // [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize]
    this.glyphSheetsMetrics = {
      // All objects indexed on [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize, letter]
      tightWidth: {},
      tightHeight: {},
      dx: {},
      dy: {},
      xInGlyphSheet: {}
    };
  }

  // method that de-structure a fontProperties object
  // into an array [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize]
  getFontPropertiesArray(fontProperties) {
    const {
      pixelDensity,
      fontFamily,
      fontStyle,
      fontWeight,
      fontSize
    } = fontProperties;
    return [pixelDensity, fontFamily, fontStyle, fontWeight, fontSize];
  }

  getKerningTable(fontProperties) {
    return getNestedProperty(this.kerningTables, this.getFontPropertiesArray(fontProperties)) || {};
  }

  setKerningTable(fontProperties, kerningTable) {
    setNestedProperty(this.kerningTables,this.getFontPropertiesArray(fontProperties), kerningTable);
  }
  
  getGlyphSheet(fontProperties) {
    return getNestedProperty(this.glyphSheets,this.getFontPropertiesArray(fontProperties));
  }

  setGlyphSheet(fontProperties, glyphSheet) {
    setNestedProperty(this.glyphSheets,this.getFontPropertiesArray(fontProperties), glyphSheet);
  }

  // return an object with xInGlyphSheet, tightWidth, tightHeight, dx, dy
  getGlyphSheetMetrics(fontProperties, letter) {
    const address = this.getFontPropertiesArray(fontProperties).concat(letter);
    const glyphSheetsMetrics = this.glyphSheetsMetrics;
    return {
      xInGlyphSheet: getNestedProperty(glyphSheetsMetrics.xInGlyphSheet, address),
      tightWidth: getNestedProperty(glyphSheetsMetrics.tightWidth, address),
      tightHeight: getNestedProperty(glyphSheetsMetrics.tightHeight, address),
      dx: getNestedProperty(glyphSheetsMetrics.dx, address),
      dy: getNestedProperty(glyphSheetsMetrics.dy, address)
    };
  }

  setGlyphSheetMetrics(fontProperties, metrics) {
    const glyphSheetsMetrics = this.glyphSheetsMetrics;
    for (const metricKey in metrics) {
      setNestedProperty(glyphSheetsMetrics[metricKey],this.getFontPropertiesArray(fontProperties), metrics[metricKey]);
    }
  }

  getGlyphsTextMetrics(fontProperties, letter) {
    return getNestedProperty(this.glyphsTextMetrics, this.getFontPropertiesArray(fontProperties).concat(letter));
  }

  setGlyphsTextMetrics(fontProperties, metrics) {
    setNestedProperty(this.glyphsTextMetrics,this.getFontPropertiesArray(fontProperties), metrics);
  }

  setGlyphTextMetrics(fontProperties, letter, metrics) {
    setNestedProperty(this.glyphsTextMetrics, this.getFontPropertiesArray(fontProperties).concat(letter), metrics);
  }

  getSpaceAdvancementOverrideForSmallSizesInPx(fontProperties) {
    return getNestedProperty(this.spaceAdvancementOverrideForSmallSizesInPx, this.getFontPropertiesArray(fontProperties));
  }

  setSpaceAdvancementOverrideForSmallSizesInPx(fontProperties, spaceAdvancementOverrideForSmallSizesInPx) {
    setNestedProperty(this.spaceAdvancementOverrideForSmallSizesInPx, this.getFontPropertiesArray(fontProperties), spaceAdvancementOverrideForSmallSizesInPx);
  }

  // Helper method to check if a glyph sheet is valid for rendering
  isValidGlyphSheet(glyphSheet) {
    return glyphSheet && typeof glyphSheet === 'object' && glyphSheet.width > 0;
  }

}

// ============================================================================
// BITMAP TEXT RENDERER
// ============================================================================

// a class constructed with a BitmapGlyphStore
// has a method to draw text on a canvas
// the text is drawn by looking up the glyphs in the BitmapGlyphStore
// and drawing them on the canvas one after the other, advancing the x position by the width of the glyph
// the text is drawn with x, y positioning equivalent to textBaseline='bottom'
// where x is the left edge of the first glyph and y is the bottom of the text bounding box (lowest point any character reaches)
class BitmapText {
  constructor(glyphStore, canvasFactory) {
    this.glyphStore = glyphStore;
    // we keep one canvas and a context for coloring all the glyphs
    if (canvasFactory) {
      this.coloredGlyphCanvas = canvasFactory();
    } else if (typeof document !== 'undefined') {
      this.coloredGlyphCanvas = document.createElement('canvas');
    } else {
      throw new Error('Canvas factory required in Node.js environment');
    }
    this.coloredGlyphCtx = this.coloredGlyphCanvas.getContext('2d');
  }

  // This returns an object of the same shape
  // and meaning as the TextMetrics object (see
  // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics ) i.e.:
  //  * the width should be the sum of the advancements (detracting kerning)
  //  * actualBoundingBoxLeft =
  //      the actualBoundingBoxLeft of the first character
  //  * actualBoundingBoxRight =
  //      the sum of the advancements (detracting kerning) EXCLUDING the one of the last char, plus the actualBoundingBoxRight of the last char
  measureText(text, fontProperties) {
    if (text.length === 0)
      return {
        width: 0,
        actualBoundingBoxLeft: 0,
        actualBoundingBoxRight: 0,
        actualBoundingBoxAscent: 0,
        actualBoundingBoxDescent: 0,
        fontBoundingBoxAscent: 0,
        fontBoundingBoxDescent: 0
      };

    let width_CSS_Px = 0;
    let letterTextMetrics = this.glyphStore.getGlyphsTextMetrics(fontProperties, text[0]);
    const actualBoundingBoxLeft_CSS_Px = letterTextMetrics.actualBoundingBoxLeft;
    let actualBoundingBoxAscent = 0;
    let actualBoundingBoxDescent = 0;
    let actualBoundingBoxRight_CSS_Px;
    let advancement_CSS_Px = 0;

    for (let i = 0; i < text.length; i++) {
      const letter = text[i];
      const nextLetter = text[i + 1];

      letterTextMetrics = this.glyphStore.getGlyphsTextMetrics(fontProperties, letter);

      actualBoundingBoxAscent = Math.max(actualBoundingBoxAscent, letterTextMetrics.actualBoundingBoxAscent);
      actualBoundingBoxDescent = Math.min(actualBoundingBoxDescent, letterTextMetrics.actualBoundingBoxDescent);

      advancement_CSS_Px = this.calculateAdvancement_CSS_Px(fontProperties, letter, nextLetter);
      width_CSS_Px += advancement_CSS_Px;
    }

    // the actualBoundingBoxRight_CSS_Px is the sum of all the advancements (detracting kerning) up to the last character...
    actualBoundingBoxRight_CSS_Px = width_CSS_Px - advancement_CSS_Px;
    // ... plus the actualBoundingBoxRight_CSS_Px of the last character
    // (this is in place of adding its advancement_CSS_Px)
    actualBoundingBoxRight_CSS_Px += letterTextMetrics.actualBoundingBoxRight;

    return {
      width: width_CSS_Px,
      // note that standard measureText returns a TextMetrics object
      // which has no height, so let's make things uniform and resist the temptation to provide it.
      actualBoundingBoxLeft: actualBoundingBoxLeft_CSS_Px,
      actualBoundingBoxRight: actualBoundingBoxRight_CSS_Px,
      actualBoundingBoxAscent,
      actualBoundingBoxDescent,
      fontBoundingBoxAscent: letterTextMetrics.fontBoundingBoxAscent,
      fontBoundingBoxDescent: letterTextMetrics.fontBoundingBoxDescent
    };
  }

  // Get the advancement of the i-th character i.e. needed AFTER the i-th character
  // so that the i+1-th character is drawn at the right place
  // This depends on both the advancement specified by the glyph of the i-th character
  // AND by the kerning correction depending on the pair of the i-th and i+1-th characters
  calculateAdvancement_CSS_Px(fontProperties, letter, nextLetter) {
    const letterTextMetrics = this.glyphStore.getGlyphsTextMetrics(fontProperties, letter);
    let x_CSS_Px = 0;

    // TODO this "space" section should handle all characters without a glyph
    //      as there are many kinds of space-like characters.

    // Handle space first ------------------------------------------
    // You could add the space advancement as we got it from the browser
    // (remember that the space doesn't have the tightCanvasBox)
    // but since at small sizes we meddle with kerning quite a bit, we want
    // to also meddle with this to try to make the width of text
    // similar to what the browser paints normally.
    // console.log(letterTextMetrics.width + " " + x_CSS_Px);
    // deal with the size of the " " character
    if (letter === " ") {
      const spaceAdvancementOverrideForSmallSizesInPx_CSS_Px = this.glyphStore.getSpaceAdvancementOverrideForSmallSizesInPx(fontProperties);
      if (spaceAdvancementOverrideForSmallSizesInPx_CSS_Px !== null) {
        x_CSS_Px += spaceAdvancementOverrideForSmallSizesInPx_CSS_Px;
      }
      else {
        x_CSS_Px += letterTextMetrics.width;
      }
    }
    // Non-space characters ------------------------------------------
    else {
      x_CSS_Px += letterTextMetrics.width;
    }

    // Next, apply the kerning correction ----------------------------
    let kerningCorrection = this.getKerningCorrection(fontProperties, letter, nextLetter);

    // We multiply the advancement of the letter by the kerning
    // Tracking and kerning are both measured in 1/1000 em, a unit of measure that is relative to the current type size.
    // We don't use ems, rather we use pxs, however we still want to keep Kerning as strictly proportional to the current type size,
    // and also to keep it as a measure "in thousands".
    x_CSS_Px -= fontProperties.fontSize * kerningCorrection / 1000;

    // since we might want to actually _place_ a glyph,
    // following this measurement, we want to return an
    // integer coordinate here
    return Math.round(x_CSS_Px);
  }

  getKerningCorrection(fontProperties, letter, nextLetter) {
    const properties = [letter, nextLetter];

    if (isKerningEnabled && nextLetter) {
      let kerningCorrectionPlace = this.glyphStore.getKerningTable(fontProperties);
      if (checkNestedPropertiesExist(kerningCorrectionPlace, properties))
        return getNestedProperty(kerningCorrectionPlace, properties);
    }

    return 0;
  }

  drawTextFromGlyphSheet(ctx, text, x_CSS_Px, y_CSS_Px, fontProperties, textColor = 'black') {
    const position = {
      x: x_CSS_Px * fontProperties.pixelDensity,
      y: y_CSS_Px * fontProperties.pixelDensity
    };
    
    const glyphSheet = this.glyphStore.getGlyphSheet(fontProperties);

    for (let i = 0; i < text.length; i++) {
      const currentLetter = text[i];
      const nextLetter = text[i + 1];
      
      this.drawLetter(ctx,
        currentLetter,
        position,
        glyphSheet,
        fontProperties,
        textColor
      );

      position.x += this.calculateLetterAdvancement(fontProperties, currentLetter, nextLetter);
    }
  }

  drawLetter(ctx, letter, position, glyphSheet, fontProperties, textColor) {
    // There are several optimisations possible here:
    // 1. We could make a special case when the color is black
    // 2. We could cache the colored glyph sheets in a small LRU cache

    const metrics = this.glyphStore.getGlyphSheetMetrics(fontProperties, letter);
    
    // If glyph sheet is missing but metrics exist, draw placeholder rectangle
    if (!this.glyphStore.isValidGlyphSheet(glyphSheet)) {
      // For placeholder rectangles, we need tightWidth and tightHeight, but not xInGlyphSheet
      if (metrics.tightWidth && metrics.tightHeight) {
        this.drawPlaceholderRectangle(ctx, position, metrics, textColor);
      }
      return;
    }
    
    // For normal glyph rendering, we need xInGlyphSheet
    if (!metrics.xInGlyphSheet) return;

    const coloredGlyphCanvas = this.createColoredGlyph(glyphSheet, metrics, textColor);
    this.renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position, metrics);
  }

  createColoredGlyph(glyphSheet, metrics, textColor) {
    const { xInGlyphSheet, tightWidth, tightHeight } = metrics;
    
    // Setup temporary canvas, same size as the glyph
    this.coloredGlyphCanvas.width = tightWidth;
    this.coloredGlyphCanvas.height = tightHeight;
    this.coloredGlyphCtx.clearRect(0, 0, tightWidth, tightHeight);

    // Draw original glyph
    this.coloredGlyphCtx.globalCompositeOperation = 'source-over'; // reset the composite operation
    // see https://stackoverflow.com/a/6061102
    this.coloredGlyphCtx.drawImage(
      glyphSheet,
      xInGlyphSheet, 0,
      tightWidth, tightHeight,
      0, 0,
      tightWidth, tightHeight
    );

    // Apply color
    this.coloredGlyphCtx.globalCompositeOperation = 'source-in';
    this.coloredGlyphCtx.fillStyle = textColor;
    this.coloredGlyphCtx.fillRect(0, 0, tightWidth, tightHeight);

    return this.coloredGlyphCanvas;
  }

  renderGlyphToMainCanvas(ctx, coloredGlyphCanvas, position, metrics) {
    const { tightWidth, tightHeight, dx, dy } = metrics;
    
     // see https://stackoverflow.com/a/6061102
    ctx.drawImage(
      coloredGlyphCanvas,
      0, 0,
      tightWidth, tightHeight,
      position.x + dx,
      position.y + dy,
      tightWidth, tightHeight
    );
  }

  drawPlaceholderRectangle(ctx, position, metrics, textColor) {
    const { tightWidth, tightHeight, dx, dy } = metrics;
    
    const rectX = position.x + dx;
    const rectY = position.y + dy;
    
    // Default to black if textColor is null or undefined
    const actualColor = textColor || 'black';
    
    // Draw a filled rectangle at the same position and size as the glyph would be
    ctx.fillStyle = actualColor;
    ctx.fillRect(rectX, rectY, tightWidth, tightHeight);
  }

  calculateLetterAdvancement(fontProperties, currentLetter, nextLetter) {
    return this.calculateAdvancement_CSS_Px(fontProperties, currentLetter, nextLetter) 
      * fontProperties.pixelDensity;
  }
}

// ============================================================================
// MAIN EXECUTION - Node.js Hello World Multi-Size Demo
// ============================================================================


// Node.js modules
const fs = require('fs');
const path = require('path');

// Set global variables (required by BitmapText)
global.loadedBitmapFontData = {};
global.isKerningEnabled = true;

// Font sizes to demonstrate
const fontSizes = [18, 18.5, 19];

// Create font properties for each size
const fontPropertiesArray = fontSizes.map(size => ({
  pixelDensity: 1,
  fontFamily: "Arial",
  fontStyle: "normal",
  fontWeight: "normal",
  fontSize: size
}));

// Function to create IDString from font size (matches browser version logic)
function createIDString(fontSize) {
  // Handle fractional sizes: 18.5 becomes "18-5", whole numbers get "-0" suffix
  const sizeStr = fontSize.toString().replace('.', '-');
  // Add "-0" suffix for whole numbers (18 -> "18-0"), fractional already have second part (18.5 -> "18-5")
  const finalSizeStr = sizeStr.includes('-') ? sizeStr : `${sizeStr}-0`;
  return `density-1-0-Arial-style-normal-weight-normal-size-${finalSizeStr}`;
}

function main() {
  try {
    console.log('BitmapText.js Node.js Multi-Size Demo - Loading font data...');
    
    // Create IDStrings for all font sizes
    const IDStrings = fontSizes.map(createIDString);
    console.log('Font sizes:', fontSizes);
    console.log('IDStrings:', IDStrings);
    
    // Load metrics for all font sizes
    const fontDataMap = new Map();
    
    for (let i = 0; i < fontSizes.length; i++) {
      const fontSize = fontSizes[i];
      const IDString = IDStrings[i];
      
      console.log(`Loading metrics for size ${fontSize}...`);
      
      // Load font metrics (JS file)
      const fontDataPath = path.resolve(__dirname, `../../font-assets/metrics-${IDString}.js`);
      if (!fs.existsSync(fontDataPath)) {
        throw new Error(`Font data file not found: ${fontDataPath}`);
      }
      
      // Execute the font data JS file to populate global.loadedBitmapFontData
      const fontDataCode = fs.readFileSync(fontDataPath, 'utf8');
      eval(fontDataCode);
      
      const fontData = global.loadedBitmapFontData[IDString];
      if (!fontData) {
        throw new Error(`Font data not found for ID: ${IDString}`);
      }
      
      fontDataMap.set(fontSize, fontData);
      console.log(`âœ“ Metrics loaded for size ${fontSize}`);
    }
    
    // Load QOI glyph sheets (check both main directory and removed-for-testing)
    const glyphSheetMap = new Map();
    
    for (let i = 0; i < fontSizes.length; i++) {
      const fontSize = fontSizes[i];
      const IDString = IDStrings[i];
      
      console.log(`Loading QOI glyph sheet for size ${fontSize}...`);
      
      // Only check main directory (like browser version)
      const qoiPath = path.resolve(__dirname, `../../font-assets/atlas-${IDString}.qoi`);
      
      if (fs.existsSync(qoiPath)) {
        console.log(`  â†³ Loading: ${path.basename(qoiPath)}`);
        const qoiBuffer = fs.readFileSync(qoiPath);
        const qoiData = QOIDecode(qoiBuffer.buffer, 0, null, 4); // Force RGBA output
        
        if (qoiData.error) {
          console.warn(`  â†³ Failed to decode QOI for size ${fontSize}, will use placeholder rectangles`);
          glyphSheetMap.set(fontSize, null);
        } else {
          console.log(`  â†³ QOI decoded: ${qoiData.width}x${qoiData.height}, ${qoiData.channels} channels`);
          const glyphSheetImage = new Image(qoiData.width, qoiData.height, new Uint8ClampedArray(qoiData.data));
          glyphSheetMap.set(fontSize, glyphSheetImage);
        }
      } else {
        console.warn(`  â†³ QOI file not found for size ${fontSize}, will use placeholder rectangles`);
        glyphSheetMap.set(fontSize, null);
      }
    }
    
    // Setup BitmapText system
    console.log('Setting up BitmapText system...');
    const bitmapGlyphStore = new BitmapGlyphStore();
    const bitmapText = new BitmapText(bitmapGlyphStore, () => new Canvas());
    
    // Process font data and populate glyph store for all sizes
    for (let i = 0; i < fontSizes.length; i++) {
      const fontSize = fontSizes[i];
      const fontProperties = fontPropertiesArray[i];
      const fontData = fontDataMap.get(fontSize);
      const glyphSheetImage = glyphSheetMap.get(fontSize);
      
      console.log(`Setting up font data for size ${fontSize}...`);
      
      bitmapGlyphStore.setKerningTable(fontProperties, fontData.kerningTable);
      bitmapGlyphStore.setGlyphsTextMetrics(fontProperties, fontData.glyphsTextMetrics);
      bitmapGlyphStore.setGlyphSheetMetrics(fontProperties, fontData.glyphSheetsMetrics);
      bitmapGlyphStore.setSpaceAdvancementOverrideForSmallSizesInPx(
        fontProperties,
        fontData.spaceAdvancementOverrideForSmallSizesInPx
      );
      
      if (glyphSheetImage) {
        bitmapGlyphStore.setGlyphSheet(fontProperties, glyphSheetImage);
        console.log(`  âœ“ Font size ${fontSize} ready with glyph sheet`);
      } else {
        console.log(`  âœ“ Font size ${fontSize} ready with placeholder mode (no glyph sheet)`);
      }
    }
    
    // Create output canvas (larger to accommodate multiple text lines)
    console.log('Creating canvas and rendering...');
    const canvas = new Canvas();
    canvas.width = 400;
    canvas.height = 200;
    const ctx = canvas.getContext('2d');
    
    // White background
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Render "Hello World" at each font size
    fontPropertiesArray.forEach((fontProperties, index) => {
      const yPosition = 50 + (index * 50); // Space lines 50px apart
      const text = `Hello World (size ${fontProperties.fontSize})`;
      
      console.log(`Rendering "${text}" at y=${yPosition}`);
      
      bitmapText.drawTextFromGlyphSheet(
        ctx,
        text,
        20,  // x position
        yPosition,
        fontProperties,
        '#000000'  // black color
      );
    });
    
    console.log('Multi-size text rendered successfully');
    
    // Export to PNG
    console.log('Encoding PNG...');
    const surface = {
      width: canvas.width,
      height: canvas.height,
      data: canvas.data
    };
    
    if (!PngEncoder.canEncode(surface)) {
      throw new Error('Surface cannot be encoded to PNG');
    }
    
    const pngBuffer = PngEncoder.encode(surface, PngEncodingOptions.DEFAULT);
    
    // Write PNG file
    const outputPath = path.resolve(process.cwd(), 'hello-world-multi-size-output.png');
    fs.writeFileSync(outputPath, Buffer.from(pngBuffer));
    
    console.log(`\nSuccess! ðŸŽ‰`);
    console.log(`Generated: ${outputPath}`);
    console.log(`Canvas size: ${canvas.width}x${canvas.height}`);
    console.log(`File size: ${fs.statSync(outputPath).size} bytes`);
    console.log(`\nThe PNG contains "Hello World" rendered at ${fontSizes.join(', ')} sizes using bitmap fonts.`);
    console.log(`Note: Sizes with missing QOI files will show black placeholder rectangles.`);
    
  } catch (error) {
    console.error('Error:', error.message);
    console.error('\nTroubleshooting:');
    console.error('1. Make sure you run this from the project root directory');
    console.error('2. Ensure font metrics exist for all sizes:', fontSizes.map(s => `metrics-density-1-0-Arial-style-normal-weight-normal-size-${s.toString().replace('.', '-')}${s.toString().includes('.') ? '' : '-0'}.js`).join(', '));
    console.error('3. QOI files are optional - missing ones will show placeholder rectangles');
    console.error('4. Generate fonts using public/font-builder.html if needed');
    process.exit(1);
  }
}

// Run the demo
if (require.main === module) {
  main();
}